/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => DendronTreePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian19 = require("obsidian");

// src/view.ts
var import_obsidian7 = require("obsidian");

// node_modules/svelte/internal/index.mjs
function noop() {
}
var identity = (x) => x;
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}
var is_client = typeof window !== "undefined";
var now = is_client ? () => window.performance.now() : () => Date.now();
var raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;
var tasks = /* @__PURE__ */ new Set();
function run_tasks(now2) {
  tasks.forEach((task) => {
    if (!task.c(now2)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0)
    raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_empty_stylesheet(node) {
  const style_element = element("style");
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function stop_propagation(fn) {
  return function(event) {
    event.stopPropagation();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = data;
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, cancelable, detail);
  return e;
}
var managed_styles = /* @__PURE__ */ new Map();
var active = 0;
function hash(str) {
  let hash2 = 5381;
  let i = str.length;
  while (i--)
    hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
  return hash2 >>> 0;
}
function create_style_information(doc, node) {
  const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
  managed_styles.set(doc, info);
  return info;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
  const step = 16.666 / duration;
  let keyframes = "{\n";
  for (let p = 0; p <= 1; p += step) {
    const t = a + (b - a) * ease(p);
    keyframes += p * 100 + `%{${fn(t, 1 - t)}}
`;
  }
  const rule = keyframes + `100% {${fn(b, 1 - b)}}
}`;
  const name = `__svelte_${hash(rule)}_${uid}`;
  const doc = get_root_for_style(node);
  const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
  if (!rules[name]) {
    rules[name] = true;
    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay}ms 1 both`;
  active += 1;
  return name;
}
function delete_rule(node, name) {
  const previous = (node.style.animation || "").split(", ");
  const next = previous.filter(
    name ? (anim) => anim.indexOf(name) < 0 : (anim) => anim.indexOf("__svelte") === -1
    // remove all Svelte animations
  );
  const deleted = previous.length - next.length;
  if (deleted) {
    node.style.animation = next.join(", ");
    active -= deleted;
    if (!active)
      clear_rules();
  }
}
function clear_rules() {
  raf(() => {
    if (active)
      return;
    managed_styles.forEach((info) => {
      const { ownerNode } = info.stylesheet;
      if (ownerNode)
        detach(ownerNode);
    });
    managed_styles.clear();
  });
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(type, detail, { cancelable });
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}
var promise;
function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
function dispatch(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
var null_transition = { duration: 0 };
function create_bidirectional_transition(node, fn, params, intro) {
  const options = { direction: "both" };
  let config = fn(node, params, options);
  let t = intro ? 0 : 1;
  let running_program = null;
  let pending_program = null;
  let animation_name = null;
  function clear_animation() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function init2(program, duration) {
    const d = program.b - t;
    duration *= Math.abs(d);
    return {
      a: t,
      b: program.b,
      d,
      duration,
      start: program.start,
      end: program.start + duration,
      group: program.group
    };
  }
  function go(b) {
    const { delay = 0, duration = 300, easing = identity, tick: tick2 = noop, css } = config || null_transition;
    const program = {
      start: now() + delay,
      b
    };
    if (!b) {
      program.group = outros;
      outros.r += 1;
    }
    if (running_program || pending_program) {
      pending_program = program;
    } else {
      if (css) {
        clear_animation();
        animation_name = create_rule(node, t, b, duration, delay, easing, css);
      }
      if (b)
        tick2(0, 1);
      running_program = init2(program, duration);
      add_render_callback(() => dispatch(node, b, "start"));
      loop((now2) => {
        if (pending_program && now2 > pending_program.start) {
          running_program = init2(pending_program, duration);
          pending_program = null;
          dispatch(node, running_program.b, "start");
          if (css) {
            clear_animation();
            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
          }
        }
        if (running_program) {
          if (now2 >= running_program.end) {
            tick2(t = running_program.b, 1 - t);
            dispatch(node, running_program.b, "end");
            if (!pending_program) {
              if (running_program.b) {
                clear_animation();
              } else {
                if (!--running_program.group.r)
                  run_all(running_program.group.c);
              }
            }
            running_program = null;
          } else if (now2 >= running_program.start) {
            const p = now2 - running_program.start;
            t = running_program.a + running_program.d * easing(p / running_program.duration);
            tick2(t, 1 - t);
          }
        }
        return !!(running_program || pending_program);
      });
    }
  }
  return {
    run(b) {
      if (is_function(config)) {
        wait().then(() => {
          config = config(options);
          go(b);
        });
      } else {
        go(b);
      }
    },
    end() {
      clear_animation();
      running_program = pending_program = null;
    }
  };
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block3, next, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i = o;
  const old_indexes = {};
  while (i--)
    old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i = n;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block3(key, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n--;
  }
  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n)
    insert2(new_blocks[n - 1]);
  run_all(updates);
  return new_blocks;
}
var _boolean_attributes = [
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
];
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);
function bind(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance3, create_fragment3, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance3 ? instance3(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment3 ? create_fragment3($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/tslib/tslib.es6.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/svelte/easing/index.mjs
function cubicOut(t) {
  const f = t - 1;
  return f * f * f + 1;
}

// node_modules/svelte/transition/index.mjs
function slide(node, { delay = 0, duration = 400, easing = cubicOut, axis = "y" } = {}) {
  const style = getComputedStyle(node);
  const opacity = +style.opacity;
  const primary_property = axis === "y" ? "height" : "width";
  const primary_property_value = parseFloat(style[primary_property]);
  const secondary_properties = axis === "y" ? ["top", "bottom"] : ["left", "right"];
  const capitalized_secondary_properties = secondary_properties.map((e) => `${e[0].toUpperCase()}${e.slice(1)}`);
  const padding_start_value = parseFloat(style[`padding${capitalized_secondary_properties[0]}`]);
  const padding_end_value = parseFloat(style[`padding${capitalized_secondary_properties[1]}`]);
  const margin_start_value = parseFloat(style[`margin${capitalized_secondary_properties[0]}`]);
  const margin_end_value = parseFloat(style[`margin${capitalized_secondary_properties[1]}`]);
  const border_width_start_value = parseFloat(style[`border${capitalized_secondary_properties[0]}Width`]);
  const border_width_end_value = parseFloat(style[`border${capitalized_secondary_properties[1]}Width`]);
  return {
    delay,
    duration,
    easing,
    css: (t) => `overflow: hidden;opacity: ${Math.min(t * 20, 1) * opacity};${primary_property}: ${t * primary_property_value}px;padding-${secondary_properties[0]}: ${t * padding_start_value}px;padding-${secondary_properties[1]}: ${t * padding_end_value}px;margin-${secondary_properties[0]}: ${t * margin_start_value}px;margin-${secondary_properties[1]}: ${t * margin_end_value}px;border-${secondary_properties[0]}-width: ${t * border_width_start_value}px;border-${secondary_properties[1]}-width: ${t * border_width_end_value}px;`
  };
}

// src/engine/note.ts
var Note = class {
  constructor(originalName, titlecase) {
    this.originalName = originalName;
    this.titlecase = titlecase;
    this.children = [];
    this.title = "";
    this.name = originalName.toLowerCase();
    this.syncMetadata(void 0);
  }
  appendChild(note) {
    if (note.parent)
      throw Error("Note has parent");
    note.parent = this;
    this.children.push(note);
  }
  removeChildren(note) {
    note.parent = void 0;
    const index = this.children.indexOf(note);
    this.children.splice(index, 1);
  }
  findChildren(name) {
    const lower = name.toLowerCase();
    return this.children.find((note) => note.name == lower);
  }
  sortChildren(rescursive) {
    this.children.sort((a, b) => a.title.localeCompare(b.title));
    if (rescursive)
      this.children.forEach((child) => child.sortChildren(rescursive));
  }
  getPath(original = false) {
    const component = [];
    const notes = this.getPathNotes();
    if (notes.length === 1)
      return original ? notes[0].originalName : notes[0].name;
    for (const note of notes) {
      if (!note.parent && note.name === "root")
        continue;
      component.push(original ? note.originalName : note.name);
    }
    return component.join(".");
  }
  getPathNotes() {
    const notes = [];
    let current = this;
    while (current) {
      notes.unshift(current);
      current = current.parent;
    }
    return notes;
  }
  syncMetadata(metadata) {
    var _a;
    this.title = (_a = metadata == null ? void 0 : metadata.title) != null ? _a : generateNoteTitle(this.originalName, this.titlecase);
  }
};
function isUseTitleCase(baseName) {
  return baseName.toLowerCase() === baseName;
}
function generateNoteTitle(originalName, titlecase) {
  if (!titlecase)
    return originalName;
  return originalName.split("-").map((item) => item.trim()).filter((item) => item.length > 0).map((word) => {
    return word[0].toUpperCase() + word.substring(1).toLowerCase();
  }).join(" ");
}
var NoteTree = class {
  constructor() {
    this.root = new Note("root", true);
  }
  sort() {
    this.root.sortChildren(true);
  }
  static getPathFromFileName(name) {
    return name.split(".");
  }
  static isRootPath(path) {
    return path.length === 1 && path[0] === "root";
  }
  addFile(file, sort = false) {
    const titlecase = isUseTitleCase(file.basename);
    const path = NoteTree.getPathFromFileName(file.basename);
    let currentNote = this.root;
    if (!NoteTree.isRootPath(path))
      for (const name of path) {
        let note = currentNote.findChildren(name);
        if (!note) {
          note = new Note(name, titlecase);
          currentNote.appendChild(note);
          if (sort)
            currentNote.sortChildren(false);
        }
        currentNote = note;
      }
    currentNote.file = file;
    return currentNote;
  }
  getFromFileName(name) {
    const path = NoteTree.getPathFromFileName(name);
    if (NoteTree.isRootPath(path))
      return this.root;
    let currentNote = this.root;
    for (const name2 of path) {
      const found = currentNote.findChildren(name2);
      if (!found)
        return void 0;
      currentNote = found;
    }
    return currentNote;
  }
  deleteByFileName(name) {
    const note = this.getFromFileName(name);
    if (!note)
      return;
    note.file = void 0;
    if (note.children.length == 0) {
      let currentNote = note;
      while (currentNote && currentNote.parent && !currentNote.file && currentNote.children.length == 0) {
        const parent = currentNote.parent;
        parent.removeChildren(currentNote);
        currentNote = parent;
      }
    }
    return note;
  }
  static *flattenInternal(root) {
    yield root;
    for (const child of root.children)
      yield* this.flattenInternal(child);
  }
  flatten() {
    return Array.from(NoteTree.flattenInternal(this.root));
  }
};

// src/components/NoteComponent.svelte
var import_obsidian6 = require("obsidian");

// node_modules/svelte/store/index.mjs
var subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  const auto = fn.length < 2;
  return readable(initial_value, (set) => {
    let started = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set);
      if (auto) {
        set(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    };
    const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
      values[i] = value;
      pending &= ~(1 << i);
      if (started) {
        sync();
      }
    }, () => {
      pending |= 1 << i;
    }));
    started = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    };
  });
}

// src/store.ts
var plugin = writable();
var getPlugin = () => get_store_value(plugin);
var activeFile = writable();
var dendronVaultList = writable([]);
var showVaultPath = derived(dendronVaultList, ($list) => $list.length > 1);

// src/utils.ts
var import_obsidian = require("obsidian");

// node_modules/nanoid/index.browser.js
var random = (bytes) => crypto.getRandomValues(new Uint8Array(bytes));
var customRandom = (alphabet, defaultSize, getRandom) => {
  let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
  let step = -~(1.6 * mask * defaultSize / alphabet.length);
  return (size = defaultSize) => {
    let id = "";
    while (true) {
      let bytes = getRandom(step);
      let j = step;
      while (j--) {
        id += alphabet[bytes[j] & mask] || "";
        if (id.length === size)
          return id;
      }
    }
  };
};
var customAlphabet = (alphabet, size = 21) => customRandom(alphabet, size, random);

// src/utils.ts
function getFolderFile(vault, path) {
  return path.length === 0 ? vault.getRoot() : vault.getAbstractFileByPath(path);
}
function openFile(app2, file, props = {}) {
  if (!file || !(file instanceof import_obsidian.TFile))
    return;
  const leaf = props.openTarget === "new-window" ? app2.workspace.openPopoutLeaf() : props.openTarget === "new-leaf" ? app2.workspace.createLeafBySplit(app2.workspace.getLeaf()) : app2.workspace.getLeaf(props.openTarget === "new-tab");
  return leaf.openFile(file, props.openState);
}
var alphanumericLowercase = "0123456789abcdefghijklmnopqrstuvwxyz";
var generateUUID = customAlphabet(alphanumericLowercase, 23);

// src/modal/lookup.ts
var import_obsidian3 = require("obsidian");

// src/modal/select-vault.ts
var import_obsidian2 = require("obsidian");
var SelectVaultModal = class extends import_obsidian2.SuggestModal {
  constructor(app2, workspace, onSelected) {
    super(app2);
    this.workspace = workspace;
    this.onSelected = onSelected;
  }
  getSuggestions(query) {
    const queryLowercase = query.toLowerCase();
    return this.workspace.vaultList.filter(
      (value) => value.config.path.toLowerCase().contains(queryLowercase) || value.config.name.toLowerCase().contains(queryLowercase)
    );
  }
  renderSuggestion(value, el) {
    el.createEl("div", { text: value.config.name });
    el.createEl("small", {
      text: value.config.path
    });
  }
  onChooseSuggestion(item, evt) {
    this.onSelected(item);
  }
};

// src/modal/lookup.ts
var LookupModal = class extends import_obsidian3.SuggestModal {
  constructor(app2, workspace, initialQuery = "") {
    super(app2);
    this.workspace = workspace;
    this.initialQuery = initialQuery;
  }
  onOpen() {
    super.onOpen();
    if (this.initialQuery.length > 0) {
      this.inputEl.value = this.initialQuery;
      this.inputEl.dispatchEvent(new Event("input"));
    }
  }
  getSuggestions(query) {
    const queryLowercase = query.toLowerCase();
    const result = [];
    let foundExact = true;
    for (const vault of this.workspace.vaultList) {
      let currentFoundExact = false;
      for (const note of vault.tree.flatten()) {
        const path = note.getPath();
        const item = {
          note,
          vault
        };
        if (path === queryLowercase) {
          currentFoundExact = true;
          result.unshift(item);
          continue;
        }
        if (note.title.toLowerCase().includes(queryLowercase) || note.name.includes(queryLowercase) || path.includes(queryLowercase))
          result.push(item);
      }
      foundExact = foundExact && currentFoundExact;
    }
    if (!foundExact && queryLowercase.trim().length > 0)
      result.unshift(null);
    return result;
  }
  renderSuggestion(item, el) {
    el.classList.add("mod-complex");
    el.createEl("div", { cls: "suggestion-content" }, (el2) => {
      var _a;
      el2.createEl("div", { text: (_a = item == null ? void 0 : item.note.title) != null ? _a : "Create New", cls: "suggestion-title" });
      el2.createEl("small", {
        text: item ? item.note.getPath() + (this.workspace.vaultList.length > 1 ? ` (${item.vault.config.name})` : "") : "Note does not exist",
        cls: "suggestion-content"
      });
    });
    if (!item || !item.note.file)
      el.createEl("div", { cls: "suggestion-aux" }, (el2) => {
        el2.append((0, import_obsidian3.getIcon)("plus"));
      });
  }
  async onChooseSuggestion(item, evt) {
    if (item && item.note.file) {
      openFile(this.app, item.note.file);
      return;
    }
    const path = item ? item.note.getPath() : this.inputEl.value;
    const doCreate = async (vault) => {
      const file = await vault.createNote(path);
      return openFile(vault.app, file);
    };
    if (item == null ? void 0 : item.vault) {
      await doCreate(item.vault);
    } else if (this.workspace.vaultList.length == 1) {
      await doCreate(this.workspace.vaultList[0]);
    } else {
      new SelectVaultModal(this.app, this.workspace, doCreate).open();
    }
  }
};

// src/engine/vault.ts
var import_obsidian5 = require("obsidian");

// src/modal/invalid-root.ts
var import_obsidian4 = require("obsidian");
var InvalidRootModal = class extends import_obsidian4.Modal {
  constructor(dendronVault) {
    super(dendronVault.app);
    this.dendronVault = dendronVault;
  }
  onOpen() {
    this.contentEl.createEl("h1", { text: "Invalid Root" });
    this.contentEl.createEl("p", {
      text: `"${this.dendronVault.config.path}" is not folder. Do you want to create this folder?`
    });
    new import_obsidian4.Setting(this.contentEl).addButton((button) => {
      button.setButtonText("Create").setCta().onClick(async () => {
        await this.dendronVault.createRootFolder();
        this.dendronVault.init();
        this.close();
      });
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/engine/vault.ts
var DendronVault = class {
  constructor(app2, config) {
    this.app = app2;
    this.config = config;
    this.isIniatialized = false;
  }
  resolveMetadata(file) {
    var _a;
    const frontmatter = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
    if (!frontmatter)
      return void 0;
    return {
      title: frontmatter["title"]
    };
  }
  init() {
    if (this.isIniatialized)
      return;
    this.tree = new NoteTree();
    const root = getFolderFile(this.app.vault, this.config.path);
    if (!(root instanceof import_obsidian5.TFolder)) {
      new InvalidRootModal(this).open();
      return;
    }
    this.folder = root;
    for (const child of root.children)
      if (child instanceof import_obsidian5.TFile && this.isNote(child.extension))
        this.tree.addFile(child).syncMetadata(this.resolveMetadata(child));
    this.tree.sort();
    this.isIniatialized = true;
  }
  async createRootFolder() {
    return await this.app.vault.createFolder(this.config.path);
  }
  async createNote(baseName) {
    const filePath = `${this.config.path}/${baseName}.md`;
    return await this.app.vault.create(filePath, "");
  }
  async generateFronmatter(file) {
    if (!this.isNote(file.extension))
      return;
    const note = this.tree.getFromFileName(file.basename);
    if (!note)
      return false;
    return await this.app.fileManager.processFrontMatter(file, (fronmatter) => {
      if (!fronmatter.id)
        fronmatter.id = generateUUID();
      if (!fronmatter.title)
        fronmatter.title = note.title;
      if (fronmatter.desc === void 0)
        fronmatter.desc = "";
      if (!fronmatter.created)
        fronmatter.created = file.stat.ctime;
      if (!fronmatter.updated)
        fronmatter.updated = file.stat.mtime;
    });
  }
  isNote(extension) {
    return extension === "md";
  }
  onFileCreated(file) {
    if (!(file instanceof import_obsidian5.TFile) || !this.isNote(file.extension))
      return false;
    this.tree.addFile(file, true).syncMetadata(this.resolveMetadata(file));
    return true;
  }
  onMetadataChanged(file) {
    var _a;
    if (!this.isNote(file.extension))
      return false;
    const note = this.tree.getFromFileName(file.basename);
    if (!note)
      return false;
    note.syncMetadata(this.resolveMetadata(file));
    (_a = note.parent) == null ? void 0 : _a.sortChildren(false);
    return true;
  }
  onFileDeleted(parsed) {
    if (!this.isNote(parsed.extension))
      return false;
    const note = this.tree.deleteByFileName(parsed.basename);
    if (note == null ? void 0 : note.parent) {
      note.syncMetadata(void 0);
    }
    return true;
  }
};

// src/components/NoteComponent.svelte
function add_css(target) {
  append_styles(target, "svelte-8xqvxp", ".dendron-tree-not-found.svelte-8xqvxp{background:rgb(var(--callout-warning));width:var(--size-4-2);height:var(--size-4-2);border-radius:100%;flex-shrink:0;margin-left:var(--size-2-3);align-self:center}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i];
  child_ctx[27] = list;
  child_ctx[28] = i;
  return child_ctx;
}
function create_if_block_2(ctx) {
  let div;
  let icon_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", "tree-item-icon collapse-icon");
      toggle_class(
        div,
        "is-collapsed",
        /*isCollapsed*/
        ctx[4]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(icon_action = /*icon*/
          ctx[9].call(null, div)),
          listen(div, "click", stop_propagation(
            /*click_handler*/
            ctx[16]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*isCollapsed*/
      16) {
        toggle_class(
          div,
          "is-collapsed",
          /*isCollapsed*/
          ctx2[4]
        );
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "dendron-tree-not-found svelte-8xqvxp");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div_transition;
  let current;
  let mounted;
  let dispose;
  let each_value = (
    /*note*/
    ctx[0].children
  );
  const get_key = (ctx2) => (
    /*child*/
    ctx2[26].name
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "tree-item-children");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div,
            "introstart",
            /*expandTransitionStart*/
            ctx[12]
          ),
          listen(
            div,
            "introend",
            /*introend_handler*/
            ctx[21]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*note, vault, childrenFocus*/
      69) {
        each_value = /*note*/
        ctx2[0].children;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block, null, get_each_context);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      add_render_callback(() => {
        if (!current)
          return;
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration: 100 }, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, slide, { duration: 100 }, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block(key_1, ctx) {
  let first;
  let notecomponent;
  let updating_focusNotes;
  let current;
  function notecomponent_focusNotes_binding(value) {
    ctx[19](
      value,
      /*child*/
      ctx[26]
    );
  }
  let notecomponent_props = {
    note: (
      /*child*/
      ctx[26]
    ),
    vault: (
      /*vault*/
      ctx[2]
    )
  };
  if (
    /*childrenFocus*/
    ctx[6][
      /*child*/
      ctx[26].name
    ] !== void 0
  ) {
    notecomponent_props.focusNotes = /*childrenFocus*/
    ctx[6][
      /*child*/
      ctx[26].name
    ];
  }
  notecomponent = new NoteComponent({ props: notecomponent_props });
  binding_callbacks.push(() => bind(notecomponent, "focusNotes", notecomponent_focusNotes_binding));
  notecomponent.$on(
    "openNote",
    /*openNote_handler*/
    ctx[20]
  );
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(notecomponent.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(notecomponent, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const notecomponent_changes = {};
      if (dirty & /*note*/
      1)
        notecomponent_changes.note = /*child*/
        ctx[26];
      if (dirty & /*vault*/
      4)
        notecomponent_changes.vault = /*vault*/
        ctx[2];
      if (!updating_focusNotes && dirty & /*childrenFocus, note*/
      65) {
        updating_focusNotes = true;
        notecomponent_changes.focusNotes = /*childrenFocus*/
        ctx[6][
          /*child*/
          ctx[26].name
        ];
        add_flush_callback(() => updating_focusNotes = false);
      }
      notecomponent.$set(notecomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(notecomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notecomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(notecomponent, detaching);
    }
  };
}
function create_fragment(ctx) {
  let div2;
  let div1;
  let t0;
  let div0;
  let t1_value = (
    /*note*/
    ctx[0].title + /*isRoot*/
    (ctx[1] && /*$showVaultPath*/
    ctx[8] ? ` (${/*vault*/
    ctx[2].config.name})` : "")
  );
  let t1;
  let t2;
  let t3;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*note*/
    ctx[0].children.length > 0 && create_if_block_2(ctx)
  );
  let if_block1 = !/*note*/
  ctx[0].file && create_if_block_1(ctx);
  let if_block2 = (
    /*note*/
    ctx[0].children.length > 0 && !/*isCollapsed*/
    ctx[4] && create_if_block(ctx)
  );
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      t1 = text(t1_value);
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      attr(div0, "class", "tree-item-inner");
      attr(div1, "class", "tree-item-self is-clickable mod-collapsible is-active");
      toggle_class(
        div1,
        "is-active",
        /*isActive*/
        ctx[7]
      );
      attr(div2, "class", "tree-item is-clickable");
      toggle_class(
        div2,
        "is-collapsed",
        /*isCollapsed*/
        ctx[4]
      );
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      if (if_block0)
        if_block0.m(div1, null);
      append(div1, t0);
      append(div1, div0);
      append(div0, t1);
      append(div1, t2);
      if (if_block1)
        if_block1.m(div1, null);
      ctx[18](div1);
      append(div2, t3);
      if (if_block2)
        if_block2.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div1,
            "click",
            /*click_handler_1*/
            ctx[17]
          ),
          listen(
            div1,
            "contextmenu",
            /*openMenu*/
            ctx[11]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*note*/
        ctx2[0].children.length > 0
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2(ctx2);
          if_block0.c();
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if ((!current || dirty & /*note, isRoot, $showVaultPath, vault*/
      263) && t1_value !== (t1_value = /*note*/
      ctx2[0].title + /*isRoot*/
      (ctx2[1] && /*$showVaultPath*/
      ctx2[8] ? ` (${/*vault*/
      ctx2[2].config.name})` : "")))
        set_data(t1, t1_value);
      if (!/*note*/
      ctx2[0].file) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block_1(ctx2);
          if_block1.c();
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty & /*isActive*/
      128) {
        toggle_class(
          div1,
          "is-active",
          /*isActive*/
          ctx2[7]
        );
      }
      if (
        /*note*/
        ctx2[0].children.length > 0 && !/*isCollapsed*/
        ctx2[4]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*note, isCollapsed*/
          17) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*isCollapsed*/
      16) {
        toggle_class(
          div2,
          "is-collapsed",
          /*isCollapsed*/
          ctx2[4]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      ctx[18](null);
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let isActive;
  let $activeFile;
  let $showVaultPath;
  component_subscribe($$self, activeFile, ($$value) => $$invalidate(15, $activeFile = $$value));
  component_subscribe($$self, showVaultPath, ($$value) => $$invalidate(8, $showVaultPath = $$value));
  let { note } = $$props;
  let { isRoot = false } = $$props;
  let { vault } = $$props;
  let headerElement;
  let isCollapsed = true;
  const icon = function(node) {
    node.appendChild((0, import_obsidian6.getIcon)("right-triangle"));
  };
  function openNoteFile(target) {
    openFile(getPlugin().app, note.file, { openTarget: target });
  }
  function createCurrentNote() {
    return __awaiter(this, void 0, void 0, function* () {
      const path = note.getPath(true);
      const plugin2 = getPlugin();
      const file = yield vault.createNote(path);
      openFile(plugin2.app, file);
    });
  }
  function deleteCurrentNote() {
    const plugin2 = getPlugin();
    if (!note.file)
      return;
    plugin2.app.vault.delete(note.file);
  }
  function openLookup() {
    const { app: app2, workspace } = getPlugin();
    new LookupModal(app2, workspace, note.getPath(true)).open();
  }
  function openMenu(e) {
    const menu = new import_obsidian6.Menu();
    if (note.file) {
      menu.addItem((item) => {
        item.setTitle("Open in new tab").setIcon("lucide-file-plus").onClick(() => openNoteFile("new-tab"));
      });
      menu.addItem((item) => {
        item.setTitle("Open to the right").setIcon("lucide-separator-vertical").onClick(() => openNoteFile("new-leaf"));
      });
      if (import_obsidian6.Platform.isDesktopApp) {
        menu.addItem((item) => {
          item.setTitle("Open in new window").setIcon("lucide-maximize").onClick(() => openNoteFile("new-window"));
        });
      }
      menu.addSeparator();
    }
    if (!note.file) {
      menu.addItem((item) => {
        item.setTitle("Create Current Note").setIcon("create-new").onClick(createCurrentNote);
      });
    }
    menu.addItem((item) => {
      item.setTitle("Create New Note").setIcon("plus").onClick(openLookup);
    });
    if (note.file)
      menu.addItem((item) => {
        item.setTitle("Delete Note").setIcon("trash").onClick(deleteCurrentNote);
      });
    menu.showAtMouseEvent(e);
  }
  let expandTransitionWaiter = Promise.resolve();
  let expandTransitionEnd;
  function expandTransitionStart() {
    expandTransitionWaiter = new Promise((resolve) => {
      $$invalidate(5, expandTransitionEnd = resolve);
    });
  }
  const childrenFocus = {};
  const focusNotes = (pathNotes) => __awaiter(void 0, void 0, void 0, function* () {
    const nextNote = pathNotes.shift();
    if (nextNote) {
      $$invalidate(4, isCollapsed = false);
      yield tick();
      const focusFN = childrenFocus[nextNote.name];
      if (!focusFN)
        return;
      if (pathNotes.length === 0)
        yield expandTransitionWaiter;
      focusFN(pathNotes);
    } else
      headerElement.scrollIntoView({ block: "center" });
  });
  const dispatcher = createEventDispatcher();
  const click_handler = () => {
    $$invalidate(4, isCollapsed = !isCollapsed);
  };
  const click_handler_1 = () => {
    dispatcher("openNote", note);
    openNoteFile(void 0);
    $$invalidate(4, isCollapsed = false);
  };
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      headerElement = $$value;
      $$invalidate(3, headerElement);
    });
  }
  function notecomponent_focusNotes_binding(value, child) {
    if ($$self.$$.not_equal(childrenFocus[child.name], value)) {
      childrenFocus[child.name] = value;
      $$invalidate(6, childrenFocus);
    }
  }
  function openNote_handler(event) {
    bubble.call(this, $$self, event);
  }
  const introend_handler = () => {
    expandTransitionEnd();
  };
  $$self.$$set = ($$props2) => {
    if ("note" in $$props2)
      $$invalidate(0, note = $$props2.note);
    if ("isRoot" in $$props2)
      $$invalidate(1, isRoot = $$props2.isRoot);
    if ("vault" in $$props2)
      $$invalidate(2, vault = $$props2.vault);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*note, $activeFile*/
    32769) {
      $:
        $$invalidate(7, isActive = note.file && $activeFile === note.file);
    }
  };
  return [
    note,
    isRoot,
    vault,
    headerElement,
    isCollapsed,
    expandTransitionEnd,
    childrenFocus,
    isActive,
    $showVaultPath,
    icon,
    openNoteFile,
    openMenu,
    expandTransitionStart,
    dispatcher,
    focusNotes,
    $activeFile,
    click_handler,
    click_handler_1,
    div1_binding,
    notecomponent_focusNotes_binding,
    openNote_handler,
    introend_handler
  ];
}
var NoteComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        note: 0,
        isRoot: 1,
        vault: 2,
        focusNotes: 14
      },
      add_css
    );
  }
  get focusNotes() {
    return this.$$.ctx[14];
  }
};
var NoteComponent_default = NoteComponent;

// src/components/MainComponent.svelte
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  child_ctx[7] = list;
  child_ctx[8] = i;
  return child_ctx;
}
function create_each_block2(key_1, ctx) {
  let first;
  let notecomponent;
  let vault = (
    /*vault*/
    ctx[6]
  );
  let current;
  const assign_notecomponent = () => (
    /*notecomponent_binding*/
    ctx[4](notecomponent, vault)
  );
  const unassign_notecomponent = () => (
    /*notecomponent_binding*/
    ctx[4](null, vault)
  );
  let notecomponent_props = {
    note: (
      /*vault*/
      ctx[6].tree.root
    ),
    isRoot: true,
    vault: (
      /*vault*/
      ctx[6]
    )
  };
  notecomponent = new NoteComponent_default({ props: notecomponent_props });
  assign_notecomponent();
  notecomponent.$on(
    "openNote",
    /*onOpenNote*/
    ctx[2]
  );
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(notecomponent.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(notecomponent, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (vault !== /*vault*/
      ctx[6]) {
        unassign_notecomponent();
        vault = /*vault*/
        ctx[6];
        assign_notecomponent();
      }
      const notecomponent_changes = {};
      if (dirty & /*$dendronVaultList*/
      2)
        notecomponent_changes.note = /*vault*/
        ctx[6].tree.root;
      if (dirty & /*$dendronVaultList*/
      2)
        notecomponent_changes.vault = /*vault*/
        ctx[6];
      notecomponent.$set(notecomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(notecomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notecomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      unassign_notecomponent();
      destroy_component(notecomponent, detaching);
    }
  };
}
function create_fragment2(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = (
    /*$dendronVaultList*/
    ctx[1]
  );
  const get_key = (ctx2) => (
    /*vault*/
    ctx2[6].config.name
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block2(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$dendronVaultList, children, onOpenNote*/
      7) {
        each_value = /*$dendronVaultList*/
        ctx2[1];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block2, null, get_each_context2);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let $dendronVaultList;
  component_subscribe($$self, dendronVaultList, ($$value) => $$invalidate(1, $dendronVaultList = $$value));
  const children2 = {};
  let pendingOpenNote = null;
  function focusTo(vault, note) {
    if (pendingOpenNote === note) {
      pendingOpenNote = null;
      return;
    }
    const vaultComponent = children2[vault.config.name];
    if (!vaultComponent)
      return;
    const pathNotes = note.getPathNotes();
    pathNotes.shift();
    vaultComponent.focusNotes(pathNotes);
  }
  function onOpenNote(e) {
    pendingOpenNote = e.detail;
  }
  function notecomponent_binding($$value, vault) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      children2[vault.config.name] = $$value;
      $$invalidate(0, children2);
    });
  }
  return [children2, $dendronVaultList, onOpenNote, focusTo, notecomponent_binding];
}
var MainComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, { focusTo: 3 });
  }
  get focusTo() {
    return this.$$.ctx[3];
  }
};
var MainComponent_default = MainComponent;

// src/icons.ts
var dendronActivityBarName = "dendron-activity-bar";
var dendronActivityBarIcon = `<path d="M51.263 53.512a5.349 5.349 0 0 0-5.349 5.348 5.349 5.349 0 0 0 2.399 4.456c.014-.185.031-.356.031-.595h5.814c0 .221-.014.436-.027.652a5.349 5.349 0 0 0 2.48-4.513 5.349 5.349 0 0 0-5.348-5.348zm-2.95 9.804a5.349 5.349 0 0 0 .201.122 5.349 5.349 0 0 1-.201-.122zm.201.122a5.349 5.349 0 0 0 .4.219 5.349 5.349 0 0 1-.4-.219zm.4.219a5.349 5.349 0 0 0 .177.088 5.349 5.349 0 0 1-.177-.088zm.177.088a5.349 5.349 0 0 0 .562.21 5.349 5.349 0 0 1-.562-.21zm.562.21a5.349 5.349 0 0 0 .187.056 5.349 5.349 0 0 1-.187-.057zm.187.056a5.349 5.349 0 0 0 .603.131 5.349 5.349 0 0 1-.603-.131Zm.603.131a5.349 5.349 0 0 0 .152.02 5.349 5.349 0 0 1-.152-.02Zm.152.02a5.349 5.349 0 0 0 .668.047 5.349 5.349 0 0 1-.668-.047Zm.668.047a5.349 5.349 0 0 0 .669-.048 5.349 5.349 0 0 1-.67.048zm.669-.048a5.349 5.349 0 0 0 .18-.025 5.349 5.349 0 0 1-.18.026zm.18-.025a5.349 5.349 0 0 0 .645-.14 5.349 5.349 0 0 1-.644.14zm2.017-.762a5.349 5.349 0 0 1-.559.305 5.349 5.349 0 0 0 .56-.305zm-.559.305a5.349 5.349 0 0 1-.185.084 5.349 5.349 0 0 0 .185-.084zm-.185.084a5.349 5.349 0 0 1-.561.21 5.349 5.349 0 0 0 .56-.21zm-.561.21a5.349 5.349 0 0 1-.067.022 5.349 5.349 0 0 0 .067-.022zm20.218-8.717c-2.223 0-4.058 1.835-4.058 4.058s1.835 4.058 4.058 4.058c2.222 0 4.058-1.835 4.058-4.058s-1.836-4.058-4.058-4.058zm0 3.14c.526 0 .918.392.918.918a.896.896 0 0 1-.918.919.896.896 0 0 1-.919-.919c0-.526.393-.919.919-.919zM53.154 43.51c-.798 4.917 2.592 9.621 7.51 10.42 4.916.797 9.62-2.593 10.419-7.51.797-4.917-2.593-9.621-7.51-10.419s-9.621 2.593-10.419 7.51zm5.739.932c.294-1.816 1.933-2.997 3.749-2.702 1.815.295 2.996 1.933 2.702 3.749-.295 1.815-1.934 2.996-3.75 2.701-1.815-.294-2.996-1.933-2.701-3.748zM42.46 18.465c-6.727 0-12.244 5.516-12.244 12.244s5.517 12.244 12.244 12.244c6.728 0 12.245-5.516 12.245-12.244S49.188 18.465 42.46 18.465zm0 5.814a6.387 6.387 0 0 1 6.43 6.43 6.387 6.387 0 0 1-6.43 6.43 6.387 6.387 0 0 1-6.43-6.43 6.387 6.387 0 0 1 6.43-6.43zm28.547 38.186v5.116c0 1.432-.194 1.47-.662 1.777a2.75 2.75 0 0 1-.439.22l-.022.01-.064.024c-.276.11-.628.234-1.02.371-.385.136-.817.29-1.283.477l-.01.003-.001.001-14.22 5-.032.013c-1.121.439-3.369 1.019-5.427 2.193-2.058 1.174-4.164 3.413-4.003 6.528l-.003-.105v14.956a50 50 0 0 0 3.71.265 50 50 0 0 0 .36-.026V84.04l-.003-.052c-.072-1.385.555-1.984 1.956-2.783 1.401-.8 3.34-1.33 4.893-1.938l-.067.025 14.231-5.004.045-.018c.905-.367 2.238-.593 3.633-1.51 1.395-.916 2.498-2.82 2.498-5.179v-5.116Zm-3.49 7.995zM39.6 41.453V73.67c-.03.306-.047.617-.047.935h.047v24.023a50 50 0 0 0 7.93.686 50 50 0 0 0 3.047-.218v-5.02l-.002-.053c-.05-1.37.239-1.562.97-2.113.73-.55 1.932-.957 3.326-1.722l-.04.021 4.38-2.317c.76-.38 2.244-.973 3.572-2.394 1.335-1.427 2.236-3.671 2.236-6.417V52.395h-5.814v26.686c0 1.662-.332 2.086-.669 2.447-.337.36-.952.674-1.952 1.178l-.027.013-4.464 2.361-.02.011c-.513.282-2.293.869-4.028 2.176-1.022.77-2.009 1.974-2.631 3.467v-16.94c.078-.574.253-.763.496-1.011.332-.339 1.085-.756 2.205-1.295 1.121-.54 2.617-1.218 3.916-2.65 1.3-1.433 2.127-3.597 2.127-6.117h-5.814c0 .72-.067 1.176-.178 1.5a1.737 1.737 0 0 1-.198.407 2.522 2.522 0 0 1-.244.304c-.349.385-1.051.798-2.128 1.316l-.182.087V41.453Zm11-35.639c5.965 0 11.756 1.163 17.198 3.465a43.866 43.866 0 0 1 14.046 9.477 44.246 44.246 0 0 1 9.477 14.046c2.302 5.442 3.465 11.233 3.465 17.198s-1.163 11.756-3.465 17.198a43.866 43.866 0 0 1-9.477 14.046 44.246 44.246 0 0 1-14.046 9.477c-5.454 2.302-11.233 3.465-17.198 3.465s-11.756-1.163-17.198-3.465a43.866 43.866 0 0 1-14.046-9.477 44.246 44.246 0 0 1-9.477-14.046C7.577 61.756 6.414 55.965 6.414 50s1.163-11.756 3.465-17.198a43.866 43.866 0 0 1 9.477-14.046 44.246 44.246 0 0 1 14.046-9.477A44.073 44.073 0 0 1 50.6 5.814M50.6 0C22.984 0 .6 22.384.6 50s22.384 50 50 50 50-22.384 50-50-22.384-50-50-50z" fill="currentcolor"/>`;

// src/view.ts
var VIEW_TYPE_DENDRON = "dendron-tree-view";
var DendronView = class extends import_obsidian7.ItemView {
  constructor(leaf, plugin2) {
    super(leaf);
    this.plugin = plugin2;
    this.icon = dendronActivityBarName;
  }
  getViewType() {
    return VIEW_TYPE_DENDRON;
  }
  getDisplayText() {
    return "Dendron Tree";
  }
  async onOpen() {
    plugin.set(this.plugin);
    this.component = new MainComponent_default({
      target: this.contentEl
    });
  }
  async onClose() {
    this.component.$destroy();
  }
};

// src/settings.ts
var import_obsidian9 = require("obsidian");

// src/modal/add-vault.ts
var import_obsidian8 = require("obsidian");
var FolderSuggester = class extends import_obsidian8.PopoverSuggest {
  constructor(app2, inputEl, onSelected) {
    super(app2);
    this.app = app2;
    this.inputEl = inputEl;
    this.onSelected = onSelected;
    this.onInputChange = () => {
      const suggestionList = this.getSuggestions(this.inputEl.value);
      if (suggestionList.length === 0) {
        this.close();
        return;
      }
      this.suggestions.setSuggestions(suggestionList);
      this.open();
      this.setAutoDestroy(this.inputEl);
      this.suggestEl.style.width = `${this.inputEl.offsetWidth}px`;
      const loc = this.inputEl.getBoundingClientRect();
      this.reposition({
        left: loc.left,
        right: loc.right,
        top: loc.top,
        bottom: loc.top + this.inputEl.offsetHeight
      });
    };
    inputEl.addEventListener("input", this.onInputChange);
    inputEl.addEventListener("focus", this.onInputChange);
    inputEl.addEventListener("blur", () => this.close());
    this.suggestEl.on("mousedown", ".suggestion-item", (e) => e.preventDefault());
    this.suggestEl.classList.add("dendron-folder-suggest");
  }
  getSuggestions(query) {
    const queryLowercase = query.toLowerCase();
    return this.app.vault.getAllLoadedFiles().filter(
      (file) => file instanceof import_obsidian8.TFolder && file.path.toLowerCase().contains(queryLowercase)
    );
  }
  renderSuggestion(value, el) {
    el.createDiv({
      text: value.path
    });
  }
  selectSuggestion(value, evt) {
    this.inputEl.value = value.path;
    this.close();
    this.onSelected(value);
  }
};
var AddVaultModal = class extends import_obsidian8.Modal {
  constructor(app2, onSubmit) {
    super(app2);
    this.onSubmit = onSubmit;
  }
  generateName({ path, name }) {
    if (path === "/")
      return "root";
    return name;
  }
  onOpen() {
    new import_obsidian8.Setting(this.contentEl).setHeading().setName("Add Vault");
    new import_obsidian8.Setting(this.contentEl).setName("Vault Path").addText((text2) => {
      new FolderSuggester(this.app, text2.inputEl, (newFolder) => {
        const currentName = this.nameText.getValue();
        if (currentName.length === 0 || this.folder && currentName === this.generateName(this.folder))
          this.nameText.setValue(this.generateName(newFolder));
        this.folder = newFolder;
      });
    });
    new import_obsidian8.Setting(this.contentEl).setName("Vault Name").addText((text2) => {
      this.nameText = text2;
    });
    new import_obsidian8.Setting(this.contentEl).addButton((btn) => {
      btn.setCta().setButtonText("Add Text").onClick(() => {
        const name = this.nameText.getValue();
        if (!this.folder || name.trim().length === 0) {
          new import_obsidian8.Notice("Please specify Vault Path and Vault Name");
          return;
        }
        if (this.onSubmit({
          path: this.folder.path,
          name
        }))
          this.close();
      });
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/settings.ts
var DEFAULT_SETTINGS = {
  vaultList: [
    {
      name: "root",
      path: "/"
    }
  ],
  autoGenerateFrontmatter: true,
  autoReveal: true,
  customResolver: false
};
var DendronTreeSettingTab = class extends import_obsidian9.PluginSettingTab {
  constructor(app2, plugin2) {
    super(app2, plugin2);
    this.plugin = plugin2;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Dendron Tree Settting" });
    new import_obsidian9.Setting(containerEl).setName("Auto Generate Front Matter").setDesc("Generate front matter for new file even if file is created outside of Dendron tree").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.autoGenerateFrontmatter).onChange(async (value) => {
        this.plugin.settings.autoGenerateFrontmatter = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian9.Setting(containerEl).setName("Auto Reveal").setDesc("Automatically reveal active file in Dendron Tree").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.autoReveal).onChange(async (value) => {
        this.plugin.settings.autoReveal = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian9.Setting(containerEl).setName("Custom Resolver").setDesc(
      "Use custom resolver to resolve ref/embed and link. (Please reopen editor after change this setting)"
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.customResolver).onChange(async (value) => {
        this.plugin.settings.customResolver = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian9.Setting(containerEl).setName("Vault List").setHeading();
    for (const vault of this.plugin.settings.vaultList) {
      new import_obsidian9.Setting(containerEl).setName(vault.name).setDesc(`Folder: ${vault.path}`).addButton((btn) => {
        btn.setButtonText("Remove").onClick(async () => {
          this.plugin.settings.vaultList.remove(vault);
          await this.plugin.saveSettings();
          this.display();
        });
      });
    }
    new import_obsidian9.Setting(containerEl).addButton((btn) => {
      btn.setButtonText("Add Vault").onClick(() => {
        new AddVaultModal(this.app, (config) => {
          const list = this.plugin.settings.vaultList;
          const nameLowecase = config.name.toLowerCase();
          if (list.find(({ name }) => name.toLowerCase() === nameLowecase)) {
            new import_obsidian9.Notice("Vault with same name already exist");
            return false;
          }
          if (list.find(({ path }) => path === config.path)) {
            new import_obsidian9.Notice("Vault with same path already exist");
            return false;
          }
          list.push(config);
          this.plugin.saveSettings().then(() => this.display());
          return true;
        }).open();
      });
    });
  }
  hide() {
    super.hide();
    this.plugin.onRootFolderChanged();
    this.plugin.configureCustomResolver();
  }
};

// src/path.ts
var lastSeparatorRegex = /[/\\](?!.*[/\\])/g;
var lastPeriodRegex = /\.(?!.*\.)/g;
function parsePath(path) {
  const pathComponent = path.split(lastSeparatorRegex);
  let dir = "";
  let name;
  if (pathComponent.length == 2)
    [dir, name] = pathComponent;
  else
    [name] = pathComponent;
  const nameComponent = name.split(lastPeriodRegex);
  const basename = nameComponent[0];
  let extension = "";
  if (nameComponent.length > 1)
    extension = nameComponent[1];
  return {
    dir,
    name,
    basename,
    extension
  };
}

// src/engine/workspace.ts
var import_obsidian10 = require("obsidian");

// node_modules/github-slugger/regex.js
var regex = /[\0-\x1F!-,\.\/:-@\[-\^`\{-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0378\u0379\u037E\u0380-\u0385\u0387\u038B\u038D\u03A2\u03F6\u0482\u0530\u0557\u0558\u055A-\u055F\u0589-\u0590\u05BE\u05C0\u05C3\u05C6\u05C8-\u05CF\u05EB-\u05EE\u05F3-\u060F\u061B-\u061F\u066A-\u066D\u06D4\u06DD\u06DE\u06E9\u06FD\u06FE\u0700-\u070F\u074B\u074C\u07B2-\u07BF\u07F6-\u07F9\u07FB\u07FC\u07FE\u07FF\u082E-\u083F\u085C-\u085F\u086B-\u089F\u08B5\u08C8-\u08D2\u08E2\u0964\u0965\u0970\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09F2-\u09FB\u09FD\u09FF\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF0-\u0AF8\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B54\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B70\u0B72-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BF0-\u0BFF\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C7F\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0CFF\u0D0D\u0D11\u0D45\u0D49\u0D4F-\u0D53\u0D58-\u0D5E\u0D64\u0D65\u0D70-\u0D79\u0D80\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF4-\u0E00\u0E3B-\u0E3F\u0E4F\u0E5A-\u0E80\u0E83\u0E85\u0E8B\u0EA4\u0EA6\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F01-\u0F17\u0F1A-\u0F1F\u0F2A-\u0F34\u0F36\u0F38\u0F3A-\u0F3D\u0F48\u0F6D-\u0F70\u0F85\u0F98\u0FBD-\u0FC5\u0FC7-\u0FFF\u104A-\u104F\u109E\u109F\u10C6\u10C8-\u10CC\u10CE\u10CF\u10FB\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u1360-\u137F\u1390-\u139F\u13F6\u13F7\u13FE-\u1400\u166D\u166E\u1680\u169B-\u169F\u16EB-\u16ED\u16F9-\u16FF\u170D\u1715-\u171F\u1735-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17D4-\u17D6\u17D8-\u17DB\u17DE\u17DF\u17EA-\u180A\u180E\u180F\u181A-\u181F\u1879-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u1945\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DA-\u19FF\u1A1C-\u1A1F\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1AA6\u1AA8-\u1AAF\u1AC1-\u1AFF\u1B4C-\u1B4F\u1B5A-\u1B6A\u1B74-\u1B7F\u1BF4-\u1BFF\u1C38-\u1C3F\u1C4A-\u1C4C\u1C7E\u1C7F\u1C89-\u1C8F\u1CBB\u1CBC\u1CC0-\u1CCF\u1CD3\u1CFB-\u1CFF\u1DFA\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FBD\u1FBF-\u1FC1\u1FC5\u1FCD-\u1FCF\u1FD4\u1FD5\u1FDC-\u1FDF\u1FED-\u1FF1\u1FF5\u1FFD-\u203E\u2041-\u2053\u2055-\u2070\u2072-\u207E\u2080-\u208F\u209D-\u20CF\u20F1-\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F-\u215F\u2189-\u24B5\u24EA-\u2BFF\u2C2F\u2C5F\u2CE5-\u2CEA\u2CF4-\u2CFF\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D70-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E00-\u2E2E\u2E30-\u3004\u3008-\u3020\u3030\u3036\u3037\u303D-\u3040\u3097\u3098\u309B\u309C\u30A0\u30FB\u3100-\u3104\u3130\u318F-\u319F\u31C0-\u31EF\u3200-\u33FF\u4DC0-\u4DFF\u9FFD-\u9FFF\uA48D-\uA4CF\uA4FE\uA4FF\uA60D-\uA60F\uA62C-\uA63F\uA673\uA67E\uA6F2-\uA716\uA720\uA721\uA789\uA78A\uA7C0\uA7C1\uA7CB-\uA7F4\uA828-\uA82B\uA82D-\uA83F\uA874-\uA87F\uA8C6-\uA8CF\uA8DA-\uA8DF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA954-\uA95F\uA97D-\uA97F\uA9C1-\uA9CE\uA9DA-\uA9DF\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A-\uAA5F\uAA77-\uAA79\uAAC3-\uAADA\uAADE\uAADF\uAAF0\uAAF1\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB5B\uAB6A-\uAB6F\uABEB\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uE000-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB29\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBB2-\uFBD2\uFD3E-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFC-\uFDFF\uFE10-\uFE1F\uFE30-\uFE32\uFE35-\uFE4C\uFE50-\uFE6F\uFE75\uFEFD-\uFF0F\uFF1A-\uFF20\uFF3B-\uFF3E\uFF40\uFF5B-\uFF65\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDD3F\uDD75-\uDDFC\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEE1-\uDEFF\uDF20-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDF9F\uDFC4-\uDFC7\uDFD0\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56-\uDC5F\uDC77-\uDC7F\uDC9F-\uDCDF\uDCF3\uDCF6-\uDCFF\uDD16-\uDD1F\uDD3A-\uDD7F\uDDB8-\uDDBD\uDDC0-\uDDFF\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE40-\uDE5F\uDE7D-\uDE7F\uDE9D-\uDEBF\uDEC8\uDEE7-\uDEFF\uDF36-\uDF3F\uDF56-\uDF5F\uDF73-\uDF7F\uDF92-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCFF\uDD28-\uDD2F\uDD3A-\uDE7F\uDEAA\uDEAD-\uDEAF\uDEB2-\uDEFF\uDF1D-\uDF26\uDF28-\uDF2F\uDF51-\uDFAF\uDFC5-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC47-\uDC65\uDC70-\uDC7E\uDCBB-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD40-\uDD43\uDD48-\uDD4F\uDD74\uDD75\uDD77-\uDD7F\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDFF\uDE12\uDE38-\uDE3D\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEA9-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC4B-\uDC4F\uDC5A-\uDC5D\uDC62-\uDC7F\uDCC6\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDC1-\uDDD7\uDDDE-\uDDFF\uDE41-\uDE43\uDE45-\uDE4F\uDE5A-\uDE7F\uDEB9-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF3A-\uDFFF]|\uD806[\uDC3B-\uDC9F\uDCEA-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD36\uDD39\uDD3A\uDD44-\uDD4F\uDD5A-\uDD9F\uDDA8\uDDA9\uDDD8\uDDD9\uDDE2\uDDE5-\uDDFF\uDE3F-\uDE46\uDE48-\uDE4F\uDE9A-\uDE9C\uDE9E-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC41-\uDC4F\uDC5A-\uDC71\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF7-\uDFAF\uDFB1-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD824-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83D\uD83F\uD87B-\uD87D\uD87F\uD885-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDECF\uDEEE\uDEEF\uDEF5-\uDEFF\uDF37-\uDF3F\uDF44-\uDF4F\uDF5A-\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE80-\uDEFF\uDF4B-\uDF4E\uDF88-\uDF8E\uDFA0-\uDFDF\uDFE2\uDFE5-\uDFEF\uDFF2-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82C[\uDD1F-\uDD4F\uDD53-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A-\uDC9C\uDC9F-\uDFFF]|\uD834[\uDC00-\uDD64\uDD6A-\uDD6C\uDD73-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDE41\uDE45-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3\uDFCC\uDFCD]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDCFF\uDD2D-\uDD2F\uDD3E\uDD3F\uDD4A-\uDD4D\uDD4F-\uDEBF\uDEFA-\uDFFF]|\uD83A[\uDCC5-\uDCCF\uDCD7-\uDCFF\uDD4C-\uDD4F\uDD5A-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDFFF]|\uD83C[\uDC00-\uDD2F\uDD4A-\uDD4F\uDD6A-\uDD6F\uDD8A-\uDFFF]|\uD83E[\uDC00-\uDFEF\uDFFA-\uDFFF]|\uD869[\uDEDE-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]/g;

// node_modules/github-slugger/index.js
var own = Object.hasOwnProperty;
var BananaSlug = class {
  /**
   * Create a new slug class.
   */
  constructor() {
    this.occurrences;
    this.reset();
  }
  /**
   * Generate a unique slug.
  *
  * Tracks previously generated slugs: repeated calls with the same value
  * will result in different slugs.
  * Use the `slug` function to get same slugs.
   *
   * @param  {string} value
   *   String of text to slugify
   * @param  {boolean} [maintainCase=false]
   *   Keep the current case, otherwise make all lowercase
   * @return {string}
   *   A unique slug string
   */
  slug(value, maintainCase) {
    const self = this;
    let result = slug(value, maintainCase === true);
    const originalSlug = result;
    while (own.call(self.occurrences, result)) {
      self.occurrences[originalSlug]++;
      result = originalSlug + "-" + self.occurrences[originalSlug];
    }
    self.occurrences[result] = 0;
    return result;
  }
  /**
   * Reset - Forget all previous slugs
   *
   * @return void
   */
  reset() {
    this.occurrences = /* @__PURE__ */ Object.create(null);
  }
};
function slug(value, maintainCase) {
  if (typeof value !== "string")
    return "";
  if (!maintainCase)
    value = value.toLowerCase();
  return value.replace(regex, "").replace(/ /g, "-");
}

// src/engine/ref.ts
function parseRefAnchor(pos) {
  if (pos === "*") {
    return {
      type: "wildcard"
    };
  } else if (pos === "^begin") {
    return {
      type: "begin"
    };
  } else if (pos === "^end") {
    return {
      type: "end"
    };
  } else if (pos.startsWith("^")) {
    return {
      type: "block",
      name: pos.slice(1)
    };
  } else {
    const [name, lineOffsetStr] = pos.split(",", 2);
    return {
      type: "header",
      name,
      lineOffset: parseInt(lineOffsetStr != null ? lineOffsetStr : "0")
    };
  }
}
function findHeadingByGithubSlug(headings, name) {
  const slugger = new BananaSlug();
  const index = headings.findIndex(({ heading }) => slugger.slug(heading) === name);
  return {
    index,
    heading: headings[index]
  };
}
function getRefContentRange(subpath, metadata) {
  var _a, _b, _c, _d;
  const range = {
    start: 0,
    startLineOffset: 0,
    end: void 0
  };
  const { start, end } = subpath;
  if (start.type === "begin") {
    range.start = 0;
    range.end = (_a = metadata.headings) == null ? void 0 : _a[0].position.start.offset;
  } else if (start.type === "end" || start.type === "wildcard") {
    return null;
  } else if (start.type === "block") {
    if (!metadata.blocks)
      return null;
    const block = metadata.blocks[start.name];
    if (!block)
      return null;
    const { position } = block;
    range.start = position.start.offset;
    range.end = position.end.offset;
  } else if (start.type === "header") {
    if (!metadata.headings)
      return null;
    const { index: startHeadingIndex, heading: startHeading } = findHeadingByGithubSlug(
      metadata.headings,
      start.name
    );
    if (!startHeading)
      return null;
    range.start = startHeading.position.start.offset;
    range.startLineOffset = start.lineOffset;
    let endHeading;
    if (end && end.type === "wildcard") {
      endHeading = (_b = metadata.headings) == null ? void 0 : _b[startHeadingIndex + 1];
    } else {
      endHeading = (_c = metadata.headings) == null ? void 0 : _c.find(
        ({ level }, index) => index > startHeadingIndex && level <= startHeading.level
      );
    }
    range.end = endHeading == null ? void 0 : endHeading.position.start.offset;
  }
  if (!end)
    return range;
  if (end.type === "begin") {
    return null;
  } else if (end.type === "end") {
    range.end = void 0;
  } else if (end.type === "header") {
    if (!metadata.headings)
      return null;
    const { heading } = findHeadingByGithubSlug(metadata.headings, end.name);
    if (!heading)
      return null;
    range.end = heading == null ? void 0 : heading.position.end.offset;
  } else if (end.type === "block") {
    const block = (_d = metadata.blocks) == null ? void 0 : _d[end.name];
    if (!block)
      return null;
    range.end = block == null ? void 0 : block.position.end.offset;
  }
  return range;
}
function anchorToLinkSubpath(anchor, headings) {
  if (anchor.type === "header") {
    let name = anchor.name;
    if (headings) {
      const { heading } = findHeadingByGithubSlug(headings, name);
      if (heading) {
        name = heading.heading;
      }
    }
    return `#${name}`;
  } else if (anchor.type === "block")
    return `#^${anchor.name}`;
  return "";
}
function parseRefSubpath(str) {
  if (str.length > 0) {
    const [startStr, endStr] = str.split(":#", 2);
    const start = parseRefAnchor(startStr);
    let end;
    if (endStr)
      end = parseRefAnchor(endStr);
    return {
      text: str,
      start,
      end
    };
  }
  return void 0;
}

// src/engine/workspace.ts
var DENDRON_URI_START = "dendron://";
var DendronWorkspace = class {
  constructor(app2) {
    this.app = app2;
    this.vaultList = [];
  }
  changeVault(vaultList) {
    this.vaultList = vaultList.map((config) => {
      var _a;
      return (_a = this.vaultList.find(
        (vault) => vault.config.name === config.name && vault.config.path === config.path
      )) != null ? _a : new DendronVault(this.app, config);
    });
    for (const vault of this.vaultList) {
      vault.init();
    }
  }
  findVaultByParent(parent) {
    return this.vaultList.find((vault) => vault.folder === parent);
  }
  findVaultByParentPath(path) {
    const file = getFolderFile(this.app.vault, path);
    return file instanceof import_obsidian10.TFolder ? this.findVaultByParent(file) : void 0;
  }
  resolveRef(sourcePath, link) {
    var _a, _b;
    if (link.startsWith(DENDRON_URI_START)) {
      const [vaultName, rest] = link.slice(DENDRON_URI_START.length).split("/", 2);
      const { path: path2, subpath: subpath2 } = rest ? (0, import_obsidian10.parseLinktext)(rest) : {
        path: void 0,
        subpath: void 0
      };
      const vault2 = this.vaultList.find(({ config }) => config.name === vaultName);
      return {
        type: "maybe-note",
        vaultName: vaultName != null ? vaultName : "",
        vault: vault2,
        note: path2 ? (_a = vault2 == null ? void 0 : vault2.tree) == null ? void 0 : _a.getFromFileName(path2) : void 0,
        path: path2 != null ? path2 : "",
        subpath: subpath2 ? parseRefSubpath(subpath2) : void 0
      };
    }
    const { dir: vaultDir } = parsePath(sourcePath);
    const vault = this.findVaultByParentPath(vaultDir);
    if (!vault)
      return null;
    const { path, subpath } = (0, import_obsidian10.parseLinktext)(link);
    const target = this.app.metadataCache.getFirstLinkpathDest(path, sourcePath);
    if (target && target.extension !== "md")
      return {
        type: "file",
        file: target
      };
    const note = vault.tree.getFromFileName(path);
    return {
      type: "maybe-note",
      vaultName: vault.config.name,
      vault,
      note,
      path,
      subpath: parseRefSubpath((_b = subpath.slice(1)) != null ? _b : "")
    };
  }
};

// src/custom-resolver/index.ts
var import_obsidian18 = require("obsidian");

// src/custom-resolver/link-hover.ts
var import_obsidian12 = require("obsidian");

// src/custom-resolver/ref-render.ts
var import_obsidian11 = require("obsidian");
var MarkdownRendererConstructor = import_obsidian11.MarkdownRenderer;
var RefMarkdownRenderer = class extends MarkdownRendererConstructor {
  constructor(parent, queed) {
    super(parent.app, parent.previewEl, queed);
    this.parent = parent;
  }
  get file() {
    return this.parent.file;
  }
  edit(markdown) {
    this.parent.editContent(markdown);
  }
};
var NoteRefRenderChild = class extends import_obsidian11.MarkdownRenderChild {
  constructor(app2, containerEl, ref) {
    super(containerEl);
    this.app = app2;
    this.containerEl = containerEl;
    this.ref = ref;
    this.found = false;
    if (!ref.note || !ref.note.file)
      throw Error("NoteRefChild only accept ref with non-blank note and file");
    this.file = ref.note.file;
    this.containerEl.classList.add("dendron-embed", "markdown-embed", "inline-embed", "is-loaded");
    this.containerEl.setText("");
    const icon = this.containerEl.createDiv("dendron-icon");
    (0, import_obsidian11.setIcon)(icon, dendronActivityBarName);
    this.previewEl = this.containerEl.createDiv("markdown-embed-content");
    const buttonComponent = new import_obsidian11.ButtonComponent(this.containerEl);
    buttonComponent.buttonEl.remove();
    buttonComponent.buttonEl = this.containerEl.createDiv(
      "markdown-embed-link"
    );
    buttonComponent.setIcon("lucide-link").setTooltip("Open link");
    buttonComponent.buttonEl.onclick = () => {
      var _a, _b;
      const openState = {};
      if (this.ref.subpath) {
        openState.eState = {
          subpath: anchorToLinkSubpath(
            this.ref.subpath.start,
            (_a = this.app.metadataCache.getFileCache(this.file)) == null ? void 0 : _a.headings
          )
        };
      }
      openFile(this.app, (_b = this.ref.note) == null ? void 0 : _b.file, { openState });
    };
    this.renderer = new RefMarkdownRenderer(this, true);
    this.addChild(this.renderer);
  }
  async getContent() {
    this.markdown = await this.app.vault.cachedRead(this.file);
    if (!this.ref.subpath) {
      this.found = true;
      return this.markdown;
    }
    const metadata = this.app.metadataCache.getFileCache(this.file);
    if (metadata) {
      this.range = getRefContentRange(this.ref.subpath, metadata);
      if (this.range) {
        let currentLineIndex = 0;
        while (currentLineIndex < this.range.startLineOffset) {
          if (this.markdown[this.range.start] === "\n")
            currentLineIndex++;
          this.range.start++;
        }
        this.found = true;
        return this.markdown.substring(this.range.start, this.range.end);
      }
    }
    this.found = false;
    return "### Unable to find section ".concat(this.ref.subpath.text, " in ").concat(this.file.basename);
  }
  editContent(target) {
    if (!this.found || !this.markdown)
      return;
    let md;
    if (!this.range) {
      md = target;
    } else {
      const before = this.markdown.substring(0, this.range.start);
      md = before + target;
      if (this.range.end) {
        const after = this.markdown.substring(this.range.end);
        md += after;
      }
    }
    this.app.vault.modify(this.file, md);
  }
  async loadFile() {
    const content = await this.getContent();
    this.renderer.renderer.set(content);
  }
  onload() {
    super.onload();
    this.registerEvent(
      this.app.metadataCache.on("changed", async (file, data) => {
        if (file === this.file) {
          this.loadFile();
        }
      })
    );
  }
};
var UnresolvedRefRenderChild = class extends import_obsidian11.MarkdownRenderChild {
  constructor(app2, containerEl, target) {
    super(containerEl);
    this.containerEl.classList.add("dendron-embed", "file-embed", "mod-empty", "is-loaded");
    this.containerEl.setText("");
    const icon = this.containerEl.createDiv("dendron-icon");
    (0, import_obsidian11.setIcon)(icon, dendronActivityBarName);
    const content = this.containerEl.createDiv();
    const { vaultName, vault, path } = target;
    if (vaultName === "") {
      content.setText("Vault name are unspecified in link.");
      return;
    } else if (!vault) {
      content.setText(`Vault ${vaultName} are not found.`);
      return;
    } else if (path === "") {
      content.setText("Note path are unspecified in link.");
      return;
    }
    content.setText(`"${target.path}" is not created yet. Click to create.`);
    this.containerEl.onclick = () => {
      vault.createNote(path).then((file) => openFile(app2, file));
    };
  }
};
function createRefRenderer(target, app2, container) {
  if (!target.note || !target.note.file) {
    return new UnresolvedRefRenderChild(app2, container, target);
  } else {
    return new NoteRefRenderChild(app2, container, target);
  }
}

// src/custom-resolver/link-hover.ts
function createLinkHoverHandler(app2, workspace, originalBoundedFunction) {
  return (parent, targetEl, link, sourcePath, state) => {
    const ref = workspace.resolveRef(sourcePath, link);
    if (!ref || ref.type !== "maybe-note")
      return originalBoundedFunction(parent, targetEl, link, sourcePath, state);
    if (!(parent.hoverPopover && parent.hoverPopover.state !== import_obsidian12.PopoverState.Hidden && parent.hoverPopover.targetEl === targetEl)) {
      const popOver = new import_obsidian12.HoverPopover(parent, targetEl);
      setTimeout(async () => {
        if (popOver.state === import_obsidian12.PopoverState.Hidden)
          return;
        const container = popOver.hoverEl.createDiv();
        const component = createRefRenderer(ref, app2, container);
        popOver.addChild(component);
        if (component instanceof NoteRefRenderChild)
          await component.loadFile();
        if (popOver.state === import_obsidian12.PopoverState.Shown)
          popOver.position();
      }, 100);
    }
  };
}

// src/custom-resolver/index.ts
var import_view3 = require("@codemirror/view");

// src/custom-resolver/ref-live.ts
var import_view = require("@codemirror/view");
var import_obsidian13 = require("obsidian");
var RefLivePlugin = class {
  constructor(app2, workspace) {
    this.app = app2;
    this.workspace = workspace;
  }
  update(update2) {
    if (!update2.state.field(import_obsidian13.editorLivePreviewField)) {
      return;
    }
    update2.view.state.facet(import_view.EditorView.decorations).forEach((d) => {
      if (typeof d !== "function") {
        const iter = d.iter();
        while (iter.value) {
          const widget = iter.value.spec.widget;
          if (widget && widget.href && widget.sourcePath && widget.title) {
            const internalWidget = widget;
            this.hack(internalWidget);
          }
          iter.next();
        }
      }
    });
  }
  hack(widget) {
    if (widget.hacked) {
      return;
    }
    widget.hacked = true;
    const target = this.workspace.resolveRef(widget.sourcePath, widget.href);
    if (!target || target.type !== "maybe-note")
      return;
    const loadComponent = (widget2) => {
      const renderer = createRefRenderer(target, this.app, widget2.containerEl);
      if (renderer instanceof NoteRefRenderChild)
        renderer.loadFile();
      widget2.addChild(renderer);
    };
    widget.initDOM = function() {
      this.containerEl = createDiv("internal-embed");
      loadComponent(this);
      return this.containerEl;
    };
    widget.applyTitle = function(container, title) {
      this.title = title;
    };
    if (widget.containerEl) {
      console.log("Workaround");
      widget.children[0].unload();
      widget.children.pop();
      loadComponent(widget);
    }
  }
};

// src/custom-resolver/ref-markdown-processor.ts
function createRefMarkdownProcessor(app2, workspace) {
  return (element2, context) => {
    const embeddedItems = element2.querySelectorAll(".internal-embed");
    const promises = [];
    embeddedItems.forEach((el) => {
      const link = el.getAttribute("src");
      if (!link)
        return;
      const target = workspace.resolveRef(context.sourcePath, link);
      if (!target || target.type !== "maybe-note")
        return;
      const renderer = createRefRenderer(target, app2, el);
      if (renderer instanceof NoteRefRenderChild)
        promises.push(renderer.loadFile());
      context.addChild(renderer);
    });
    return Promise.all(promises);
  };
}

// src/custom-resolver/link-open.ts
var import_obsidian14 = require("obsidian");
function createLinkOpenHandler(workspace, originalBoundedFunction) {
  return async (linktext, sourcePath, newLeaf, openViewState) => {
    var _a, _b;
    const target = workspace.resolveRef(sourcePath, linktext);
    if (!target || target.type !== "maybe-note")
      return originalBoundedFunction(linktext, sourcePath, newLeaf, openViewState);
    let file = (_a = target.note) == null ? void 0 : _a.file;
    if (!file) {
      if (target.vaultName === "") {
        new import_obsidian14.Notice("Vault name is unspecified in link.");
        return;
      } else if (!target.vault) {
        new import_obsidian14.Notice(`Vault ${target.vaultName} is not found.`);
        return;
      } else if (target.path === "") {
        new import_obsidian14.Notice("Note path is unspecified in link.");
        return;
      }
      file = await target.vault.createNote(target.path);
    }
    let newLink = file.path;
    if (target.subpath)
      newLink += anchorToLinkSubpath(
        target.subpath.start,
        (_b = app.metadataCache.getFileCache(file)) == null ? void 0 : _b.headings
      );
    return originalBoundedFunction(newLink, "", newLeaf, openViewState);
  };
}

// src/custom-resolver/link-live.ts
var import_language = require("@codemirror/language");
var import_state = require("@codemirror/state");
var import_view2 = require("@codemirror/view");
var import_obsidian15 = require("obsidian");
var import_obsidian16 = require("obsidian");

// src/custom-resolver/link-render.ts
function renderLinkTitle(app2, workspace, href, title, sourcePath) {
  var _a, _b, _c;
  if (title) {
    return title;
  }
  const ref = workspace.resolveRef(sourcePath, href);
  if (!ref || ref.type !== "maybe-note" || !((_a = ref.note) == null ? void 0 : _a.file)) {
    return href;
  }
  const fileTitle = (_c = (_b = app2.metadataCache.getFileCache(ref.note.file)) == null ? void 0 : _b.frontmatter) == null ? void 0 : _c["title"];
  return fileTitle != null ? fileTitle : href;
}

// src/custom-resolver/link-live.ts
var LinkWidget = class extends import_view2.WidgetType {
  constructor(app2, workspace, sourcePath, href, title) {
    super();
    this.app = app2;
    this.workspace = workspace;
    this.sourcePath = sourcePath;
    this.href = href;
    this.title = title;
  }
  initDOM() {
    this.containerEl = createSpan(
      {
        cls: "cm-hmd-internal-link"
      },
      (el) => {
        el.createSpan({
          cls: "cm-underline"
        });
      }
    );
    this.updateTitle();
    this.containerEl.addEventListener("click", () => {
      this.app.workspace.openLinkText(this.href, this.sourcePath);
    });
  }
  updateTitle() {
    this.containerEl.children[0].setText(
      renderLinkTitle(this.app, this.workspace, this.href, this.title, this.sourcePath)
    );
  }
  toDOM(view) {
    if (!this.containerEl)
      this.initDOM();
    return this.containerEl;
  }
};
var LinkLivePlugin = class {
  constructor(app2, workspace, editorView) {
    this.app = app2;
    this.workspace = workspace;
    this.editorView = editorView;
    this.decorations = import_view2.Decoration.none;
    this.widgets = [];
    this.decorations = this.buildDecorations(editorView);
  }
  update(update2) {
    this.decorations = this.buildDecorations(update2.view);
  }
  getLinks(view) {
    const links = [];
    for (const { from, to } of view.visibleRanges) {
      let linkStart = -1;
      let linkTitle = void 0;
      let linkHref = "";
      (0, import_language.syntaxTree)(view.state).iterate({
        from,
        to,
        enter(node) {
          const tokenClass = node.type.prop(import_language.tokenClassNodeProp);
          if (!tokenClass)
            return;
          const tokenClassList = tokenClass.split(" ");
          if (tokenClassList.contains("formatting-link-start") && !tokenClassList.contains("formatting-embed")) {
            linkStart = node.from;
          } else if (linkStart >= 0) {
            if (tokenClassList.contains("hmd-internal-link")) {
              const text2 = view.state.doc.sliceString(node.from, node.to);
              if (tokenClassList.contains("link-has-alias")) {
                linkTitle = text2;
              } else {
                linkHref = text2;
              }
            } else if (tokenClassList.contains("formatting-link-end")) {
              links.push({
                start: linkStart,
                end: node.to,
                href: linkHref,
                title: linkTitle,
                hasAlias: !!linkTitle,
                showSource: true
              });
              linkStart = -1;
              linkTitle = void 0;
              linkHref = "";
            }
          }
        }
      });
    }
    return links;
  }
  configureLinkVisibility(links, view) {
    const prevDecorations = view.state.facet(import_view2.EditorView.decorations);
    for (const decorFn of prevDecorations) {
      if (typeof decorFn !== "function")
        continue;
      const decor = decorFn(view);
      const iter = decor.iter();
      let found = false;
      while (iter.value) {
        if (iter.value.isReplace) {
          const link = links.find(({ start }) => start === iter.from);
          if (link) {
            found = true;
            link.showSource = false;
            if (link.hasAlias) {
              iter.next();
              iter.next();
              iter.next();
            } else {
              iter.next();
            }
            iter.next();
          }
        }
        iter.next();
      }
      if (found)
        break;
    }
  }
  getWidget(link, sourcePath) {
    const lastWidgetIndex = this.widgets.findIndex(
      (widget) => widget.href === link.href && widget.sourcePath === sourcePath
    );
    if (lastWidgetIndex >= 0) {
      const widget = this.widgets[lastWidgetIndex];
      widget.title = link.title;
      widget.updateTitle();
      this.widgets.splice(lastWidgetIndex, 1);
      return widget;
    }
    return new LinkWidget(this.app, this.workspace, sourcePath, link.href, link.title);
  }
  buildDecorations(view) {
    var _a, _b;
    if (!view.state.field(import_obsidian16.editorLivePreviewField)) {
      return import_view2.Decoration.none;
    }
    const links = this.getLinks(view);
    if (links.length === 0)
      return import_view2.Decoration.none;
    this.configureLinkVisibility(links, view);
    const builder = new import_state.RangeSetBuilder();
    const currentWidgets = [];
    const sourcePath = (_b = (_a = view.state.field(import_obsidian15.editorInfoField).file) == null ? void 0 : _a.path) != null ? _b : "";
    for (const link of links) {
      if (link.showSource)
        continue;
      const widget = this.getWidget(link, sourcePath);
      currentWidgets.push(widget);
      builder.add(
        link.start,
        link.end,
        import_view2.Decoration.widget({
          widget
        })
      );
    }
    this.widgets = currentWidgets;
    return builder.finish();
  }
};

// src/custom-resolver/link-markdown-processor.ts
function createLinkMarkdownProcessor(app2, workspace) {
  return (el, ctx) => {
    console.log();
    const linksEl = el.querySelectorAll(".internal-link");
    if (linksEl.length == 0)
      return;
    const section = ctx.getSectionInfo(el);
    const cache = app2.metadataCache.getCache(ctx.sourcePath);
    if (!section || !(cache == null ? void 0 : cache.links))
      return;
    const links = cache.links.filter(
      (link) => link.position.start.line >= section.lineStart && link.position.end.line <= section.lineEnd
    );
    if (links.length !== linksEl.length) {
      console.warn("Cannot post process link");
      return;
    }
    linksEl.forEach((el2, index) => {
      const link = links[index];
      if (!link.original.startsWith("[[") || !link.original.endsWith("]]"))
        return;
      let title, href;
      const split = link.original.substring(2, link.original.length - 2).split("|", 2);
      if (split.length == 1)
        href = split[0];
      else {
        title = split[0];
        href = split[1];
      }
      const titleText = renderLinkTitle(app2, workspace, href, title, ctx.sourcePath);
      el2.setText(titleText);
      el2.setAttribute("href", href);
      el2.setAttribute("data-href", href);
      el2.setAttribute("aria-label", href);
      el2.setAttribute("data-tooltip-position", "top");
    });
  };
}

// src/custom-resolver/link-ref-clickbale.ts
var import_obsidian17 = require("obsidian");
var LinkRefClickbale = class {
  constructor(view) {
    this.view = view;
    const editor = view.state.field(import_obsidian17.editorInfoField).editor;
    if (editor && editor.getClickableTokenAt) {
      this.getClickableTokenAtOrig = editor.getClickableTokenAt;
      editor.getClickableTokenAt = LinkRefClickbale.createClickableTokenAtWrapper(
        this.getClickableTokenAtOrig
      );
    }
  }
  static createClickableTokenAtWrapper(original) {
    return function(...args) {
      const result = original.call(this, ...args);
      if (result && result.type === "internal-link") {
        const raw = this.getRange(result.start, result.end);
        const split = raw.split("|", 2);
        if (split.length === 2) {
          result.text = split[1];
        }
      }
      return result;
    };
  }
  destroy() {
    if (this.getClickableTokenAtOrig) {
      const editor = this.view.state.field(import_obsidian17.editorInfoField).editor;
      if (editor) {
        editor.getClickableTokenAt = this.getClickableTokenAtOrig;
      }
    }
  }
};

// src/custom-resolver/index.ts
var CustomResolver = class extends import_obsidian18.Component {
  constructor(plugin2, workspace) {
    super();
    this.plugin = plugin2;
    this.workspace = workspace;
    this.refPostProcessor = createRefMarkdownProcessor(this.plugin.app, this.workspace);
    this.linkPostProcessor = createLinkMarkdownProcessor(this.plugin.app, this.workspace);
    this.refEditorExtenstion = import_view3.ViewPlugin.define((v) => {
      return new RefLivePlugin(this.plugin.app, this.workspace);
    });
    this.linkEditorExtenstion = import_view3.ViewPlugin.define(
      (view) => {
        return new LinkLivePlugin(this.plugin.app, this.workspace, view);
      },
      {
        decorations: (value) => value.decorations
      }
    );
    this.linkRefClickbaleExtension = import_view3.ViewPlugin.define((v) => {
      return new LinkRefClickbale(v);
    });
  }
  onload() {
    this.plugin.app.workspace.onLayoutReady(() => {
      this.plugin.app.workspace.registerEditorExtension(this.refEditorExtenstion);
      this.plugin.app.workspace.registerEditorExtension(this.linkEditorExtenstion);
      this.plugin.app.workspace.registerEditorExtension(this.linkRefClickbaleExtension);
      this.pagePreviewPlugin = this.plugin.app.internalPlugins.getEnabledPluginById("page-preview");
      if (!this.pagePreviewPlugin)
        return;
      this.originalLinkHover = this.pagePreviewPlugin.onLinkHover;
      this.pagePreviewPlugin.onLinkHover = createLinkHoverHandler(
        this.plugin.app,
        this.workspace,
        this.originalLinkHover.bind(this.pagePreviewPlugin)
      );
    });
    import_obsidian18.MarkdownPreviewRenderer.registerPostProcessor(this.refPostProcessor);
    import_obsidian18.MarkdownPreviewRenderer.registerPostProcessor(this.linkPostProcessor);
    this.originalOpenLinkText = this.plugin.app.workspace.openLinkText;
    this.plugin.app.workspace.openLinkText = createLinkOpenHandler(
      this.workspace,
      this.originalOpenLinkText.bind(this.plugin.app.workspace)
    );
  }
  onunload() {
    this.plugin.app.workspace.openLinkText = this.originalOpenLinkText;
    import_obsidian18.MarkdownPreviewRenderer.unregisterPostProcessor(this.linkPostProcessor);
    import_obsidian18.MarkdownPreviewRenderer.unregisterPostProcessor(this.refPostProcessor);
    this.plugin.app.workspace.unregisterEditorExtension(this.linkRefClickbaleExtension);
    this.plugin.app.workspace.unregisterEditorExtension(this.linkEditorExtenstion);
    this.plugin.app.workspace.unregisterEditorExtension(this.refEditorExtenstion);
    if (!this.pagePreviewPlugin)
      return;
    this.pagePreviewPlugin.onLinkHover = this.originalLinkHover;
  }
};

// src/main.ts
var DendronTreePlugin = class extends import_obsidian19.Plugin {
  constructor() {
    super(...arguments);
    this.workspace = new DendronWorkspace(this.app);
    this.onCreateFile = async (file) => {
      const vault = this.workspace.findVaultByParent(file.parent);
      if (vault && vault.onFileCreated(file)) {
        if (this.settings.autoGenerateFrontmatter && file instanceof import_obsidian19.TFile && file.stat.size === 0)
          await vault.generateFronmatter(file);
        this.updateNoteStore();
      }
    };
    this.onDeleteFile = (file) => {
      const parsed = parsePath(file.path);
      const vault = this.workspace.findVaultByParentPath(parsed.dir);
      if (vault && vault.onFileDeleted(parsed)) {
        this.updateNoteStore();
      }
    };
    this.onRenameFile = (file, oldPath) => {
      const oldParsed = parsePath(oldPath);
      const oldVault = this.workspace.findVaultByParentPath(oldParsed.dir);
      let update2 = false;
      if (oldVault) {
        update2 = oldVault.onFileDeleted(oldParsed);
      }
      const newVault = this.workspace.findVaultByParent(file.parent);
      if (newVault) {
        update2 = newVault.onFileCreated(file) || update2;
      }
      if (update2)
        this.updateNoteStore();
    };
    this.onFileMenu = (menu, file) => {
      if (!(file instanceof import_obsidian19.TFile))
        return;
      menu.addItem((item) => {
        item.setIcon(dendronActivityBarName).setTitle("Reveal in Dendron Tree").onClick(() => this.revealFile(file));
      });
    };
    this.onResolveMetadata = (file) => {
      const vault = this.workspace.findVaultByParent(file.parent);
      if (vault && vault.onMetadataChanged(file)) {
        this.updateNoteStore();
      }
    };
  }
  async onload() {
    await this.loadSettings();
    await this.migrateSettings();
    (0, import_obsidian19.addIcon)(dendronActivityBarName, dendronActivityBarIcon);
    this.addCommand({
      id: "dendron-lookup",
      name: "Lookup Note",
      callback: () => {
        new LookupModal(this.app, this.workspace).open();
      }
    });
    this.addSettingTab(new DendronTreeSettingTab(this.app, this));
    this.registerView(VIEW_TYPE_DENDRON, (leaf) => new DendronView(leaf, this));
    this.addRibbonIcon(dendronActivityBarName, "Open Dendron Tree", () => {
      this.activateView();
    });
    this.app.workspace.onLayoutReady(() => {
      this.onRootFolderChanged();
      this.registerEvent(this.app.vault.on("create", this.onCreateFile));
      this.registerEvent(this.app.vault.on("delete", this.onDeleteFile));
      this.registerEvent(this.app.vault.on("rename", this.onRenameFile));
      this.registerEvent(this.app.metadataCache.on("resolve", this.onResolveMetadata));
      this.registerEvent(this.app.workspace.on("file-open", this.onOpenFile, this));
      this.registerEvent(this.app.workspace.on("file-menu", this.onFileMenu));
    });
    this.configureCustomResolver();
  }
  async migrateSettings() {
    function pathToVaultConfig(path) {
      const { name } = parsePath(path);
      if (name.length === 0)
        return {
          name: "root",
          path: "/"
        };
      let processed = path;
      if (processed.endsWith("/"))
        processed = processed.slice(0, -1);
      if (processed.startsWith("/") && processed.length > 1)
        processed = processed.slice(1);
      return {
        name,
        path: processed
      };
    }
    if (this.settings.vaultPath) {
      this.settings.vaultList = [pathToVaultConfig(this.settings.vaultPath)];
      this.settings.vaultPath = void 0;
      await this.saveSettings();
    }
    if (this.settings.vaultList.length > 0 && typeof this.settings.vaultList[0] === "string") {
      this.settings.vaultList = this.settings.vaultList.map(
        (path) => pathToVaultConfig(path)
      );
      await this.saveSettings();
    }
  }
  onunload() {
  }
  onRootFolderChanged() {
    this.workspace.changeVault(this.settings.vaultList);
    this.updateNoteStore();
  }
  configureCustomResolver() {
    if (this.settings.customResolver && !this.customResolver) {
      this.customResolver = new CustomResolver(this, this.workspace);
      this.addChild(this.customResolver);
    } else if (!this.settings.customResolver && this.customResolver) {
      this.removeChild(this.customResolver);
      this.customResolver = void 0;
    }
  }
  updateNoteStore() {
    dendronVaultList.set(this.workspace.vaultList);
  }
  onOpenFile(file) {
    activeFile.set(file);
    if (file && this.settings.autoReveal)
      this.revealFile(file);
  }
  revealFile(file) {
    const vault = this.workspace.findVaultByParent(file.parent);
    if (!vault)
      return;
    const note = vault.tree.getFromFileName(file.basename);
    if (!note)
      return;
    for (const leaf of this.app.workspace.getLeavesOfType(VIEW_TYPE_DENDRON)) {
      if (!(leaf.view instanceof DendronView))
        continue;
      leaf.view.component.focusTo(vault, note);
    }
  }
  async activateView() {
    const leafs = this.app.workspace.getLeavesOfType(VIEW_TYPE_DENDRON);
    if (leafs.length == 0) {
      const leaf = this.app.workspace.getLeftLeaf(false);
      await leaf.setViewState({
        type: VIEW_TYPE_DENDRON,
        active: true
      });
      this.app.workspace.revealLeaf(leaf);
    } else {
      leafs.forEach((leaf) => this.app.workspace.revealLeaf(leaf));
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
