{"path":"iCloudDrive/bks/Algebra/Algebra/Sequences, Sums, Products/Finite Calculus - David Gleich - X.pdf","text":"Finite Calculus: A Tutorial for Solving Nasty Sums David Gleich January 17, 2005 Abstract In this tutorial, I will ﬁrst explain the need for ﬁnite calculus using an example sum I think is diﬃcult to solve. Next, I will show where this sum actually occurs and why it is important. Following that, I will present all the mathematics behind ﬁnite calculus and a series of theorems to make it helpful before concluding with a set of examples to show that it really is useful. Contents 1 How to Evaluate ∑n x=1 x2? 2 2 The Computational Cost of Gaussian Elimination 3 3 The Finite Calculus 4 3.1 Discrete Derivative . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 3.2 The Indeﬁnite Sum and the Discrete Anti-Derivative . . . . . . . . . . . 7 3.3 Helpful Finite Calculus Theorems . . . . . . . . . . . . . . . . . . . . . . 8 4 Making Finite Calculus Useful: Stirling and His Numbers 10 4.1 Stirling Numbers (of the Second Kind) . . . . . . . . . . . . . . . . . . . 12 4.2 Proving the Theorem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 4.3 Computing Stirling Numbers . . . . . . . . . . . . . . . . . . . . . . . . 15 5 Examples Galore... 16 5.1 ∑n x=1 x2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 5.2 A Double Sum . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 5.3 Average Codeword Length . . . . . . . . . . . . . . . . . . . . . . . . . . 17 6 Conclusion 18 1 1 How to Evaluate ∑n x=1 x2? One of the problems we’ll1 learn to address during this tutorial is how to mechanically (i.e. without much thinking) compute the closed form value of the sum n∑ x=1 x 2. (1) While many students may already know the closed form answer to this particular question, our quest for the answer will lead us to techniques to easily evaluate nasty sums such as n∑ x=1 m∑ y=1(x + y) 2 (2) and n∑ x=0 x2 x. (3) Since we’ll be using ∑n x=1 x2 as a motivating example, we’ll ﬁrst familiarize our- selves with the ﬁrst few values of this function. n 0 1 2 1 2 3 4 We want the area underneath the stepped line, not the area underneath the smooth curve. It is ironic that we can easily determine the area underneath the smooth curve using the inﬁnite calculus but have trouble determining the much more simple area under the stepped line. In short, that is the goal of this tutorial – to derive a ﬁnite (or discrete) analogue of inﬁnite calculus so the ﬁnite sum 2∑ x=1 x 2 is no more diﬃcult to solve than the “inﬁnite” sum ∫ 2 1 x2 dx. Besides ﬁnite calculus, another way to compute the value of ∑n x=1 x2 is to look it up in a book, or try and guess the answer. Searching through CRC Standard Mathematical Tables and Formuale [6], on p. 21 we ﬁnd n∑ x=1 x2 = n(n + 1)(2n + 1) By closed form, we mean involving some set of fundamental operations, such as addi- tion, multiplication, exponentiation, and even factorials. Whereas in inﬁnite calculus, we needed to compute the area under a function exactly, in ﬁnite calculus we want to compute the area under a sequence exactly. We call this ﬁnite calculus because each sum is composed of a ﬁnite (rather than inﬁnite) set of terms. One way to think of ﬁnite calculus is calculus on the integers rather than the real numbers. In calculus, we used the notion of derivative and anti-derivative along with the fundamental theorem of calculus to write the closed form solution of ∫ b a f (x) dx = F (b) − F (a), where d Unfortunately, this simple form does not work for x2. ∆x2 = (x + 1) 2 − x2 = 2x + 1 ̸= 2x. Now, our derivate for x2 was only oﬀ by 1. Is there any easy way we can ﬁx this problem? If we rewrite our previous failed derivative as ∆ (x 2) − 1 = 2x, we ﬁnd ourselves must closer. Now, we can pull the −1 into the derivative by observing that ∆(x2 − x) = 2x + 1 − 1 = 2x. We can factor x2 − x as x(x − 1). Thus, we have ∆(x(x − 1)) = 2x. I’ll leave it to the reader to verify that ∆(x(x − 1)(x − 2)) = 3x(x − 1). It appears we’ve found a new type of power for discrete derivatives! These powers are known as “falling powers.” Deﬁnition (Falling Power). The expression x to the m falling is denoted xm Proof. The proof is straight from the deﬁnition. ∆ (f (x) + g(x)) = f (x + 1) + g(x + 1) − f (x) − g(x). Rearranging terms, we get ∆ (f (x) + g(x)) = ∆f (x) + ∆g(x). With the discrete deﬁnite integral, the theorem we’d like to show (by analogy with inﬁnite calculus) is b∑ a g(x) δx ? = b∑ x=a g(x). Unfortunately, this isn’t true as a quick check shows. 5∑ 1 x δx = x2 Theorem 3.5. The function 2x satisﬁes ∆ (2 x) = 2 x and ∑ 2 x δx = 2 x + C. Let’s compute the general derivative of an exponent. ∆ (c x) = c x+1 − c x = (c − 1)c x. Because c is a constant in this expression, we can then immediately compute the anti- derivative as well. ∑ c x δx = cx To move from x3f (x) ∆f (x) ∑ f (x) δxTheorem 4.1. We can convert between powers and falling powers using the following formula x m = m∑ k=0 { m k } x k we get the following sets. {♣, ♦}, {♥} {♣, ♥}, {♦} {♦, ♥}, {♣} So {3 2 } = 3, since there are three ways to put 3 items into 2 non-empty sets. We still don’t really know much about Stirling numbers though. Let’s prove a theorem to help us general new Stirling numbers from previous ones. Theorem 4.2. { n k } = { n − 1 k − 1 } + k{ n − 1 k }. Proof. We’ll give a combinatorial proof of this identity. In a combinatorial proof, we choose a particular quantity and give two ways of counting this quantity. Since these two diﬀerent ways count the same thing, they must be equal. In this proof, we’ll count the number of ways to partition n distinct objects into k non-empty sets. The obvious way to count this quantity is by using our previous deﬁnition of Stirling numbers. By this deﬁnition, {n k} counts the number of ways to partition n distinct objects into k non-empty sets. Now, let’s count this quantity using a diﬀerent way. I like to call this the “weirdo” method. Let’s pick out one of our distinct objects and call it x, the “weirdo.” We can now count the number of ways to partition n distinct objects into k non-empty sets by keeping track of where the “weirdo” goes. The ﬁrst possibility is that the “weirdo” is in a set all by itself. In this case, there are {n−1 k−1} ways for the other n − 1 objects to be partitioned into k − 1 non-empy sets. If the “weirdo” is not in a set by itself, then it must be inside another non-empty set. So the others must have been divided into k non-empty sets. There are {n−1 k } ways of partitioning them. For each of these partitions, we can insert the “weirdo” into any of the k sets and get another partition. So there are k{n−1 k } total ways putting the “weirdo” into these existing sets. Since we have completely dealt with the “weirdo”, there are {n−1 k−1} + k{n−1 k } ways to partition n distinct objects into k non-empty sets. Thus, { n k } = { n − 1 k − 1 } + k{ n − 1 k }. 1 0 1 0 1 1 0 1 3 1 0 1 7 6 1 0 1 15 25 10 1 0 1 31 90 65 15 1 Figure 1: A table of Stirling Numbers of the second kind { n k} which induces the Stirling triangle. The value of { n k} is the k + 1th number on the n + 1th row, e.g. { 4 2 } = 7. To build the triangle, use Theorem 4.2. This theorem says that the value in a particular position is k times the number up and to the right, plus the number up and to the left, e.g. 7 = 2 ∗ 3 + 1. 4.2 Proving the Theorem In order to prove Theorem 4.1, we’ll ﬁrst prove a helpful lemma, then do a lot of algebra. Lemma. A helpful lemma x · xk (See the end for a discussion of the steps in the following work.) x r+1 = xx r = r∑ k=0 {r k } x · xk If we apply an ordering to the sets comprising these partitions, i.e. π1, π2, . . . , πk, then we can construct a surjective map from X to Y using the map f (x) = yj | x ∈ πj, that is, the set πj is the inverse image of yj. Since there are k! orderings of the numbers between 1 and k, we get that there are k! {n k} surjections. We can also count this using an inclusion-exclusion argument. If we take the total number of mappings from X to Y , we want to subtract all the mappings that do not map to at least one element in y. We can do this by look at all maps that exclude a particular element yi. To do this, we take the total number of maps between X and Y and subtract the number of maps that exclude an element yi. However, now we’ve subtracted some maps twice (maps that exclude yi and yj), and we then need to add them back. So we then add the number of maps that exclude two elements, then subtract the maps that exclude at least three (for a similar reason), etc. This strange sum actually counts all of our elements. For more information about a powerful generalization of this proof technique, see [5]. There are (k i) ways to pick the i elements from k to exclude and there are (k − i)n maps that exclude one set of i elements from Y . Thus, we get the number of surjective maps from X to Y is (k 0 )kn | n∑ x=1 n∑ y=1(x + y) 2 = n+1∑ 1 n+1∑ 1 (x + y) 2 δy δx = n+1∑ 1 n+1∑ 1 (x + y) 2 While you’ve already solved the denominator, the numerator is a little more chal- lenging. However, since you have (obviously) read all portions of this tutorial you know about ﬁnite calculus and, unabashed, proceed ahead. 10∑ x=1 x2 x = 11∑ 1 x2 x δx. Now, you remember this little theorem about “discrete integration by parts” (The- orem 3.6). ∑ x2 x δx = x2 x − ∑ 2 x+1 δx = x2 x − 2 x+1 = 2 x(x − 2). Then, 10∑ x=1 x2 x = 2 x(x − 2)|11 1 = 9 · 2 11 + 2. The average codeword length is then 9 · 211 + 2","libVersion":"0.3.1","langs":""}