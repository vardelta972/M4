{"path":"iCloudDrive/bks/Combinatorics/Combinatorics/counting.pdf","text":"Basic Counting Principles Michael Albert 1 Introduction One of the basic elements of the area of maths known as combinatorics is counting. Rarely does one see an Olympiad level problem which is only about counting1; but frequently, understanding the basic counting principles and some particular standard examples of counting problems might be an ingredient in such a problem. In these notes we’ll present those principles and examples, and also look at some slightly more advanced techniques. To begin with, what do we mean exactly by “counting”? In mathematics it generally means that we are given a set A, described abstractly in some way, and asked how many elements belong to A. But I ﬁnd it useful to keep a mental connection with the more physical aspects of counting. I tend to think of the elements of A as pebbles, originally in a heap, that need to be counted. By ﬁnding some clever way to arrange or sort the pebbles it’s often easier to count them than it would be if they were just in a single heap. One piece of notation will be helpful. If A is a ﬁnite set, we use |A| to denote the number of elements belonging to A (the analogy with absolute value is that the absolute value of a number is a measure of its size, as is the number of elements that belong to a set.) 2 Basic Principles The Addition Principle Let A and B be disjoint ﬁnite sets2 Then: |A ∪ B| = |A| + |B| . Here’s a “proof” of this principle 3. We want to count how many pebbles there are in two bags. We could dump them out on the table and count the resulting heap. But, if someone has helpfully labelled the bags with the number of pebbles in each, we could just add those two numbers together instead. Of course the addition principle has the obvious extension to more than two sets. If A1, A2, . . . Ak are pairwise disjoint (meaning that the intersection of any two is empty) then |A1 ∪ A2 ∪ · · · ∪ Ak| = |A1| + |A2| + · · · + |Ak| . 1But see Problem 5 of the IMO in 2008! 2Two sets are disjoint if they have no common elements, that is, if their intersection is empty. 3Formal proofs in this area would require us to show that we could ﬁnd a correspondence between certain sets – to say that a set X contains n elements is to claim the existence of a one to one correspondence between X and {1, 2, . . . , n}. Doing this is dull and unenlightening, so we don’t usually bother. 1 We might also right this more compactly as: \f \f \f \f \f k⋃ i=1 Ai \f \f \f \f \f = k∑ i=1 |Ai| ; which is really more of an excuse to introduce some notation than anything else. We’ll talk about how to handle the situation where the sets we have are not disjoint in some detail later, but for now just note that in general: |A ∪ B| = |A| + |B| − |A ∩ B| . There’s not much that can be done with the addition principle by itself, so just a couple of basic examples: Example 1 How many positive integers less than or equal to 100 are multiples of 2 or multiples of 3? Solution: Let A be the set of positive integers less than 100 that are multiples of 2, and B the set of positive integers less than 100 that are multiples of 3. We want to know |A ∪ B|. Certainly |A| = 50 and |B| = 33, but the two sets are not disjoint. To use the addition principle as stated, we should take B′ to be the set of odd multiples of 3 instead. There are 17 of those, and hence |A ∪ B| = |A ∪ B′| = 50 + 17 = 67. Alternatively, we could use the second form, noting that A ∩ B is the set of multiples of 6, of which there are 16 and so |A ∪ B| = 50 + 33 − 16 = 67. Example 2 How many two digit numbers are there, whose digits are in decreasing order? Solution: This time the bags containing our pebbles are not so obvious. But, we could take Ai for 1 ≤ i ≤ 9 to be the set of two digit numbers whose ﬁrst digit is i and whose digits are in decreasing order. Clearly |Ai| = i and the Ai are pairwise disjoint. Therefore, |A1 ∪ A2 ∪ · · · ∪ A9| = |A1| + |A2| + · · · + |A9| = 1 + 2 + · · · + 9 = 45. An alternative, possibly more “clever” approach would be to note that, written with leading 0’s of the 100 numbers between 0 and 99, there are 10 with equal digits, and the number with digits in increasing order is the same as the number with digits in decreasing order; i.e. half of the remaining 90, so 45. Time for the second of our counting principles: The Multiplication Principle If a set B can be partitioned into k sets, and each of these sets contains n elements, then |B| = nk. This time we know that there are k bags on the table, and each is marked as containing the same number, n of pebbles, so, rather than adding up k copies of n we can just multiply instead. Of course we could have n1 crates, each containing n2 boxes, each containing n3 bags, each containing n4 pebbles and we could conclude that the total number of pebbles was n1n2n3n4, so there is an extended version of the multiplication principle available as well. The most common situation in which the multiplication principle arises is when the objects that we are counting can be thought of as being constructed by some sequential process, and where the number of ways to carry out each step of the process is always the same. Then, the total number of objects is just the product of the number of choices at each stage. 2 Example 3 How many three digit numbers are there, whose digits are all distinct? Solution: Construct such numbers a digit at a time. There are 9 choices for the ﬁrst digit (since 0 isn’t allowed). Having chosen the ﬁrst digit, there are still 9 choices for the second digit (since we’ve lost the use of the ﬁrst digit, but now could use 0). Then, 8 choices remain for the third digit. So, the total number of such numbers is 9 × 9 × 8 = 648. Example 4 Show that the number of subsets of an n element set (including the empty set and the set itself ) is 2 n. Solution: In this case, let’s use the answer to give us a clue as to how to do the question. To get a number like 2 n using the multiplication principle, we need to make a sequence of n choices, each time having two alternatives. Aha! Let the elements of the set be x1 through xn. For the kth choice, simply decide whether or not to include xk in the subset. Alternatively we could proceed by induction. The claim is easy to check for n ≤ 1. Now suppose that it holds for n = m − 1 and consider the subsets of a set, S, of m elements. Choose an element s ∈ S and write S = T ∪ {s} where T has m − 1 elements. To choose a subset of S we can ﬁrst choose a subset of T (2m−1 choices by the inductive hypothesis), and then whether or not to include s (2 choices). By the multiplication principle, the number of subsets of S is 2m−1 × 2 = 2 m. There’s a third basic principle4 which is often used implicitly rather than explicitly, but which we’ll have the opportunity to use more explicitly later, so we might as well mention it here. I call it the Double Counting Principle If there are two or more correct ways to compute |A| they must all give the same answer. 3 Four Fundamental Counting Problems Now we turn to four related counting problems – these are the basic ingredients in many other problems. All four deal with the following basic question: In how many ways can k objects be selected from a set of n objects? I’ve deliberately made the statement of the question ambiguous. There are two obvious issues: • Does the order in which we select the objects matter? • Can the same object be selected more than once? The four possible combinations of yes/no answers to these two problems (by an application of the multiplication principle!) give us our four related problems. Let’s review them all and then begin: • If we take the order of selection into account, and allow repetition, then we are constructing sequences of k objects from among n. 4Warning! While almost everyone will know what you mean when you say “addition principle” or “multiplication principle”, this one has lots of aliases. 3 • If we take the order of selection into account, but do not allow repetition, then we are constructing permutations of k objects from among n. • If we do not take the order of selection into account, and do not allow repetition, then we are constructing subsets of k objects from among n. • If we do not take the order of selection into account, but do allow repetition, then we are constructing multisets of k objects from among n. Now let’s begin with the speciﬁc problem: how many sequences (ordered selections, repetition allowed) of k objects can be constructed from a pool of n objects? This one is a simple application of the multiplication principle. Since the order of selection matters, we consider the selection of each item in turn. We have n choices for the ﬁrst item, n for the second, n for the third, . . . , and n for the kth. By the multiplication principle we conclude: The number of sequences of k objects from among n objects is k times z }| { n × n × · · · × n = nk. The second example: how many permutations (ordered selections, repetition forbidden) of k objects can be constructed from a pool of n objects? Again this is an application of the multiplication principle. Each object we select rules it out as a future selection. So, we have n choices for our ﬁrst item, n − 1 for the second, n − 2 for the third, . . . , and n − k + 1 for the kth. By the multiplication principle we conclude: The number of permutations of k objects from among n objects is P (n, k) = k factors z }| { n × (n − 1) × · · · × (n − k + 1) . You may have seen a slightly diﬀerent version of this formula. If we deﬁne: n! = n × (n − 1) × (n − 2) × · · · × 3 × 2 × 1 (read “n factorial”) and if 1 ≤ k ≤ n then P (n, k) = n!/(n − k)! (0! = 1 by deﬁnition.) Now, the cases 1 ≤ k ≤ n are the “interesting”ones, in that if we attempt to construct a permutation of more than n objects from among n we cannot (by the pigeonhole principle, a sequence of more than n items from an n element set must contain a repetition) and so the count of such permutations is 0. However, the original formula gives that answer, whereas the new one gives nonsense, since it involves the factorial of a negative number. In an abstract problem you might not know in advance whether or not k is in the interesting range – and using the original formula might let you avoid a case distinction. The third example: how many subset (unordered selections, repetition forbidden) of k objects can be constructed from a pool of n objects? The number we seek is denoted C(n, k) or (n k) (and read “n choose k”.) It might seem that this is a much more diﬃcult problem – because the order of selection is no longer important, it is not at all clear how to apply any 4 of our basic principles. But perhaps we can ﬁnd a use of the double counting principle, solving a problem that we know the answer to in a way that makes use of the number C(n, k) that we seek. Here’s the idea – we previously computed P (n, k) by selecting the elements of a permutation in order. However, we could instead ﬁrst select the set of elements that we will place in the permutation, and then choosing the order (the positions of the ﬁnalists in a 100m race will represent a permutation of say 6 of the original 40 entrants – this order is generally found by ﬁrst choosing the 6 ﬁnalists, and then determining the appropriate permutation). Obviously there are C(n, k) ways to choose the set of elements. Having chosen them, they can be arranged in P (k, k) = k! ways. By the multiplication and double counting principles: C(n, k) × k! = P (n, k). The number of subsets of k objects from among n objects is C(n, k) = P (n, k)/k! = n! k!(n − k)! (the latter only holding in the interesting cases 0 ≤ k ≤ n.) Before carrying on, another application of the double counting principle (we’ll return to the topic of combina- torial identities later): n∑ k=0 C(n, k) = 2n. We know that the right hand side counts the number of subsets of an n element set. The left hand side does too. To choose a subset we can ﬁrst choose its size (k) and then choose a set of that size. Since these possible choices are disjoint, the addition principle applies and we get the left hand side. The ﬁnal example: how many multisets (unordered selection, repetition allowed) of k objects can be constructed from a pool of n objects? A multiset is sort of like a shopping list: “3 apples, 2 kiwifruit, no bananas, 4 tomatoes” is a multiset of 9 items from the four element set {apple, kiwifruit, banana, tomato}. So, we can associate with a multiset of size k from among n elements a solution to the equation: x1 + x2 + x3 + · · · + xn = k in non-negative integers. here x1 counts the number of times the ﬁrst element appears in the multiset, x2 the number of times the second element occurs and so on. In our previous example, the solution (3, 2, 0, 4) to the equation x1 + x2 + x3 + x4 = 9 would represent that particular multiset. If we represent that solution in tally notation: ||| + || + +|||| we see that a solution to the equation of the desired form corresponds to an arrangement of nine |’s and three +’s in any order. We could get such an arrangement by beginning with 12 |’s and choosing three of them to draw strokes through, making them +’s. So, we can do this in C(12, 3) ways. This argument generalizes easily and gives: The number of multisets of k objects from among n objects is C(n + k − 1, k − 1) = C(n + k − 1, n) (the two forms according to whether we think of choosing the symbols that are +’s or those that are |’s.) Note that of the four problems, the multiset problem is the least “basic”, which is probably why it doesn’t have its own special symbol! 5","libVersion":"0.3.1","langs":""}