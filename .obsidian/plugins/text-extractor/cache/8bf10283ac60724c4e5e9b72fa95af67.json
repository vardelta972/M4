{"path":"iCloudDrive/bks/Number Theory/Number Theory 2/Elementary NT - William Stein.pdf","text":"This is page i Printer: Opaque this Elementary Number Theory: Primes, Congruences, and Secrets William Stein November 16, 2011 v To my wife Clarita Lefthand vi This is page vii Printer: Opaque this Contents Preface ix 1 Prime Numbers 1 1.1 Prime Factorization . . . . . . . . . . . . . . . . . . . . . . 2 1.2 The Sequence of Prime Numbers . . . . . . . . . . . . . . . 10 1.3 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 2 The Ring of Integers Modulo n 21 2.1 Congruences Modulo n . . . . . . . . . . . . . . . . . . . . . 22 2.2 The Chinese Remainder Theorem . . . . . . . . . . . . . . . 29 2.3 Quickly Computing Inverses and Huge Powers . . . . . . . . 31 2.4 Primality Testing . . . . . . . . . . . . . . . . . . . . . . . . 36 2.5 The Structure of (Z/pZ) ∗ . . . . . . . . . . . . . . . . . . . 39 2.6 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44 3 Public-key Cryptography 49 3.1 Playing with Fire . . . . . . . . . . . . . . . . . . . . . . . . 49 3.2 The Diﬃe-Hellman Key Exchange . . . . . . . . . . . . . . 51 3.3 The RSA Cryptosystem . . . . . . . . . . . . . . . . . . . . 56 3.4 Attacking RSA . . . . . . . . . . . . . . . . . . . . . . . . . 61 3.5 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67 4 Quadratic Reciprocity 69 4.1 Statement of the Quadratic Reciprocity Law . . . . . . . . 70 viii Contents 4.2 Euler’s Criterion . . . . . . . . . . . . . . . . . . . . . . . . 73 4.3 First Proof of Quadratic Reciprocity . . . . . . . . . . . . . 75 4.4 A Proof of Quadratic Reciprocity Using Gauss Sums . . . . 81 4.5 Finding Square Roots . . . . . . . . . . . . . . . . . . . . . 86 4.6 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89 5 Continued Fractions 93 5.1 The Deﬁnition . . . . . . . . . . . . . . . . . . . . . . . . . 94 5.2 Finite Continued Fractions . . . . . . . . . . . . . . . . . . 95 5.3 Inﬁnite Continued Fractions . . . . . . . . . . . . . . . . . . 101 5.4 The Continued Fraction of e . . . . . . . . . . . . . . . . . . 107 5.5 Quadratic Irrationals . . . . . . . . . . . . . . . . . . . . . . 110 5.6 Recognizing Rational Numbers . . . . . . . . . . . . . . . . 115 5.7 Sums of Two Squares . . . . . . . . . . . . . . . . . . . . . 117 5.8 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121 6 Elliptic Curves 123 6.1 The Deﬁnition . . . . . . . . . . . . . . . . . . . . . . . . . 124 6.2 The Group Structure on an Elliptic Curve . . . . . . . . . . 125 6.3 Integer Factorization Using Elliptic Curves . . . . . . . . . 129 6.4 Elliptic Curve Cryptography . . . . . . . . . . . . . . . . . 135 6.5 Elliptic Curves Over the Rational Numbers . . . . . . . . . 140 6.6 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146 Answers and Hints 149 References 155 Index 160 This is page ix Printer: Opaque this Preface This is a book about prime numbers, congruences, secret messages, and elliptic curves that you can read cover to cover. It grew out of undergrad- uate courses that the author taught at Harvard, UC San Diego, and the University of Washington. The systematic study of number theory was initiated around 300B.C. when Euclid proved that there are inﬁnitely many prime numbers, and also cleverly deduced the fundamental theorem of arithmetic, which asserts that every positive integer factors uniquely as a product of primes. Over a thousand years later (around 972A.D.) Arab mathematicians formulated the congruent number problem that asks for a way to decide whether or not a given positive integer n is the area of a right triangle, all three of whose sides are rational numbers. Then another thousand years later (in 1976), Diﬃe and Hellman introduced the ﬁrst ever public-key cryptosystem, which enabled two people to communicate secretely over a public communications channel with no predetermined secret; this invention and the ones that followed it revolutionized the world of digital communication. In the 1980s and 1990s, elliptic curves revolutionized number theory, providing striking new insights into the congruent number problem, primality testing, public- key cryptography, attacks on public-key systems, and playing a central role in Andrew Wiles’ resolution of Fermat’s Last Theorem. Today, pure and applied number theory is an exciting mix of simultane- ously broad and deep theory, which is constantly informed and motivated by algorithms and explicit computation. Active research is underway that promises to resolve the congruent number problem, deepen our understand- ing into the structure of prime numbers, and both challenge and improve x Preface our ability to communicate securely. The goal of this book is to bring the reader closer to this world. The reader is strongly encouraged to do every exercise in this book, checking their answers in the back (where many, but not all, solutions are given). Also, throughout the text there, are examples of calculations done using the powerful free open source mathematical software system Sage (http://www.sagemath.org), and the reader should try every such example and experiment with similar examples. Background. The reader should know how to read and write mathemati- cal proofs and must have know the basics of groups, rings, and ﬁelds. Thus, the prerequisites for this book are more than the prerequisites for most el- ementary number theory books, while still being aimed at undergraduates. Notation and Conventions. We let N = {1, 2, 3, . . .} denote the natural numbers, and use the standard notation Z, Q, R, and C for the rings of integer, rational, real, and complex numbers, respectively. In this book, we will use the words proposition, theorem, lemma, and corollary as follows. Usually a proposition is a less important or less fundamental assertion, a theorem is a deeper culmination of ideas, a lemma is something that we will use later in this book to prove a proposition or theorem, and a corollary is an easy consequence of a proposition, theorem, or lemma. More diﬃcult exercises are marked with a (*). Acknowledgements. I would like to thank Brian Conrad, Carl Pomer- ance, and Ken Ribet for many clarifying comments and suggestions. Bau- rzhan Bektemirov, Lawrence Cabusora, and Keith Conrad read drafts of this book and made many comments, and Carl Witty commented exten- sively on the ﬁrst two chapters. Frank Calegari used the course when teaching Math 124 at Harvard, and he and his students provided much feedback. Noam Elkies made comments and suggested Exercise 4.6. Seth Kleinerman wrote a version of Section 5.4 as a class project. Hendrik Lenstra made helpful remarks about how to present his factorization al- gorithm. Michael Abshoﬀ, Sabmit Dasgupta, David Joyner, Arthur Pat- terson, George Stephanides, Kevin Stern, Eve Thompson, Ting-You Wang, and Heidi Williams all suggested corrections. I also beneﬁted from conver- sations with Henry Cohn and David Savitt. I used Sage ([Sag08]), emacs, and LATEX in the preparation of this book. This is page 1 Printer: Opaque this 1 Prime Numbers Every positive integer can be written uniquely as a product of prime num- bers, e.g., 100 = 22 · 5 2. This is surprisingly diﬃcult to prove, as we will see below. Even more astounding is that actually ﬁnding a way to write certain 1,000-digit numbers as a product of primes seems out of the reach of present technology, an observation that is used by millions of people every day when they buy things online. Since prime numbers are the building blocks of integers, it is natural to wonder how the primes are distributed among the integers. “There are two facts about the distribution of prime numbers. The ﬁrst is that, [they are] the most arbitrary and ornery ob- jects studied by mathematicians: they grow like weeds among the natural numbers, seeming to obey no other law than that of chance, and nobody can predict where the next one will sprout. The second fact is even more astonishing, for it states just the opposite: that the prime numbers exhibit stunning regularity, that there are laws governing their behavior, and that they obey these laws with almost military precision.” — Don Zagier [Zag75] The Riemann Hypothesis, which is the most famous unsolved problem in number theory, postulates a very precise answer to the question of how the prime numbers are distributed. This chapter lays the foundations for our study of the theory of numbers by weaving together the themes of prime numbers, integer factorization, and the distribution of primes. In Section 1.1, we rigorously prove that the 2 1. Prime Numbers every positive integer is a product of primes, and give examples of speciﬁc integers for which ﬁnding such a decomposition would win one a large cash bounty. In Section 1.2, we discuss theorems about the set of prime numbers, starting with Euclid’s proof that this set is inﬁnite, and discuss the largest known prime. Finally we discuss the distribution of primes via the prime number theorem and the Riemann Hypothesis. 1.1 Prime Factorization 1.1.1 Primes The set of natural numbers is N = {1, 2, 3, 4, . . .}, and the set of integers is Z = {. . . , −2, −1, 0, 1, 2, . . .}. Deﬁnition 1.1.1 (Divides). If a, b ∈ Z we say that a divides b, written a | b, if ac = b for some c ∈ Z. In this case, we say a is a divisor of b. We say that a does not divide b, written a ∤ b, if there is no c ∈ Z such that ac = b. For example, we have 2 | 6 and −3 | 15. Also, all integers divide 0, and 0 divides only 0. However, 3 does not divide 7 in Z. Remark 1.1.2. The notation b . : a for “b is divisible by a” is common in Russian literature on number theory. Deﬁnition 1.1.3 (Prime and Composite). An integer n > 1 is prime if the only positive divisors of n are 1 and n. We call n composite if n is not prime. The number 1 is neither prime nor composite. The ﬁrst few primes of N are 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, . . . , and the ﬁrst few composites are 4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22, 24, 25, 26, 27, 28, 30, 32, 33, 34, . . . . Remark 1.1.4. J. H. Conway argues in [Con97, viii] that −1 should be considered a prime, and in the 1914 table [Leh14], Lehmer considers 1 to be a prime. In this book, we consider neither −1 nor 1 to be prime. SAGE Example 1.1.5. We use Sage to compute all prime numbers between a and b − 1. 1.1 Prime Factorization 3 sage: prime_range(10,50) [11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] We can also compute the composites in an interval. sage: [n for n in range(10,30) if not is_prime(n)] [10, 12, 14, 15, 16, 18, 20, 21, 22, 24, 25, 26, 27, 28] Every natural number is built, in a unique way, out of prime numbers: Theorem 1.1.6 (Fundamental Theorem of Arithmetic). Every natural number can be written as a product of primes uniquely up to order. Note that primes are the products with only one factor and 1 is the empty product. Remark 1.1.7. Theorem 1.1.6, which we will prove in Section 1.1.4, is trick- ier to prove than you might ﬁrst think. For example, unique factorization fails in the ring Z[√−5] = {a + b√−5 : a, b ∈ Z} ⊂ C, where 6 factors in two diﬀerent ways: 6 = 2 · 3 = (1 + √−5) · (1 − √−5). 1.1.2 The Greatest Common Divisor We will use the notion of the greatest common divisor of two integers to prove that if p is a prime and p | ab, then p | a or p | b. Proving this is the key step in our proof of Theorem 1.1.6. Deﬁnition 1.1.8 (Greatest Common Divisor). Let gcd(a, b) = max {d ∈ Z : d | a and d | b} , unless both a and b are 0 in which case gcd(0, 0) = 0. For example, gcd(1, 2) = 1, gcd(6, 27) = 3, and for any a, gcd(0, a) = gcd(a, 0) = a. If a ̸= 0, the greatest common divisor exists because if d | a then d ≤ |a|, and there are only |a| positive integers ≤ |a|. Similarly, the gcd exists when b ̸= 0. Lemma 1.1.9. For any integers a and b, we have gcd(a, b) = gcd(b, a) = gcd(±a, ±b) = gcd(a, b − a) = gcd(a, b + a). Proof. We only prove that gcd(a, b) = gcd(a, b − a), since the other cases are proved in a similar way. Suppose d | a and d | b, so there exist integers c1 and c2 such that dc1 = a and dc2 = b. Then b−a = dc2 −dc1 = d(c2 −c1), 4 1. Prime Numbers so d | b − a. Thus gcd(a, b) ≤ gcd(a, b − a), since the set over which we are taking the max for gcd(a, b) is a subset of the set for gcd(a, b − a). The same argument with a replaced by −a and b replaced by b − a, shows that gcd(a, b − a) = gcd(−a, b − a) ≤ gcd(−a, b) = gcd(a, b), which proves that gcd(a, b) = gcd(a, b − a). Lemma 1.1.10. Suppose a, b, n ∈ Z. Then gcd(a, b) = gcd(a, b − an). Proof. By repeated application of Lemma 1.1.9, we have gcd(a, b) = gcd(a, b − a) = gcd(a, b − 2a) = · · · = gcd(a, b − an). Assume for the moment that we have already proved Theorem 1.1.6. A naive way to compute gcd(a, b) is to factor a and b as a product of primes using Theorem 1.1.6; then the prime factorization of gcd(a, b) can be read oﬀ from that of a and b. For example, if a = 2261 and b = 1275, then a = 7 · 17 · 19 and b = 3 · 5 2 · 17, so gcd(a, b) = 17. It turns out that the greatest common divisor of two integers, even huge numbers (millions of digits), is surprisingly easy to compute using Algorithm 1.1.13 below, which computes gcd(a, b) without factoring a or b. To motivate Algorithm 1.1.13, we compute gcd(2261, 1275) in a diﬀerent way. First, we recall a helpful fact. Proposition 1.1.11. Suppose that a and b are integers with b ̸= 0. Then there exists unique integers q and r such that 0 ≤ r < |b| and a = bq + r. Proof. For simplicity, assume that both a and b are positive (we leave the general case to the reader). Let Q be the set of all nonnegative integers n such that a − bn is nonnegative. Then Q is nonempty because 0 ∈ Q and Q is bounded because a − bn < 0 for all n > a/b. Let q be the largest element of Q. Then r = a − bq < b, otherwise q + 1 would also be in Q. Thus q and r satisfy the existence conclusion. To prove uniqueness, suppose that q′ and r′ also satisfy the conclusion. Then q′ ∈ Q since r′ = a − bq′ ≥ 0, so q′ ≤ q, and we can write q′ = q − m for some m ≥ 0. If q′ ̸= q, then m ≥ 1 so r′ = a − bq′ = a − b(q − m) = a − bq + bm = r + bm ≥ b since r ≥ 0, a contradiction. Thus q = q′ and r′ = a − bq′ = a − bq = r, as claimed. For us, an algorithm is a ﬁnite sequence of instructions that can be fol- lowed to perform a speciﬁc task, such as a sequence of instructions in a computer program, which must terminate on any valid input. The word “al- gorithm” is sometimes used more loosely (and sometimes more precisely) than deﬁned here, but this deﬁnition will suﬃce for us. 1.1 Prime Factorization 5 Algorithm 1.1.12 (Division Algorithm). Suppose a and b are integers with b ̸= 0. This algorithm computes integers q and r such that 0 ≤ r < |b| and a = bq + r. We will not describe the actual steps of Algorithm 1.1.12, since it is just the familiar long division algorithm. Note that it might not be exactly the same as the standard long division algorithm you learned in school, because we make the remainder positive even when dividing a negative number by a positive number. We use the division algorithm repeatedly to compute gcd(2261, 1275). Dividing 2261 by 1275 we ﬁnd that 2261 = 1 · 1275 + 986, so q = 1 and r = 986. Notice that if a natural number d divides both 2261 and 1275, then d divides their diﬀerence 986 and d still divides 1275. On the other hand, if d divides both 1275 and 986, then it has to divide their sum 2261 as well! We have made progress: gcd(2261, 1275) = gcd(1275, 986). This equality also follows by applying Lemma 1.1.9. Repeating, we have 1275 = 1 · 986 + 289, so gcd(1275, 986) = gcd(986, 289). Keep going: 986 = 3 · 289 + 119 289 = 2 · 119 + 51 119 = 2 · 51 + 17. Thus gcd(2261, 1275) = · · · = gcd(51, 17), which is 17 because 17 | 51. Thus gcd(2261, 1275) = 17. Aside from some tedious arithmetic, that computation was systematic, and it was not necessary to factor any integers (which is something we do not know how to do quickly if the numbers involved have hundreds of digits). Algorithm 1.1.13 (Greatest Common Division). Given integers a, b, this algorithm computes gcd(a, b). 1. [Assume a > b > 0] We have gcd(a, b) = gcd(|a|, |b|) = gcd(|b|, |a|), so we may replace a and b by their absolute values and hence assume a, b ≥ 0. If a = b, output a and terminate. Swapping if necessary, we assume a > b. If b = 0, we output a. 2. [Quotient and Remainder] Using Algorithm 1.1.12, write a = bq + r, with 0 ≤ r < b and q ∈ Z. 6 1. Prime Numbers 3. [Finished?] If r = 0, then b | a, so we output b and terminate. 4. [Shift and Repeat] Set a ← b and b ← r, then go to Step 2. Proof. Lemmas 1.1.9–1.1.10 imply that gcd(a, b) = gcd(b, r) so the gcd does not change in Step 4. Since the remainders form a decreasing sequence of nonnegative integers, the algorithm terminates. Example 1.1.14. Set a = 15 and b = 6. 15 = 6 · 2 + 3 gcd(15, 6) = gcd(6, 3) 6 = 3 · 2 + 0 gcd(6, 3) = gcd(3, 0) = 3 Note that we can just as easily do an example that is ten times as big, an observation that will be important in the proof of Theorem 1.1.19 below. Example 1.1.15. Set a = 150 and b = 60. 150 = 60 · 2 + 30 gcd(150, 60) = gcd(60, 30) 60 = 30 · 2 + 0 gcd(60, 30) = gcd(30, 0) = 30 SAGE Example 1.1.16. Sage uses the gcd command to compute the great- est common divisor of two integers. For example, sage: gcd(97,100) 1 sage: gcd(97 * 10^15, 19^20 * 97^2) 97 Lemma 1.1.17. For any integers a, b, n, we have gcd(an, bn) = gcd(a, b) · |n|. Proof. The idea is to follow Example 1.1.15; we step through Euclid’s al- gorithm for gcd(an, bn) and note that at every step the equation is the equation from Euclid’s algorithm for gcd(a, b) but multiplied through by n. For simplicity, assume that both a and b are positive. We will prove the lemma by induction on a + b. The statement is true in the base case when a + b = 2, since then a = b = 1. Now assume a, b are arbitrary with a ≥ b. Let q and r be such that a = bq + r and 0 ≤ r < b. Then by Lemmas 1.1.9– 1.1.10, we have gcd(a, b) = gcd(b, r). Multiplying a = bq + r by n we see that an = bnq + rn, so gcd(an, bn) = gcd(bn, rn). Then b + r = b + (a − bq) = a − b(q − 1) ≤ a < a + b, so by induction gcd(bn, rn) = gcd(b, r) · |n|. Since gcd(a, b) = gcd(b, r), this proves the lemma. Lemma 1.1.18. Suppose a, b, n ∈ Z are such that n | a and n | b. Then n | gcd(a, b). 1.1 Prime Factorization 7 Proof. Since n | a and n | b, there are integers c1 and c2, such that a = nc1 and b = nc2. By Lemma 1.1.17, gcd(a, b) = gcd(nc1, nc2) = n gcd(c1, c2), so n divides gcd(a, b). With Algorithm 1.1.13, we can prove that if a prime divides the product of two numbers, then it has got to divide one of them. This result is the key to proving that prime factorization is unique. Theorem 1.1.19 (Euclid). Let p be a prime and a, b ∈ N. If p | ab then p | a or p | b. You might think this theorem is “intuitively obvious,” but that might be because the fundamental theorem of arithmetic (Theorem 1.1.6) is deeply ingrained in your intuition. Yet Theorem 1.1.19 will be needed in our proof of the fundamental theorem of arithmetic. Proof of Theorem 1.1.19. If p | a we are done. If p ∤ a then gcd(p, a) = 1, since only 1 and p divide p. By Lemma 1.1.17, gcd(pb, ab) = b. Since p | pb and, by hypothesis, p | ab, it follows (using Lemma 1.1.17) that p | gcd(pb, ab) = b gcd(p, a) = b · 1 = b. 1.1.3 Numbers Factor as Products of Primes In this section, we prove that every natural number factors as a product of primes. Then we discuss the diﬃculty of ﬁnding such a decomposition in practice. We will wait until Section 1.1.4 to prove that factorization is unique. As a ﬁrst example, let n = 1275. The sum of the digits of n is divisible by 3, so n is divisible by 3 (see Proposition 2.1.9), and we have n = 3 · 425. The number 425 is divisible by 5, since its last digit is 5, and we have 1275 = 3 · 5 · 85. Again, dividing 85 by 5, we have 1275 = 3 · 52 · 17, which is the prime factorization of 1275. Generalizing this process proves the following proposition. Proposition 1.1.20. Every natural number is a product of primes. Proof. Let n be a natural number. If n = 1, then n is the empty product of primes. If n is prime, we are done. If n is composite, then n = ab with a, b < n. By induction, a and b are products of primes, so n is also a product of primes. Two questions immediately arise: (1) is this factorization unique, and (2) how quickly can we ﬁnd such a factorization? Addressing (1), what if we had done something diﬀerently when breaking apart 1275 as a product of primes? Could the primes that show up be diﬀerent? Let’s try: we have 8 1. Prime Numbers 1275 = 5 · 255. Now 255 = 5 · 51 and 51 = 17 · 3, and again the factorization is the same, as asserted by Theorem 1.1.6. We will prove the uniqueness of the prime factorization of any integer in Section 1.1.4. SAGE Example 1.1.21. The factor command in Sage factors an integer as a product of primes with multiplicities. For example, sage: factor(1275) 3 * 5^2 * 17 sage: factor(2007) 3^2 * 223 sage: factor(31415926535898) 2 * 3 * 53 * 73 * 2531 * 534697 Regarding (2), there are algorithms for integer factorization. It is a major open problem to decide how fast integer factorization algorithms can be. We say that an algorithm to factor n is polynomial time if there is a polynomial f (x) such that for any n the number of steps needed by the algorithm to factor n is less than f (log10(n)). Note that log10(n) is an approximation for the number of digits of the input n to the algorithm. Open Problem 1.1.22. Is there an algorithm that can factor any integer n in polynomial time? Peter Shor [Sho97] devised a polynomial time algorithm for factoring integers on quantum computers. We will not discuss his algorithm further, except to note that in 2001 IBM researchers built a quantum computer that used Shor’s algorithm to factor 15 (see [LMG+01, IBM01]). Building much larger quantum computers appears to be extremely diﬃcult. You can earn money by factoring certain large integers. Many cryptosys- tems would be easily broken if factoring certain large integers was easy. Since nobody has proven that factoring integers is diﬃcult, one way to increase conﬁdence that factoring is diﬃcult is to oﬀer cash prizes for fac- toring certain integers. For example, until recently there was a $10,000 bounty on factoring the following 174-digit integer (see [RSA]): 1881988129206079638386972394616504398071635633794173827007 6335642298885971523466548531906060650474304531738801130339 6716199692321205734031879550656996221305168759307650257059 This number is known as RSA-576 since it has 576 digits when written in binary (see Section 2.3.2 for more on binary numbers). It was factored at the German Federal Agency for Information Technology Security in December 2003 (see [Wei03]): 398075086424064937397125500550386491199064362342526708406 385189575946388957261768583317 × 472772146107435302536223071973048224632914695302097116459 852171130520711256363590397527 1.1 Prime Factorization 9 The previous RSA challenge was the 155-digit number 1094173864157052742180970732204035761200373294544920599091 3842131476349984288934784717997257891267332497625752899781 833797076537244027146743531593354333897. It was factored on 22 August 1999 by a group of sixteen researchers in four months on a cluster of 292 computers (see [ACD+99]). They found that RSA-155 is the product of the following two 78-digit primes: p = 10263959282974110577205419657399167590071656780803806 6803341933521790711307779 q = 10660348838016845482092722036001287867920795857598929 1522270608237193062808643. The next RSA challenge is RSA-640: 31074182404900437213507500358885679300373460228427275457201619 48823206440518081504556346829671723286782437916272838033415471 07310850191954852900733772482278352574238645401469173660247765 2346609, and its factorization was worth $20,000 until November 2005 when it was factored by F. Bahr, M. Boehm, J. Franke, and T. Kleinjun. This factor- ization took ﬁve months. Here is one of the prime factors (you can ﬁnd the other): 16347336458092538484431338838650908598417836700330923121811108 52389333100104508151212118167511579. (This team also factored a 663-bit RSA challenge integer.) The smallest currently open challenge is RSA-704, worth $30,000: 74037563479561712828046796097429573142593188889231289084936232 63897276503402826627689199641962511784399589433050212758537011 89680982867331732731089309005525051168770632990723963807867100 86096962537934650563796359 SAGE Example 1.1.23. Using Sage, we see that the above number has 212 decimal digits and is deﬁnitely composite: sage: n = 7403756347956171282804679609742957314259318888\\ ...9231289084936232638972765034028266276891996419625117\\ ...8439958943305021275853701189680982867331732731089309\\ ...0055250511687706329907239638078671008609696253793465\\ ...0563796359 sage: len(n.str(2)) 10 1. Prime Numbers 704 sage: len(n.str(10)) 212 sage: n.is_prime() # this is instant False These RSA numbers were factored using an algorithm called the number ﬁeld sieve (see [LL93]), which is the best-known general purpose factoriza- tion algorithm. A description of how the number ﬁeld sieve works is beyond the scope of this book. However, the number ﬁeld sieve makes extensive use of the elliptic curve factorization method, which we will describe in Sec- tion 6.3. 1.1.4 The Fundamental Theorem of Arithmetic We are ready to prove Theorem 1.1.6 using the following idea. Suppose we have two factorizations of n. Using Theorem 1.1.19, we cancel common primes from each factorization, one prime at a time. At the end, we dis- cover that the factorizations must consist of exactly the same primes. The technical details are given below. Proof. If n = 1, then the only factorization is the empty product of primes, so suppose n > 1. By Proposition 1.1.20, there exist primes p1, . . . , pd such that n = p1p2 · · · pd. Suppose that n = q1q2 · · · qm is another expression of n as a product of primes. Since p1 | n = q1(q2 · · · qm), Euclid’s theorem implies that p1 = q1 or p1 | q2 · · · qm. By induction, we see that p1 = qi for some i. Now cancel p1 and qi, and repeat the above argument. Eventually, we ﬁnd that, up to order, the two factorizations are the same. 1.2 The Sequence of Prime Numbers This section is concerned with three questions: 1. Are there inﬁnitely many primes? 2. Given a, b ∈ Z, are there inﬁnitely many primes of the form ax + b? 1.2 The Sequence of Prime Numbers 11 3. How are the primes spaced along the number line? We ﬁrst show that there are inﬁnitely many primes, then state Dirichlet’s theorem that if gcd(a, b) = 1, then ax + b is a prime for inﬁnitely many values of x. Finally, we discuss the Prime Number Theorem which asserts that there are asymptotically x/ log(x) primes less than x, and we make a connection between this asymptotic formula and the Riemann Hypothesis. 1.2.1 There Are Inﬁnitely Many Primes Each number on the left in the following table is prime. We will see soon that this pattern does not continue indeﬁnitely, but something similar works. 3 = 2 + 1 7 = 2 · 3 + 1 31 = 2 · 3 · 5 + 1 211 = 2 · 3 · 5 · 7 + 1 2311 = 2 · 3 · 5 · 7 · 11 + 1 Theorem 1.2.1 (Euclid). There are inﬁnitely many primes. Proof. Suppose that p1, p2, . . . , pn are n distinct primes. We construct a prime pn+1 not equal to any of p1, . . . , pn, as follows. If N = p1p2p3 · · · pn + 1, (1.2.1) then by Proposition 1.1.20 there is a factorization N = q1q2 · · · qm with each qi prime and m ≥ 1. If q1 = pi for some i, then pi | N . Because of (1.2.1), we also have pi | N − 1, so pi | 1 = N − (N − 1), which is a contradiction. Thus the prime pn+1 = q1 is not in the list p1, . . . , pn, and we have constructed our new prime. For example, 2 · 3 · 5 · 7 · 11 · 13 + 1 = 30031 = 59 · 509. Multiplying together the ﬁrst six primes and adding 1 doesn’t produce a prime, but it produces an integer that is merely divisible by a new prime. Joke 1.2.2 (Hendrik Lenstra). There are inﬁnitely many composite num- bers. Proof. To obtain a new composite number, multiply together the ﬁrst n composite numbers and don’t add 1. 12 1. Prime Numbers 1.2.2 Enumerating Primes In this section we describe a sieving process that allows us to enumerate all primes up to n. The sieve works by ﬁrst writing down all numbers up to n, noting that 2 is prime, and crossing oﬀ all multiples of 2. Next, note that the ﬁrst number not crossed oﬀ is 3, which is prime, and cross oﬀ all multiples of 3, etc. Repeating this process, we obtain a list of the primes up to n. Formally, the algorithm is as follows: Algorithm 1.2.3 (Prime Sieve). Given a positive integer n, this algorithm computes a list of the primes up to n. 1. [Initialize] Let X = [3, 5, . . .] be the list of all odd integers between 3 and n. Let P = [2] be the list of primes found so far. 2. [Finished?] Let p be the ﬁrst element of X. If p ≥ √n, append each element of X to P and terminate. Otherwise append p to P . 3. [Cross Oﬀ] Set X equal to the sublist of elements in X that are not divisible by p. Go to Step 2. For example, to list the primes ≤ 40 using the sieve, we proceed as follows. First P = [2] and X = [3, 5, 7, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39]. We append 3 to P and cross oﬀ all multiples of 3 to obtain the new list X = [5, 7, 11, 13, 17, 19, 23, 25, 29, 31, 35, 37]. Next we append 5 to P , obtaining P = [2, 3, 5], and cross oﬀ the multiples of 5, to obtain X = [7, 11, 13, 17, 19, 23, 29, 31, 37]. Because 72 ≥ 40, we append X to P and ﬁnd that the primes less than 40 are 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37. Proof of Algorithm 1.2.3. The part of the algorithm that is not clear is that when the ﬁrst element a of X satisﬁes a ≥ √n, then each element of X is prime. To see this, suppose m is in X, so √n ≤ m ≤ n and that m is divisible by no prime that is ≤ √n. Write m = ∏ p ei i with the pi distinct primes ordered so that p1 < p2 < . . .. If pi > √n for each i and there is more than one pi, then m > n, a contradiction. Thus some pi is less than√n, which also contradicts our assumptions on m. 1.2.3 The Largest Known Prime Though Theorem 1.2.1 implies that there are inﬁnitely many primes, it still makes sense to ask the question “What is the largest known prime?” 1.2 The Sequence of Prime Numbers 13 A Mersenne prime is a prime of the form 2 q − 1. According to [Cal] the largest known prime as of March 2007 is the 44th known Mersenne prime p = 2 32582657 − 1, which has 9,808,358 decimal digits 1. This would take over 2000 pages to print, assuming a page contains 60 lines with 80 characters per line. The Electronic Frontier Foundation has oﬀered a $100,000 prize to the ﬁrst person who ﬁnds a 10,000,000 digit prime. Euclid’s theorem implies that there deﬁnitely are inﬁnitely many primes bigger than p. Deciding whether or not a number is prime is interesting, as a theoretical problem, and as a problem with applications to cryptography, as we will see in Section 2.4 and Chapter 3. SAGE Example 1.2.4. We can compute the decimal expansion of p in Sage, although watch out as this is a serious computation that may take around a minute on your computer. Also, do not print out p or s below, because both would take a very long time to scroll by. sage: p = 2^32582657 - 1 sage: p.ndigits() 9808358 Next we convert p to a decimal string and look at some of the digits. sage: s = p.str(10) # this takes a long time sage: len(s) # s is a very long string (long time) 9808358 sage: s[:20] # the first 20 digits of p (long time) ’12457502601536945540’ sage: s[-20:] # the last 20 digits (long time) ’11752880154053967871’ 1.2.4 Primes of the Form ax + b Next we turn to primes of the form ax + b, where a and b are ﬁxed integers with a > 1 and x varies over the natural numbers N. We assume that gcd(a, b) = 1, because otherwise there is no hope that ax + b is prime inﬁnitely often. For example, 2x + 2 = 2(x + 1) is only prime if x = 0, and is not prime for any x ∈ N. Proposition 1.2.5. There are inﬁnitely many primes of the form 4x − 1. Why might this be true? We list numbers of the form 4x−1 and underline those that are prime. 3, 7, 11, 15, 19, 23, 27, 31, 35, 39, 43, 47, . . . 1The 45th known Mersenne prime may have been found on August 23, 2008 as this book goes to press. 14 1. Prime Numbers Not only is it plausible that underlined numbers will continue to appear indeﬁnitely, it is something we can easily prove. Proof. Suppose p1, p2, . . . , pn are distinct primes of the form 4x − 1. Con- sider the number N = 4p1p2 · · · pn − 1. Then pi ∤ N for any i. Moreover, not every prime p | N is of the form 4x + 1; if they all were, then N would be of the form 4x + 1. Since N is odd, each prime divisor pi is odd so there is a p | N that is of the form 4x − 1. Since p ̸= pi for any i, we have found a new prime of the form 4x − 1. We can repeat this process indeﬁnitely, so the set of primes of the form 4x − 1 cannot be ﬁnite. Note that this proof does not work if 4x − 1 is replaced by 4x + 1, since a product of primes of the form 4x − 1 can be of the form 4x + 1. Example 1.2.6. Set p1 = 3, p2 = 7. Then N = 4 · 3 · 7 − 1 = 83 is a prime of the form 4x − 1. Next N = 4 · 3 · 7 · 83 − 1 = 6971, which is again a prime of the form 4x − 1. Again, N = 4 · 3 · 7 · 83 · 6971 − 1 = 48601811 = 61 · 796751. This time 61 is a prime, but it is of the form 4x + 1 = 4 · 15 + 1. However, 796751 is prime and 796751 = 4 · 199188 − 1. We are unstoppable. N = 4 · 3 · 7 · 83 · 6971 · 796751 − 1 = 5591 · 6926049421. This time the small prime, 5591, is of the form 4x − 1 and the large one is of the form 4x + 1. Theorem 1.2.7 (Dirichlet). Let a and b be integers with gcd(a, b) = 1. Then there are inﬁnitely many primes of the form ax + b. Proofs of this theorem typically use tools from advanced number theory, and are beyond the scope of this book (see e.g., [FT93, §VIII.4]). 1.2.5 How Many Primes are There? We saw in Section 1.2.1 that there are inﬁnitely many primes. In order to get a sense of just how many primes there are, we consider a few warm- up questions. Then we consider some numerical evidence and state the prime number theorem, which gives an asymptotic answer to our question, 1.2 The Sequence of Prime Numbers 15 and connect this theorem with a form of the famous Riemann Hypothesis. Our discussion of counting primes in this section is very cursory; for more details, read Crandall and Pomerance’s excellent book [CP01, §1.1.5]. The following vague discussion is meant to motivate a precise way to measure the number (or percentage) of primes. What percentage of natu- ral numbers are even? Answer: Half of them. What percentage of natural numbers are of the form 4x − 1? Answer: One fourth of them. What per- centage of natural numbers are perfect squares? Answer: Zero percent of all natural numbers, in the sense that the limit of the proportion of perfect squares to all natural numbers converges to 0. More precisely, lim x→∞ #{n ∈ N : n ≤ x and n is a perfect square} x = 0, since the numerator is roughly √x and limx→∞ √x x = 0. Likewise, it is an easy consequence of Theorem 1.2.10 that zero percent of all natural numbers are prime (see Exercise 1.4). We are thus led to ask another question: How many positive integers ≤ x are perfect squares? Answer: Roughly √x. In the context of primes, we ask, Question 1.2.8. How many natural numbers ≤ x are prime? Let π(x) = #{p ∈ N : p ≤ x is a prime}. For example, π(6) = #{2, 3, 5} = 3. Some values of π(x) are given in Table 1.1, and Figures 1.1 and 1.2 contain graphs of π(x). These graphs look like straight lines, which maybe bend down slightly. SAGE Example 1.2.9. To compute π(x) in Sage use the prime pi(x) com- mand: sage: prime_pi(6) 3 sage: prime_pi(100) 25 sage: prime_pi(3000000) 216816 We can also draw a plot of π(x) using the plot command: sage: plot(prime_pi, 1,1000, rgbcolor=(0,0,1)) Gauss was an inveterate computer: he wrote in an 1849 letter that there are 216, 745 primes less than 3, 000, 000 (this is wrong but close; the correct count is 216, 816). 16 1. Prime Numbers TABLE 1.1. Values of π(x) x 100 200 300 400 500 600 700 800 900 1000 π(x) 25 46 62 78 95 109 125 139 154 168 (100, 25) (200, 46) (500, 95) (900, 154) (1000, 168) 250 500 750 1000 50 100 150 200 FIGURE 1.1. Graph of π(x) for x < 1000 Gauss conjectured the following asymptotic formula for π(x), which was later proved independently by Hadamard and Vall´ee Poussin in 1896 (but will not be proved in this book). Theorem 1.2.10 (Prime Number Theorem). The function π(x) is asymp- totic to x/ log(x), in the sense that lim x→∞ π(x) x/ log(x) = 1. We do nothing more here than motivate this deep theorem with a few further observations. The theorem implies that lim x→∞ π(x) x = lim x→∞ 1 log(x) = 0, so for any a, lim x→∞ π(x) x/(log(x) − a) = lim x→∞ π(x) x/ log(x) − aπ(x) x = 1. Thus x/(log(x) − a) is also asymptotic to π(x) for any a. See [CP01, §1.1.5] for a discussion of why a = 1 is the best choice. Table 1.2 compares π(x) and x/(log(x) − 1) for several x < 10000. The record for counting primes is π(10 23) = 1925320391606803968923. Note that such computations are very diﬃcult to get exactly right, so the above might be slightly wrong. For the reader familiar with complex analysis, we mention a connection between π(x) and the Riemann Hypothesis. The Riemann zeta function ζ(s) is a complex analytic function on C \\ {1} that extends the function 1.2 The Sequence of Prime Numbers 17 TABLE 1.2. Comparison of π(x) and x/(log(x) − 1) x π(x) x/(log(x) − 1) (approx) 1000 168 169.2690290604408165186256278 2000 303 302.9888734545463878029800994 3000 430 428.1819317975237043747385740 4000 550 548.3922097278253264133400985 5000 669 665.1418784486502172369455815 6000 783 779.2698885854778626863677374 7000 900 891.3035657223339974352567759 8000 1007 1001.602962794770080754784281 9000 1117 1110.428422963188172310675011 10000 1229 1217.976301461550279200775705 2500 5000 7500 10000 250 500 750 1000 1250 25000 50000 75000 100000 2500 5000 7500 10000 FIGURE 1.2. Graphs of π(x) for x < 10000 and x < 100000 18 1. Prime Numbers deﬁned on a right half plane by ∑∞ n=1 n−s. The Riemann Hypothesis is the conjecture that the zeros in C of ζ(s) with positive real part lie on the line Re(s) = 1/2. This conjecture is one of the Clay Math Institute million dollar millennium prize problems [Cla]. According to [CP01, §1.4.1], the Riemann Hypothesis is equivalent to the conjecture that Li(x) = ∫ x 2 1 log(t) dt is a “good” approximation to π(x), in the following precise sense. Conjecture 1.2.11 (Equivalent to the Riemann Hypothesis). For all x ≥ 2.01, |π(x) − Li(x)| ≤ √x log(x). If x = 2, then π(2) = 1 and Li(2) = 0, but √2 log(2) = 0.9802 . . ., so the inequality is not true for x ≥ 2, but 2.01 is big enough. We will do nothing more to explain this conjecture, and settle for one numerical example. Example 1.2.12. Let x = 4 · 1022. Then π(x) = 783964159847056303858, Li(x) = 783964159852157952242.7155276025801473 . . . , |π(x) − Li(x)| = 5101648384.71552760258014 . . . , √x log(x) = 10408633281397.77913344605 . . . , x/(log(x) − 1) = 783650443647303761503.5237113087392967 . . . . SAGE Example 1.2.13. We use Sage to graph π(x), Li(x), and √x log(x). sage: P = plot(Li, 2,10000, rgbcolor=’purple’) sage: Q = plot(prime_pi, 2,10000, rgbcolor=’black’) sage: R = plot(sqrt(x)*log(x),2,10000,rgbcolor=’red’) sage: show(P+Q+R,xmin=0, figsize=[8,3]) 2500 5000 7500 10000 250 500 750 1000 1250 The topmost line is Li(x), the next line is π(x), and the bottom line is√x log(x). 1.3 Exercises 19 For more on the prime number theorem and the Riemann hypothesis see [Zag75] and [MS08]. 1.3 Exercises 1.1 Compute the greatest common divisor gcd(455, 1235) by hand. 1.2 Use the prime enumeration sieve to make a list of all primes up to 100. 1.3 Prove that there are inﬁnitely many primes of the form 6x − 1. 1.4 Use Theorem 1.2.10 to deduce that lim x→∞ π(x) x = 0. 1.5 Let ψ(x) be the number of primes of the form 4k −1 that are ≤ x. Use a computer to make a conjectural guess about limx→∞ ψ(x)/π(x). 1.6 So far 44 Mersenne primes 2p − 1 have been discovered. Give a guess, backed up by an argument, about when the next Mersenne prime might be discovered (you will have to do some online research). 1.7 (a) Let y = 10000. Compute π(y) = #{primes p ≤ y}. (b) The prime number theorem implies π(x) is asymptotic to x log(x) . How close is π(y) to y/ log(y), where y is as in (a)? 1.8 Let a, b, c, n be integers. Prove that (a) if a | n and b | n with gcd(a, b) = 1, then ab | n. (b) if a | bc and gcd(a, b) = 1, then a | c. 1.9 Let a, b, c, d, and m be integers. Prove that (a) if a | b and b | c then a | c. (b) if a | b and c | d then ac | bd. (c) if m ̸= 0, then a | b if and only if ma | mb. (d) if d | a and a ̸= 0, then |d| ≤ |a|. 1.10 In each of the following, apply the division algorithm to ﬁnd q and r such that a = bq + r and 0 ≤ r < |b|: a = 300, b = 17, a = 729, b = 31, a = 300, b = −17, a = 389, b = 4. 1.11 (a) (Do this part by hand.) Compute the greatest common divisor of 323 and 437 using the algorithm described in class that involves quotients and remainders (i.e., do not just factor a and b). 20 1. Prime Numbers (b) Compute by any means the greatest common divisor of 314159265358979323846264338 and 271828182845904523536028747. 1.12 (a) Suppose a, b and n are positive integers. Prove that if a n | bn, then a | b. (b) Suppose p is a prime and a and k are positive integers. Prove that if p | a k, then p k | a k. 1.13 (a) Prove that if a positive integer n is a perfect square, then n cannot be written in the form 4k + 3 for k an integer. (Hint: Compute the remainder upon division by 4 of each of (4m) 2, (4m + 1)2, (4m + 2)2, and (4m + 3)2.) (b) Prove that no integer in the sequence 11, 111, 1111, 11111, 111111, . . . is a perfect square. (Hint: 111 · · · 111 = 111 · · · 108 + 3 = 4k + 3.) 1.14 Prove that a positive integer n is prime if and only if n is not divisible by any prime p with 1 < p ≤ √n. This is page 21 Printer: Opaque this 2 The Ring of Integers Modulo n A startling fact about numbers is that it takes less than a second to decide with near certainty whether or not any given 1,000 digit number n is a prime, without actually factoring n. The algorithm for this involves doing some arithmetic with n that works diﬀerently depending on whether n is prime or composite. In particular, we do arithmetic with the set (in fact, “ring”) of integers {0, 1, . . . , n − 1} using an innovative rule for addition and multiplication, where the sum and product of two elements of that set is again in that set. Another surprising fact is that one can almost instantly compute the last 1,000 digits of a massive multi-billion digit number like n = 1234 1234567890 without explicitly writing down all the digits of n. Again, this calculation involves arithmetic with the ring {0, 1, . . . , n − 1}. This chapter is about the ring Z/nZ of integers modulo n, the beauti- ful structure this ring has, and how to apply it to the above mentioned problems, among others. It is foundational for the rest of this book. In Sec- tion 2.1, we discuss when linear equations modulo n have a solution, then introduce the Euler ϕ function and prove Euler’s Theorem and Wilson’s theorem. In Section 2.2, we prove the Chinese Remainer Theorem, which addresses simultaneous solubility of several linear equations modulo co- prime moduli. With these theoretical foundations in place, in Section 2.3, we introduce algorithms for doing powerful computations modulo n, in- cluding computing large powers quickly, and solving linear equations. We ﬁnish in Section 2.4 with a discussion of recognizing prime numbers using arithmetic modulo n. 22 2. The Ring of Integers Modulo n 2.1 Congruences Modulo n Deﬁnition 2.1.1 (Group). A group is a set G equipped with a binary operation G × G → G (denoted by multiplication below) and an identity element 1 ∈ G such that: 1. For all a, b, c ∈ G, we have (ab)c = a(bc). 2. For each a ∈ G, we have 1a = a1 = a, and there exists b ∈ G such that ab = 1. Deﬁnition 2.1.2 (Abelian Group). An abelian group is a group G such that ab = ba for every a, b ∈ G. Deﬁnition 2.1.3 (Ring). A ring R is a set equipped with binary operations + and × and elements 0, 1 ∈ R such that R is an abelian group under +, and for all a, b, c ∈ R we have • 1a = a1 = a • (ab)c = a(bc) • a(b + c) = ab + ac. If, in addition, ab = ba for all a, b ∈ R, then we call R a commutative ring. In this section, we deﬁne the ring Z/nZ of integers modulo n, introduce the Euler ϕ-function, and relate it to the multiplicative order of certain elements of Z/nZ. If a, b ∈ Z and n ∈ N, we say that a is congruent to b modulo n if n | a−b, and write a ≡ b (mod n). Let nZ = (n) be the subset of Z consisting of all multiples of n (this is called the “ideal of Z generated by n”). Deﬁnition 2.1.4 (Integers Modulo n). The ring Z/nZ of integers mod- ulo n is the set of equivalence classes of integers modulo n. It is equipped with its natural ring structure: (a + nZ) + (b + nZ) = (a + b) + nZ (a + nZ) · (b + nZ) = (a · b) + nZ. Example 2.1.5. For example, Z/3Z = {{. . . , −3, 0, 3, . . .}, {. . . , −2, 1, 4, . . .}, {. . . , −1, 2, 5, . . .}} SAGE Example 2.1.6. In Sage, we list the elements of Z/nZ as follows: sage: R = Integers(3) sage: list(R) [0, 1, 2] 2.1 Congruences Modulo n 23 We use the notation Z/nZ because Z/nZ is the quotient of the ring Z by the “ideal” nZ of multiples of n. Because Z/nZ is the quotient of a ring by an ideal, the ring structure on Z induces a ring structure on Z/nZ. We often let a or a (mod n) denote the equivalence class a + nZ of a. Deﬁnition 2.1.7 (Field). A ﬁeld K is a ring such that for every nonzero element a ∈ K there is an element b ∈ K such that ab = 1. For example, if p is a prime, then Z/pZ is a ﬁeld (see Exercise 2.12). Deﬁnition 2.1.8 (Reduction Map and Lift). We call the natural reduction map Z → Z/nZ, which sends a to a + nZ, reduction modulo n. We also say that a is a lift of a + nZ. Thus, e.g., 7 is a lift of 1 mod 3, since 7 + 3Z = 1 + 3Z. We can use that arithmetic in Z/nZ is well deﬁned is to derive tests for divisibility by n (see Exercise 2.8). Proposition 2.1.9. A number n ∈ Z is divisible by 3 if and only if the sum of the digits of n is divisible by 3. Proof. Write n = a + 10b + 100c + · · · , where the digits of n are a, b, c, etc. Since 10 ≡ 1 (mod 3), n = a + 10b + 100c + · · · ≡ a + b + c + · · · (mod 3), from which the proposition follows. 2.1.1 Linear Equations Modulo n In this section, we are concerned with how to decide whether or not a linear equation of the form ax ≡ b (mod n) has a solution modulo n. Algorithms for computing solutions to ax ≡ b (mod n) are the topic of Section 2.3. First, we prove a proposition that gives a criterion under which one can cancel a quantity from both sides of a congruence. Proposition 2.1.10 (Cancellation). If gcd(c, n) = 1 and ac ≡ bc (mod n), then a ≡ b (mod n). Proof. By deﬁnition n | ac − bc = (a − b)c. Since gcd(n, c) = 1, it follows from Theorem 1.1.6 that n | a − b, so a ≡ b (mod n), as claimed. 24 2. The Ring of Integers Modulo n When a has a multiplicative inverse a ′ in Z/nZ (i.e., aa ′ ≡ 1 (mod n)) then the equation ax ≡ b (mod n) has a unique solution x ≡ a ′b (mod n). Thus, it is of interest to determine the units in Z/nZ, i.e., the elements which have a multiplicative inverse. We will use complete sets of residues to prove that the units in Z/nZ are exactly the a ∈ Z/nZ such that gcd(˜a, n) = 1 for any lift ˜a of a to Z (it doesn’t matter which lift). Deﬁnition 2.1.11 (Complete Set of Residues). We call a subset R ⊂ Z of size n whose reductions modulo n are pairwise distinct a complete set of residues modulo n. In other words, a complete set of residues is a choice of representative for each equivalence class in Z/nZ. For example, R = {0, 1, 2, . . . , n − 1} is a complete set of residues modulo n. When n = 5, R = {0, 1, −1, 2, −2} is a complete set of residues. Lemma 2.1.12. If R is a complete set of residues modulo n and a ∈ Z with gcd(a, n) = 1, then aR = {ax : x ∈ R} is also a complete set of residues modulo n. Proof. If ax ≡ ax′ (mod n) with x, x ′ ∈ R, then Proposition 2.1.10 implies that x ≡ x′ (mod n). Because R is a complete set of residues, this implies that x = x′. Thus the elements of aR have distinct reductions modulo n. It follows, since #aR = n, that aR is a complete set of residues modulo n. Proposition 2.1.13 (Units). If gcd(a, n) = 1, then the equation ax ≡ b (mod n) has a solution, and that solution is unique modulo n. Proof. Let R be a complete set of residues modulo n, so there is a unique element of R that is congruent to b modulo n. By Lemma 2.1.12, aR is also a complete set of residues modulo n, so there is a unique element ax ∈ aR that is congruent to b modulo n, and we have ax ≡ b (mod n). Algebraically, this proposition asserts that if gcd(a, n) = 1, then the map Z/nZ → Z/nZ given by left multiplication by a is a bijection. Example 2.1.14. Consider the equation 2x ≡ 3 (mod 7), and the complete set R = {0, 1, 2, 3, 4, 5, 6} of coset representatives. We have 2R = {0, 2, 4, 6, 8 ≡ 1, 10 ≡ 3, 12 ≡ 5}, so 2 · 5 ≡ 3 (mod 7). When gcd(a, n) ̸= 1, then the equation ax ≡ b (mod n) may or may not have a solution. For example, 2x ≡ 1 (mod 4) has no solution, but 2x ≡ 2 (mod 4) does, and in fact it has more than one mod 4 (x = 1 and x = 3). Generalizing Proposition 2.1.13, we obtain the following more general criterion for solvability. 2.1 Congruences Modulo n 25 Proposition 2.1.15 (Solvability). The equation ax ≡ b (mod n) has a solution if and only if gcd(a, n) divides b. Proof. Let g = gcd(a, n). If there is a solution x to the equation ax ≡ b (mod n), then n | (ax − b). Since g | n and g | a, it follows that g | b. Conversely, suppose that g | b. Then n | (ax − b) if and only if n g | ( a g x − b g ) . Thus ax ≡ b (mod n) has a solution if and only if a g x ≡ b g (mod n g ) has a solution. Since gcd(a/g, n/g) = 1, Proposition 2.1.13 implies this latter equation does have a solution. In Chapter 4, we will study quadratic reciprocity, which gives a nice criterion for whether or not a quadratic equation modulo n has a solution. 2.1.2 Euler’s Theorem Let (Z/nZ)∗ denote the set of elements [x] ∈ Z/nZ such that gcd(x, n) = 1. The set (Z/nZ) ∗ is a group, called the group of units of the ring Z/nZ; it will be of great interest to us. Each element of this group has an order, and Lagrange’s theorem from group theory implies that each element of (Z/nZ) ∗ has an order that divides the order of (Z/nZ) ∗. In elementary number theory, this fact goes by the monicker “Fermat’s Little Theorem” when n is prime and “Euler’s Theorem” in general, and we reprove it from basic principles in this section. Deﬁnition 2.1.16 (Order of an Element). Let n ∈ N and x ∈ Z and suppose that gcd(x, n) = 1. The order of x modulo n is the smallest m ∈ N such that xm ≡ 1 (mod n). To show that the deﬁnition makes sense, we verify that such an m exists. Consider x, x 2, x 3, . . . modulo n. There are only ﬁnitely many residue classes modulo n, so we must eventually ﬁnd two integers i, j with i < j such that xj ≡ xi (mod n). Since gcd(x, n) = 1, Proposition 2.1.10 implies that we can cancel x’s and conclude that xj−i ≡ 1 (mod n). SAGE Example 2.1.17. Use x.multiplicative order() to compute the order of an element of Z/nZ in Sage. 26 2. The Ring of Integers Modulo n sage: R = Integers(10) sage: a = R(3) # create an element of Z/10Z sage: a.multiplicative_order() 4 Notice that the powers of a are periodic with period 4, i.e., there are four powers and they repeat: sage: [a^i for i in range(15)] [1, 3, 9, 7, 1, 3, 9, 7, 1, 3, 9, 7, 1, 3, 9] The command range(n) we use above returns the list of integers between 0 and n − 1, inclusive. Deﬁnition 2.1.18 (Euler’s ϕ-function). For n ∈ N, let ϕ(n) = #{a ∈ N : a ≤ n and gcd(a, n) = 1}. For example, ϕ(1) = #{1} = 1, ϕ(2) = #{1} = 1, ϕ(5) = #{1, 2, 3, 4} = 4, ϕ(12) = #{1, 5, 7, 11} = 4. Also, if p is any prime number then ϕ(p) = #{1, 2, . . . , p − 1} = p − 1. In Section 2.2.1, we prove that if gcd(m, r) = 1, then ϕ(mr) = ϕ(m)ϕ(r). This will yield an easy way to compute ϕ(n) in terms of the prime factor- ization of n. SAGE Example 2.1.19. Use the euler phi(n) command to compute ϕ(n) in Sage: sage: euler_phi(2007) 1332 Theorem 2.1.20 (Euler’s Theorem). If gcd(x, n) = 1, then xϕ(n) ≡ 1 (mod n). Proof. As mentioned above, Euler’s Theorem has the following group- theoretic interpretation. The set of units in Z/nZ is a group (Z/nZ) ∗ = {a ∈ Z/nZ : gcd(a, n) = 1} that has order ϕ(n). The theorem then asserts that the order of an element of (Z/nZ) ∗ divides the order ϕ(n) of (Z/nZ) ∗. This is a special case of 2.1 Congruences Modulo n 27 the more general fact (Lagrange’s Theorem) that if G is a ﬁnite group and g ∈ G, then the order of g divides the cardinality of G. We now give an elementary proof of the theorem. Let P = {a : 1 ≤ a ≤ n and gcd(a, n) = 1}. In the same way that we proved Lemma 2.1.12, we see that the reductions modulo n of the elements of xP are the same as the reductions of the elements of P . Thus ∏ a∈P (xa) ≡ ∏ a∈P a (mod n), since the products are over the same numbers modulo n. Now cancel the a’s on both sides to get x#P ≡ 1 (mod n), as claimed. SAGE Example 2.1.21. We illustrate Euler’s Theorem using Sage. The Mod(x,n) command returns the equivalence class of x in Z/nZ. sage: n = 20 sage: k = euler_phi(n); k 8 sage: [Mod(x,n)^k for x in range(n) if gcd(x,n) == 1] [1, 1, 1, 1, 1, 1, 1, 1] 2.1.3 Wilson’s Theorem The following characterization of prime numbers, from the 1770s, is called “Wilson’s Theorem,” though it was ﬁrst proved by Lagrange. Proposition 2.1.22 (Wilson’s Theorem). An integer p > 1 is prime if and only if (p − 1)! ≡ −1 (mod p). For example, if p = 3, then (p − 1)! = 2 ≡ −1 (mod 3). If p = 17, then (p − 1)! = 20922789888000 ≡ −1 (mod 17). But if p = 15, then (p − 1)! = 87178291200 ≡ 0 (mod 15), so 15 is composite. Thus Wilson’s theorem could be viewed as a primality test, though, from a computational point of view, it is probably one of the world’s least eﬃcient primality tests since computing (n−1)! takes so many steps. 28 2. The Ring of Integers Modulo n Proof. The statement is clear when p = 2, so henceforth we assume that p > 2. We ﬁrst assume that p is prime and prove that (p − 1)! ≡ −1 (mod p). If a ∈ {1, 2, . . . , p − 1}, then the equation ax ≡ 1 (mod p) has a unique solution a ′ ∈ {1, 2, . . . , p − 1}. If a = a ′, then a 2 ≡ 1 (mod p), so p | a 2 −1 = (a−1)(a+1), so p | (a−1) or p | (a+1), so a ∈ {1, p−1}. We can thus pair oﬀ the elements of {2, 3, . . . , p − 2}, each with their inverse. Thus 2 · 3 · · · · · (p − 2) ≡ 1 (mod p). Multiplying both sides by p − 1 proves that (p − 1)! ≡ −1 (mod p). Next, we assume that (p − 1)! ≡ −1 (mod p) and prove that p must be prime. Suppose not, so that p ≥ 4 is a composite number. Let ℓ be a prime divisor of p. Then ℓ < p, so ℓ | (p − 1)!. Also, by assumption, ℓ | p | ((p − 1)! + 1). This is a contradiction, because a prime can not divide a number a and also divide a + 1, since it would then have to divide (a + 1) − a = 1. Example 2.1.23. We illustrate the key step in the above proof in the case p = 17. We have 2·3 · · · 15 = (2·9)·(3·6)·(4·13)·(5·7)·(8·15)·(10·12)·(14·11) ≡ 1 (mod 17), where we have paired up the numbers a, b for which ab ≡ 1 (mod 17). SAGE Example 2.1.24. We use Sage to create a table of triples; the ﬁrst column contains n, the second column contains (n − 1)! modulo n, and the third contains −1 modulo n. Notice that the ﬁrst columns contains a prime precisely when the second and third columns are equal. (The ... notation indicates a multi-line command in Sage; you should not type the dots in explicitly.) sage: for n in range(1,10): ... print n, factorial(n-1) % n, -1 % n 1 0 0 2 1 1 3 2 2 4 2 3 5 4 4 6 0 5 7 6 6 8 0 7 9 0 8 2.2 The Chinese Remainder Theorem 29 2.2 The Chinese Remainder Theorem In this section, we prove the Chinese Remainder Theorem, which gives conditions under which a system of linear equations is guaranteed to have a solution. In the 4th century a Chinese mathematician asked the following: Question 2.2.1. There is a quantity whose number is unknown. Repeat- edly divided by 3, the remainder is 2; by 5 the remainder is 3; and by 7 the remainder is 2. What is the quantity? In modern notation, Question 2.2.1 asks us to ﬁnd a positive integer solution to the following system of three equations: x ≡ 2 (mod 3) x ≡ 3 (mod 5) x ≡ 2 (mod 7) The Chinese Remainder Theorem asserts that a solution exists, and the proof gives a method to ﬁnd one. (See Section 2.3 for the necessary algo- rithms.) Theorem 2.2.2 (Chinese Remainder Theorem). Let a, b ∈ Z and n, m ∈ N such that gcd(n, m) = 1. Then there exists x ∈ Z such that x ≡ a (mod m), x ≡ b (mod n). Moreover x is unique modulo mn. Proof. If we can solve for t in the equation a + tm ≡ b (mod n), then x = a + tm will satisfy both congruences. To see that we can solve, subtract a from both sides and use Proposition 2.1.13 together with our assumption that gcd(n, m) = 1 to see that there is a solution. For uniqueness, suppose that x and y solve both congruences. Then z = x − y satisﬁes z ≡ 0 (mod m) and z ≡ 0 (mod n), so m | z and n | z. Since gcd(n, m) = 1, it follows that nm | z, so x ≡ y (mod nm). Algorithm 2.2.3 (Chinese Remainder Theorem). Given coprime integers m and n and integers a and b, this algorithm ﬁnd an integer x such that x ≡ a (mod m) and x ≡ b (mod n). 1. [Extended GCD] Use Algorithm 2.3.7 below to ﬁnd integers c, d such that cm + dn = 1. 2. [Answer] Output x = a + (b − a)cm and terminate. 30 2. The Ring of Integers Modulo n Proof. Since c ∈ Z, we have x ≡ a (mod m), and using that cm + dn = 1, we have a + (b − a)cm ≡ a + (b − a) ≡ b (mod n). Now we can answer Question 2.2.1. First, we use Theorem 2.2.2 to ﬁnd a solution to the pair of equations x ≡ 2 (mod 3), x ≡ 3 (mod 5). Set a = 2, b = 3, m = 3, n = 5. Step 1 is to ﬁnd a solution to t · 3 ≡ 3 − 2 (mod 5). A solution is t = 2. Then x = a + tm = 2 + 2 · 3 = 8. Since any x′ with x′ ≡ x (mod 15) is also a solution to those two equations, we can solve all three equations by ﬁnding a solution to the pair of equations x ≡ 8 (mod 15) x ≡ 2 (mod 7). Again, we ﬁnd a solution to t · 15 ≡ 2 − 8 (mod 7). A solution is t = 1, so x = a + tm = 8 + 15 = 23. Note that there are other solutions. Any x′ ≡ x (mod 3 · 5 · 7) is also a solution; e.g., 23 + 3 · 5 · 7 = 128. SAGE Example 2.2.4. The CRT(a,b,m,n) command in Sage computes an integer x such that x ≡ a (mod m) and x ≡ b (mod n). For example, sage: CRT(2,3, 3, 5) -7 The CRT list command computes a number that reduces to several num- bers modulo coprime moduli. We use it to answer Question 2.2.1: sage: CRT_list([2,3,2], [3,5,7]) 23 2.2.1 Multiplicative Functions Recall from Deﬁnition 2.1.18 that the Euler ϕ-function is ϕ(n) = #{a : 1 ≤ a ≤ n and gcd(a, n) = 1}. Lemma 2.2.5. Suppose that m, n ∈ N and gcd(m, n) = 1. Then the map ψ : (Z/mnZ) ∗ → (Z/mZ) ∗ × (Z/nZ)∗. (2.2.1) deﬁned by ψ(c) = (c mod m, c mod n) is a bijection. 2.3 Quickly Computing Inverses and Huge Powers 31 Proof. We ﬁrst show that ψ is injective. If ψ(c) = ψ(c′), then m | c − c ′ and n | c − c ′, so nm | c − c ′ because gcd(n, m) = 1. Thus c = c ′ as elements of (Z/mnZ)∗. Next we show that ψ is surjective, i.e., that every element of (Z/mZ) ∗ × (Z/nZ) ∗ is of the form ψ(c) for some c. Given a and b with gcd(a, m) = 1 and gcd(b, n) = 1, Theorem 2.2.2 implies that there exists c with c ≡ a (mod m) and c ≡ b (mod n). We may assume that 1 ≤ c ≤ nm, and since gcd(a, m) = 1 and gcd(b, n) = 1, we must have gcd(c, nm) = 1. Thus ψ(c) = (a, b). Deﬁnition 2.2.6 (Multiplicative Function). A function f : N → C is multiplicative if, whenever m, n ∈ N and gcd(m, n) = 1, we have f (mn) = f (m) · f (n). Proposition 2.2.7 (Multiplicativity of ϕ). The function ϕ is multiplica- tive. Proof. The map ψ of Lemma 2.2.5 is a bijection, so the set on the left in (2.2.1) has the same size as the product set on the right in (2.2.1). Thus ϕ(mn) = ϕ(m) · ϕ(n). The proposition is helpful in computing ϕ(n), at least if we assume we can compute the factorization of n (see Section 3.4.1 for a connection between factoring n and computing ϕ(n)). For example, ϕ(12) = ϕ(22) · ϕ(3) = 2 · 2 = 4. Also, for n ≥ 1, we have ϕ(pn) = p n − p n p = pn − pn−1 = p n−1(p − 1), (2.2.2) since ϕ(p n) is the number of numbers less than pn minus the number of those that are divisible by p. Thus, e.g., ϕ(389 · 112) = 388 · (11 2 − 11) = 388 · 110 = 42680. 2.3 Quickly Computing Inverses and Huge Powers This section is about how to solve the equation ax ≡ 1 (mod n) when we know it has a solution, and how to eﬃciently compute a m (mod n). We also discuss a simple probabilistic primality test that relies on our ability to compute a m (mod n) quickly. All three of these algorithms are of fundamental importance to the cryptography algorithms of Chapter 3. 32 2. The Ring of Integers Modulo n 2.3.1 How to Solve ax ≡ 1 (mod n) Suppose a, n ∈ N with gcd(a, n) = 1. Then by Proposition 2.1.13 the equation ax ≡ 1 (mod n) has a unique solution. How can we ﬁnd it? Proposition 2.3.1 (Extended Euclidean Representation). Suppose a, b ∈ Z and let g = gcd(a, b). Then there exists x, y ∈ Z such that ax + by = g. Remark 2.3.2. If e = cg is a multiple of g, then cax + cby = cg = e, so e = (cx)a + (cy)b can also be written in terms of a and b. Proof of Proposition 2.3.1. Let g = gcd(a, b). Then gcd(a/g, b/g) = 1, so by Proposition 2.1.15, the equation a g · x ≡ 1 ( mod b g ) (2.3.1) has a solution x ∈ Z. Multiplying (2.3.1) through by g yields ax ≡ g (mod b), so there exists y such that b · (−y) = ax − g. Then ax + by = g, as required. Given a, b and g = gcd(a, b), our proof of Proposition 2.3.1 gives a way to explicitly ﬁnd x, y such that ax + by = g, assuming one knows an algorithm to solve linear equations modulo n. Since we do not know such an algorithm, we now discuss a way to explicitly ﬁnd x and y. This algorithm will in fact enable us to solve linear equations modulo n. To solve ax ≡ 1 (mod n) when gcd(a, n) = 1, use the Algorithm 2.3.7 to ﬁnd x and y such that ax + ny = 1. Then ax ≡ 1 (mod n). Example 2.3.3. Suppose a = 5 and b = 7. The steps of Algorithm 1.1.13 to compute gcd(5, 7) are as follows. Here we underline certain numbers, because it clariﬁes the subsequent back substitution we will use to ﬁnd x and y. 7 = 1 · 5 + 2 so 2 = 7 − 5 5 = 2 · 2 + 1 so 1 = 5 − 2 · 2 = 5 − 2(7 − 5) = 3 · 5 − 2 · 7 On the right, we have back-substituted in order to write each partial re- mainder as a linear combination of a and b. In the last step, we obtain gcd(a, b) as a linear combination of a and b, as desired. Example 2.3.4. That example was not too complicated, so we try another one. Let a = 130 and b = 61. We have 130 = 2 · 61 + 8 8 = 130 − 2 · 61 61 = 7 · 8 + 5 5 = −7 · 130 + 15 · 61 8 = 1 · 5 + 3 3 = 8 · 130 − 17 · 61 5 = 1 · 3 + 2 2 = −15 · 130 + 32 · 61 3 = 1 · 2 + 1 1 = 23 · 130 − 49 · 61 2.3 Quickly Computing Inverses and Huge Powers 33 Thus x = 23 and y = −49 is a solution to 130x + 61y = 1. Example 2.3.5. This example is just like Example 2.3.4 above, except we make the notation on the right more compact. 130 = 2 · 61 + 8 8 = (1, −2) 61 = 7 · 8 + 5 5 = (−7, 15) = (0, 1) − 7(1, −2) 8 = 1 · 5 + 3 3 = (8, −17) = (1, −2) − (−7, 15) 5 = 1 · 3 + 2 2 = (−15, 32) = (−7, 15) − (8, −17) 3 = 1 · 2 + 1 1 = (23, −49) = (8, −17) − (−15, 32) Notice at each step that the vector on the right is just the vector from two steps ago minus a multiple of the vector from one step ago, where the multiple is the coﬃcient of what we divide by. SAGE Example 2.3.6. The xgcd(a,b) command computes the greatest common divisor g of a and b along with x, y such that ax + by = g. sage: xgcd(5,7) (1, -4, 3) sage: xgcd(130,61) (1, 23, -49) Algorithm 2.3.7 (Extended Euclidean Algorithm). Suppose a and b are integers and let g = gcd(a, b). This algorithm ﬁnds g, x and y such that ax + by = g. We describe only the steps when a > b ≥ 0, since one can easily reduce to this case. 1. [Initialize] Set x = 1, y = 0, r = 0, s = 1. 2. [Finished?] If b = 0, set g = a and terminate. 3. [Quotient and Remainder] Use Algorithm 1.1.12 to write a = qb + c with 0 ≤ c < b. 4. [Shift] Set (a, b, r, s, x, y) = (b, c, x − qr, y − qs, r, s) and go to Step 2. (This shift step is nicely illustrated in Example 2.3.5.) Proof. This algorithm is the same as Algorithm 1.1.13, except that we keep track of extra variables x, y, r, s, so it terminates and when it terminates d = gcd(a, b). We omit the rest of the inductive proof that the algorithm is correct, and instead refer the reader to [Knu97, §1.2.1]. Algorithm 2.3.8 (Inverse Modulo n). Suppose a and n are integers and gcd(a, n) = 1. This algorithm ﬁnds an x such that ax ≡ 1 (mod n). 1. [Compute Extended GCD] Use Algorithm 2.3.7 to compute integers x, y such that ax + ny = gcd(a, n) = 1. 2. [Finished] Output x. 34 2. The Ring of Integers Modulo n Proof. Reduce ax+ny = 1 modulo n to see that x satisﬁes ax ≡ 1 (mod n). Example 2.3.9. Solve 17x ≡ 1 (mod 61). First, we use Algorithm 2.3.7 to ﬁnd x, y such that 17x + 61y = 1: 61 = 3 · 17 + 10 10 = 61 − 3 · 17 17 = 1 · 10 + 7 7 = −61 + 4 · 17 10 = 1 · 7 + 3 3 = 2 · 61 − 7 · 17 3 = 2 · 3 + 1 1 = −5 · 61 + 18 · 17 Thus 17 · 18 + 61 · (−5) = 1 so x = 18 is a solution to 17x ≡ 1 (mod 61). SAGE Example 2.3.10. Sage implements the above algorithm for quickly computing inverses modulo n. For example, sage: a = Mod(17, 61) sage: a^(-1) 18 2.3.2 How to Compute am (mod n) Let a and n be integers, and m a nonnegative integer. In this section, we de- scribe an eﬃcient algorithm to compute a m (mod n). For the cryptography applications in Chapter 3, m will have hundreds of digits. The naive approach to computing a m (mod n) is to simply compute am = a · a · · · a (mod n) by repeatedly multiplying by a and reducing mod- ulo m. Note that after each arithmetic operation is completed, we reduce the result modulo n so that the sizes of the numbers involved do not get too large. Nonetheless, this algorithm is horribly ineﬃcient because it takes m − 1 multiplications, which is huge if m has hundreds of digits. A much more eﬃcient algorithm for computing a m (mod n) involves writing m in binary, then expressing a m as a product of expressions a 2 i, for various i. These latter expressions can be computed by repeatedly squaring a 2i. This more clever algorithm is not “simpler,” but it is vastly more eﬃcient since the number of operations needed grows with the number of binary digits of m, whereas with the naive algorithm in the previous paragraph, the number of operations is m − 1. Algorithm 2.3.11 (Write a number in binary). Let m be a nonnegative integer. This algorithm writes m in binary, so it ﬁnds εi ∈ {0, 1} such that m = ∑r i=0 εi2i with each εi ∈ {0, 1}. 1. [Initialize] Set i = 0. 2. [Finished?] If m = 0, terminate. 3. [Digit] If m is odd, set εi = 1, otherwise εi = 0. Increment i. 2.3 Quickly Computing Inverses and Huge Powers 35 4. [Divide by 2] Set m = ⌊ m 2 ⌋ , the greatest integer ≤ m/2. Goto Step 2. SAGE Example 2.3.12. To write a number in binary using Sage, use the str command: sage: 100.str(2) ’1100100’ Notice the above is the correct binary expansion: sage: 0*2^0 + 0*2^1 + 1*2^2 + 0*2^3 + 0*2^4 + 1*2^5 + 1*2^6 100 Algorithm 2.3.13 (Compute Power). Let a and n be integers and m a nonnegative integer. This algorithm computes a m modulo n. 1. [Write in Binary] Write m in binary using Algorithm 2.3.11, so a m = ∏ εi=1 a 2 i (mod n). 2. [Compute Powers] Compute a, a 2, a 2 2 = (a2) 2, a 2 3 = (a 22) 2, etc., up to a 2 r , where r + 1 is the number of binary digits of m. 3. [Multiply Powers] Multiply together the a 2 i such that εi = 1, always working modulo n. Example 2.3.14. We can compute the last 2 digits of 791, by ﬁnding 7 91 (mod 100). First, because gcd(7, 100) = 1, we have by Theorem 2.1.20 that 7ϕ(100) ≡ 1 (mod 100). Because ϕ is multiplicative, ϕ(100) = ϕ(2 2 · 5 2) = (22 − 2) · (5 2 − 5) = 40. Thus 7 40 ≡ 1 (mod 100), hence 7 91 ≡ 7 40+40+11 ≡ 7 11 (mod 100). We now compute 7 11 (mod 100) using the above algorithm. First, write 11 in binary by repeatedly dividing by 2. 11 = 5 · 2 + 1 5 = 2 · 2 + 1 2 = 1 · 2 + 0 1 = 0 · 2 + 1 So in binary, (11)2 = 1011, which we check: 11 = 1 · 8 + 1 · 2 + 1. 36 2. The Ring of Integers Modulo n Next, compute a, a 2, a 4, a 8 and output a 8 · a 2 · a. We have a = 7 a 2 ≡ 49 a 4 ≡ 492 ≡ 1 a 8 ≡ 12 ≡ 1 Note: it is easiest to square 49 by working modulo 4 and 25 and using the Chinese Remainder Theorem. Finally, 791 ≡ 7 11 ≡ a 8 · a 2 · a ≡ 1 · 49 · 7 ≡ 43 (mod 100). SAGE Example 2.3.15. Sage implements the above algorithm for comput- ing powers eﬃciently. For example, sage: Mod(7,100)^91 43 We can also, of course, directly compute 791 in Sage, though we would not want to do this by hand: sage: 7^91 80153343160247310515380886994816022539378033762994852 007501964604841680190743 2.4 Primality Testing Theorem 2.4.1 (Pseudoprimality). An integer p > 1 is prime if and only if for every a ̸≡ 0 (mod p), a p−1 ≡ 1 (mod p). Proof. If p is prime, then the statement follows from Proposition 2.1.22. If p is composite, then there is a divisor a of p with 2 ≤ a < p. If a p−1 ≡ 1 (mod p), then p | a p−1 − 1. Since a | p, we have a | a p−1 − 1, hence there exists an integer k such that ak = a p−1 − 1. Subtracting, we see that a p−1 − ak = 1, so a(a p−2 − k) = 1. This implies that a | 1, which is a contradiction since a ≥ 2. Suppose n ∈ N. Using Theorem 2.4.1 and Algorithm 2.3.13, we can either quickly prove that n is not prime, or convince ourselves that n is likely prime (but not quickly prove that n is prime). For example, if 2 n−1 ̸≡ 1 (mod n), then we have proved that n is not prime. On the other hand, if a n−1 ≡ 1 (mod n) for a few a, it “seems likely” that n is prime, and we loosely refer to such a number that seems prime for several bases as a pseudoprime. 2.4 Primality Testing 37 There are composite numbers n (called Carmichael numbers) with the amazing property that a n−1 ≡ 1 (mod n) for all a with gcd(a, n) = 1. The ﬁrst Carmichael number is 561, and it is a theorem that there are inﬁnitely many such numbers ([AGP94]). Example 2.4.2. Is p = 323 prime? We compute 2322 (mod 323). Making a table as above, we have i m εi 22 i mod 323 0 322 0 2 1 161 1 4 2 80 0 16 3 40 0 256 4 20 0 290 5 10 0 120 6 5 1 188 7 2 0 137 8 1 1 35 Thus 2 322 ≡ 4 · 188 · 35 ≡ 157 (mod 323), so 323 is not prime, though this computation gives no information about how 323 factors as a product of primes. In fact, one ﬁnds that 323 = 17 · 19. SAGE Example 2.4.3. It’s possible to easily prove that a large number is composite, but the proof does not easily yield a factorization. For example if n = 95468093486093450983409583409850934850938459083, then 2n−1 ̸≡ 1 (mod n), so n is composite. sage: n = 95468093486093450983409583409850934850938459083 sage: Mod(2,n)^(n-1) 34173444139265553870830266378598407069248687241 Note that factoring n actually takes much longer than the above computa- tion (which was essentially instant). sage: factor(n) # takes up to a few seconds. 1610302526747 * 59285812386415488446397191791023889 Another practical primality test is the Miller-Rabin test, which has the property that each time it is run on a number n it either correctly asserts that the number is deﬁnitely not prime, or that it is probably prime, and the probability of correctness goes up with each successive call. If Miller- Rabin is called m times on n and in each case claims that n is probably prime, then one can in a precise sense bound the probability that n is composite in terms of m. 38 2. The Ring of Integers Modulo n We state the Miller-Rabin algorithm precisely, but do not prove anything about the probability that it will succeed. Algorithm 2.4.4 (Miller-Rabin Primality Test). Given an integer n ≥ 5 this algorithm outputs either true or false. If it outputs true, then n is “probably prime,” and if it outputs false, then n is deﬁnitely composite. 1. [Split Oﬀ Power of 2] Compute the unique integers m and k such that m is odd and n − 1 = 2 k · m. 2. [Random Base] Choose a random integer a with 1 < a < n. 3. [Odd Power] Set b = a m (mod n). If b ≡ ±1 (mod n) output true and terminate. 4. [Even Powers] If b2 r ≡ −1 (mod n) for any r with 1 ≤ r ≤ k − 1, output true and terminate. Otherwise output false. If Miller-Rabin outputs true for n, we can call it again with n and if it again outputs true then the probability that we have incorrectly determined that n is prime (when n is actually composite) decreases. Proof. We will prove that the algorithm is correct, but will prove nothing about how likely the algorithm is to assert that a composite is prime. We must prove that if the algorithm pronounces an integer n composite, then n really is composite. Thus suppose n is prime, yet the algorithm pronounces n composite. Then a m ̸≡ ±1 (mod n), and for all r with 1 ≤ r ≤ k − 1 we have a 2rm ̸≡ −1 (mod n). Since n is prime and 2k−1m = (n − 1)/2, Proposition 4.2.1 implies that a 2k−1m ≡ ±1 (mod n), so by our hypothesis a 2k−1m ≡ 1 (mod n). But then (a 2k−2m) 2 ≡ 1 (mod n), so by Proposition 2.5.3 (which is proved right after it is stated, and whose proof does not depend on this argument), we have a 2 k−2m ≡ ±1 (mod n). Again, by our hypothesis, this implies a 2 k−2m ≡ 1 (mod n). Repeating this argument inductively, we see that a m ≡ ±1 (mod n), which contradicts our hypothesis on a. Until recently it was an open problem to give an algorithm (with proof) that decides whether or not any integer is prime in time bounded by a poly- nomial in the number of digits of the integer. Agrawal, Kayal, and Saxena recently found the ﬁrst polynomial-time primality test (see [AKS02]). We will not discuss their algorithm further, because for our applications to cryptography Miller-Rabin or pseudoprimality tests will be suﬃcient. See [Sho05, Ch. 21] for a book that gives a detailed exposition of this algorithm. SAGE Example 2.4.5. The is prime command uses a combination of tech- niques to determine (provably correctly!) whether or not an integer is prime. sage: n = 95468093486093450983409583409850934850938459083 sage: is_prime(n) False 2.5 The Structure of (Z/pZ)∗ 39 We use the is prime function to make a table of the ﬁrst few Mersenne primes (see Section 1.2.3). sage: for p in primes(100): ... if is_prime(2^p - 1): ... print p, 2^p - 1 2 3 3 7 5 31 7 127 13 8191 17 131071 19 524287 31 2147483647 61 2305843009213693951 89 618970019642690137449562111 There is a specialized test for primality of Mersenne numbers called the Lucas-Lehmer test. This remarkably simple algorithm determines provably correctly whether or not a number 2 p − 1 is prime. We implement it in a few lines of code and use the Lucas-Lehmer test to check for primality of two Mersenne numbers: sage: def is_prime_lucas_lehmer(p): ... s = Mod(4, 2^p - 1) ... for i in range(3, p+1): ... s = s^2 - 2 ... return s == 0 sage: # Check primality of 2^9941 - 1 sage: is_prime_lucas_lehmer(9941) True sage: # Check primality of 2^next_prime(1000)-1 sage: is_prime_lucas_lehmer(next_prime(1000)) False For more on Mersenne primes, see the Great Internet Mersenne Prime Search (GIMPS) project at http://www.mersenne.org/. 2.5 The Structure of (Z/pZ) ∗ This section is about the structure of the group (Z/pZ) ∗ of units modulo a prime number p. The main result is that this group is always cyclic. We will use this result later in Chapter 4 in our proof of quadratic reciprocity. Deﬁnition 2.5.1 (Primitive root). A primitive root modulo an integer n is an element of (Z/nZ) ∗ of order ϕ(n). 40 2. The Ring of Integers Modulo n We will prove that there is a primitive root modulo every prime p. Since the unit group (Z/pZ) ∗ has order p−1, this implies that (Z/pZ)∗ is a cyclic group, a fact that will be extremely useful, since it completely determines the structure of (Z/pZ)∗ as a group. If n is an odd prime power, then there is a primitive root modulo n (see Exercise 2.28), but there is no primitive root modulo the prime power 23, and hence none mod 2n for n ≥ 3 (see Exercise 2.27). Section 2.5.1 is the key input to our proof that (Z/pZ) ∗ is cyclic; here we show that for every divisor d of p − 1 there are exactly d elements of (Z/pZ)∗ whose order divides d. We then use this result in Section 2.5.2 to produce an element of (Z/pZ) ∗ of order qr when qr is a prime power that exactly divides p − 1 (i.e., qr divides p − 1, but qr+1 does not divide p − 1), and multiply together these elements to obtain an element of (Z/pZ)∗ of order p − 1. SAGE Example 2.5.2. Use the primitive root command to compute the smallest positive integer that is a primitive root modulo n. For example, below we compute primitive roots modulo p for each prime p < 20. sage: for p in primes(20): ... print p, primitive_root(p) 2 1 3 2 5 2 7 3 11 2 13 2 17 3 19 2 2.5.1 Polynomials over Z/pZ The polynomials x2 − 1 has four roots in Z/8Z, namely 1, 3, 5, and 7. In contrast, the following proposition shows that a polynomial of degree d over a ﬁeld, such as Z/pZ, can have at most d roots. Proposition 2.5.3 (Root Bound). Let f ∈ k[x] be a nonzero polynomial over a ﬁeld k. Then there are at most deg(f ) elements α ∈ k such that f (α) = 0. 2.5 The Structure of (Z/pZ)∗ 41 Proof. We prove the proposition by induction on deg(f ). The cases in which deg(f ) ≤ 1 are clear. Write f = anxn + · · · a1x + a0. If f (α) = 0, then f (x) = f (x) − f (α) = an(x n − αn) + · · · + a1(x − α) + a0(1 − 1) = (x − α)(an(xn−1 + · · · + αn−1) + · · · + a2(x + α) + a1) = (x − α)g(x), for some polynomial g(x) ∈ k[x]. Next, suppose that f (β) = 0 with β ̸= α. Then (β −α)g(β) = 0, so, since β −α ̸= 0 and k is a ﬁeld, we have g(β) = 0. By our inductive hypothesis, g has at most n − 1 roots, so there are at most n − 1 possibilities for β. It follows that f has at most n roots. SAGE Example 2.5.4. We use Sage to ﬁnd the roots of a polynomials over Z/13Z. sage: R.<x> = PolynomialRing(Integers(13)) sage: f = x^15 + 1 sage: f.roots() [(12, 1), (10, 1), (4, 1)] sage: f(12) 0 The output of the roots command above lists each root along with its multiplicity (which is 1 in each case above). Proposition 2.5.5. Let p be a prime number and let d be a divisor of p − 1. Then f = xd − 1 ∈ (Z/pZ)[x] has exactly d roots in Z/pZ. Proof. Let e = (p − 1)/d. We have xp−1 − 1 = (xd) e − 1 = (xd − 1)((xd) e−1 + (xd)e−2 + · · · + 1) = (xd − 1)g(x), where g ∈ (Z/pZ)[x] and deg(g) = de − d = p − 1 − d. Theorem 2.1.20 implies that xp−1 − 1 has exactly p − 1 roots in Z/pZ, since every nonzero element of Z/pZ is a root! By Proposition 2.5.3, g has at most p − 1 − d roots and x d − 1 has at most d roots. Since a root of (xd − 1)g(x) is a root of either xd − 1 or g(x) and xp−1 − 1 has p − 1 roots, g must have exactly p − 1 − d roots and xd − 1 must have exactly d roots, as claimed. SAGE Example 2.5.6. We use Sage to illustrate the proposition. sage: R.<x> = PolynomialRing(Integers(13)) sage: f = x^6 + 1 sage: f.roots() [(11, 1), (8, 1), (7, 1), (6, 1), (5, 1), (2, 1)] 42 2. The Ring of Integers Modulo n We pause to reemphasize that the analog of Proposition 2.5.5 is false when p is replaced by a composite integer n, since a root mod n of a product of two polynomials need not be a root of either factor. For example, f = x2 − 1 = (x − 1)(x + 1) ∈ Z/15Z[x] has the four roots 1, 4, 11, and 14. 2.5.2 Existence of Primitive Roots Recall from Section 2.1.2 that the order of an element x in a ﬁnite group is the smallest m ≥ 1 such that xm = 1. In this section, we prove that (Z/pZ)∗ is cyclic by using the results of Section 2.5.1 to produce an element of (Z/pZ) ∗ of order d for each prime power divisor d of p − 1, and then we multiply these together to obtain an element of order p − 1. We will use the following lemma to assemble elements of each order dividing p − 1 to produce an element of order p − 1. Lemma 2.5.7. Suppose a, b ∈ (Z/nZ)∗ have orders r and s, respectively, and that gcd(r, s) = 1. Then ab has order rs. Proof. This is a general fact about commuting elements of any group; our proof only uses that ab = ba and nothing special about (Z/nZ)∗. Since (ab) rs = a rsbrs = 1, the order of ab is a divisor of rs. Write this divisor as r1s1 where r1 | r and s1 | s. Raise both sides of the equation a r1s1br1s1 = (ab)r1s1 = 1 to the power r2 = r/r1 to obtain a r1r2s1br1r2s1 = 1. Since a r1r2s1 = (a r1r2)s1 = 1, we have b r1r2s1 = 1, so s | r1r2s1. Since gcd(s, r1r2) = gcd(s, r) = 1, it follows that s = s1. Similarly r = r1, so the order of ab is rs. Theorem 2.5.8 (Primitive Roots). There is a primitive root modulo any prime p. In particular, the group (Z/pZ)∗ is cyclic. Proof. The theorem is true if p = 2, since 1 is a primitive root, so we may assume p > 2. Write p − 1 as a product of distinct prime powers qni i : p − 1 = qn1 1 qn2 2 · · · qnr r . By Proposition 2.5.5, the polynomial xqni i − 1 has exactly qni i roots, and the polynomial xqni−1 i − 1 has exactly qni−1 i roots. There are qni i − qni−1 i = 2.5 The Structure of (Z/pZ)∗ 43 qni−1 i (qi − 1) elements a ∈ Z/pZ such that aqni i = 1 but aqni−1 i ̸= 1; each of these elements has order qni i . Thus for each i = 1, . . . , r, we can choose an ai of order qni i . Then, using Lemma 2.5.7 repeatedly, we see that a = a1a2 · · · ar has order qn1 1 · · · qnr r = p − 1, so a is a primitive root modulo p. Example 2.5.9. We illustrate the proof of Theorem 2.5.8 when p = 13. We have p − 1 = 12 = 22 · 3. The polynomial x4 − 1 has roots {1, 5, 8, 12} and x2 − 1 has roots {1, 12}, so we may take a1 = 5. The polynomial x3 − 1 has roots {1, 3, 9}, and we set a2 = 3. Then a = 5 · 3 = 15 ≡ 2 is a primitive root. To verify this, note that the successive powers of 2 (mod 13) are 2, 4, 8, 3, 6, 12, 11, 9, 5, 10, 7, 1. Example 2.5.10. Theorem 2.5.8 is false if, for example, p is replaced by a power of 2 bigger than 4. For example, the four elements of (Z/8Z) ∗ each have order dividing 2, but ϕ(8) = 4. Theorem 2.5.11 (Primitive Roots mod p n). Let p n be a power of an odd prime. Then there is a primitive root modulo p n. The proof is left as Exercise 2.28. Proposition 2.5.12 (Number of primitive roots). If there is a primitive root modulo n, then there are exactly ϕ(ϕ(n)) primitive roots modulo n. Proof. The primitive roots modulo n are the generators of (Z/nZ) ∗, which by assumption is cyclic of order ϕ(n). Thus they are in bijection with the generators of any cyclic group of order ϕ(n). In particular, the number of primitive roots modulo n is the same as the number of elements of Z/ϕ(n)Z with additive order ϕ(n). An element of Z/ϕ(n)Z has additive order ϕ(n) if and only if it is coprime to ϕ(n). There are ϕ(ϕ(n)) such elements, as claimed. Example 2.5.13. For example, there are ϕ(ϕ(17)) = ϕ(16) = 24 − 23 = 8 primitive roots mod 17, namely 3, 5, 6, 7, 10, 11, 12, 14. The ϕ(ϕ(9)) = ϕ(6) = 2 primitive roots modulo 9 are 2 and 5. There are no primitive roots modulo 8, even though ϕ(ϕ(8)) = ϕ(4) = 2 > 0. 2.5.3 Artin’s Conjecture Conjecture 2.5.14 (Emil Artin). Suppose a ∈ Z is not −1 or a perfect square. Then there are inﬁnitely many primes p such that a is a primitive root modulo p. 44 2. The Ring of Integers Modulo n There is no single integer a such that Artin’s conjecture is known to be true. For any given a, Pieter [Mor93] proved that there are inﬁnitely many p such that the order of a is divisible by the largest prime factor of p − 1. Hooley [Hoo67] proved that something called the Generalized Riemann Hypothesis implies Conjecture 2.5.14. Remark 2.5.15. Artin conjectured more precisely that if N (x, a) is the number of primes p ≤ x such that a is a primitive root modulo p, then N (x, a) is asymptotic to C(a)π(x), where C(a) is a positive constant that depends only on a and π(x) is the number of primes up to x. 2.5.4 Computing Primitive Roots Theorem 2.5.8 does not suggest an eﬃcient algorithm for ﬁnding primitive roots. To actually ﬁnd a primitive root mod p in practice, we try a = 2, then a = 3, etc., until we ﬁnd an a that has order p − 1. Computing the order of an element of (Z/pZ)∗ requires factoring p − 1, which we do not know how to do quickly in general, so ﬁnding a primitive root modulo p for large p seems to be a diﬃcult problem. Algorithm 2.5.16 (Primitive Root). Given a prime p, this algorithm com- putes the smallest positive integer a that generates (Z/pZ) ∗. 1. [p = 2?] If p = 2 output 1 and terminate. Otherwise set a = 2. 2. [Prime Divisors] Compute the prime divisors p1, . . . , pr of p − 1. 3. [Generator?] If for every pi, we have a (p−1)/pi ̸≡ 1 (mod p), then a is a generator of (Z/pZ) ∗, so output a and terminate. 4. [Try next] Set a = a + 1 and go to Step 3. Proof. Let a ∈ (Z/pZ) ∗. The order of a is a divisor d of the order p − 1 of the group (Z/pZ)∗. Write d = (p − 1)/n, for some divisor n of p − 1. If a is not a generator of (Z/pZ)∗, then since n | (p − 1), there is a prime divisor pi of p − 1 such that pi | n. Then a (p−1)/pi = (a (p−1)/n) n/pi ≡ 1 (mod p). Conversely, if a is a generator, then a (p−1)/pi ̸≡ 1 (mod p) for any pi. Thus the algorithm terminates with Step 3 if and only if the a under consideration is a primitive root. By Theorem 2.5.8, there is at least one primitive root, so the algorithm terminates. 2.6 Exercises 2.1 Prove that for any positive integer n, the set (Z/nZ) ∗ under multi- plication modulo n is a group. 2.6 Exercises 45 2.2 Compute the following gcd’s using Algorithm 1.1.13: gcd(15, 35) gcd(247, 299) gcd(51, 897) gcd(136, 304) 2.3 Use Algorithm 2.3.7 to ﬁnd x, y ∈ Z such that 2261x + 1275y = 17. 2.4 Prove that if a and b are integers and p is a prime, then (a + b)p ≡ a p + b p (mod p). You may assume that the binomial coeﬃcient p! r!(p − r)! is an integer. 2.5 (a) Prove that if x, y is a solution to ax + by = d, with d = gcd(a, b), then for all c ∈ Z, x′ = x + c · b d , y′ = y − c · a d (2.6.1) is also a solution to ax + by = d. (b) Find two distinct solutions to 2261x + 1275y = 17. (c) Prove that all solutions are of the form (2.6.1) for some c. 2.6 Let f (x) = x2 + ax + b ∈ Z[x] be a quadratic polynomial with integer coeﬃcients, for example, f (x) = x2 + x + 6. Formulate a conjecture about when the set {f (n) : n ∈ Z and f (n) is prime} is inﬁnite. Give numerical evidence that supports your conjecture. 2.7 Find four complete sets of residues modulo 7, where the ith set sat- isﬁes the ith condition: (1) nonnegative, (2) odd, (3) even, (4) prime. 2.8 Find rules in the spirit of Proposition 2.1.9 for divisibility of an integer by 5, 9, and 11, and prove each of these rules using arithmetic modulo a suitable n. 2.9 (*) (The following problem is from the 1998 Putnam Competition.) Deﬁne a sequence of decimal integers an as follows: a1 = 0, a2 = 1, and an+2 is obtained by writing the digits of an+1 immediately followed by those of an. For example, a3 = 10, a4 = 101, and a5 = 10110. Determine the n such that an is a multiple of 11, as follows: (a) Find the smallest integer n > 1 such that an is divisible by 11. (b) Prove that an is divisible by 11 if and only if n ≡ 1 (mod 6). 2.10 Find an integer x such that 37x ≡ 1 (mod 101). 46 2. The Ring of Integers Modulo n 2.11 What is the order of 2 modulo 17? 2.12 Let p be a prime. Prove that Z/pZ is a ﬁeld. 2.13 Find an x ∈ Z such that x ≡ −4 (mod 17) and x ≡ 3 (mod 23). 2.14 Prove that if n > 4 is composite then (n − 1)! ≡ 0 (mod n). 2.15 For what values of n is ϕ(n) odd? 2.16 (a) Prove that ϕ is multiplicative as follows. Suppose m, n are pos- itive integers and gcd(m, n) = 1. Show that the natural map ψ : Z/mnZ → Z/mZ × Z/nZ is an injective homomorphism of rings, hence bijective by counting, then look at unit groups. (b) Prove conversely that if gcd(m, n) > 1, then the natural map ψ : Z/mnZ → Z/mZ × Z/nZ is not an isomorphism. 2.17 Seven competitive math students try to share a huge hoard of stolen math books equally between themselves. Unfortunately, six books are left over, and in the ﬁght over them, one math student is expelled. The remaining six math students, still unable to share the math books equally since two are left over, again ﬁght, and another is expelled. When the remaining ﬁve share the books, one book is left over, and it is only after yet another math student is expelled that an equal sharing is possible. What is the minimum number of books that allows this to happen? 2.18 Show that if p is a positive integer such that both p and p2 + 2 are prime, then p = 3. 2.19 Let ϕ : N → N be the Euler ϕ function. (a) Find all natural numbers n such that ϕ(n) = 1. (b) Do there exist natural numbers m and n such that ϕ(mn) ̸= ϕ(m) · ϕ(n)? 2.20 Find a formula for ϕ(n) directly in terms of the prime factorization of n. 2.21 (a) Prove that if ϕ : G → H is a group homomorphism, then ker(ϕ) is a subgroup of G. (b) Prove that ker(ϕ) is normal, i.e., if a ∈ G and b ∈ ker(ϕ), then a −1ba ∈ ker(ϕ). 2.22 Is the set Z/5Z = {0, 1, 2, 3, 4} with binary operation multiplication modulo 5 a group? 2.6 Exercises 47 2.23 Find all four solutions to the equation x2 − 1 ≡ 0 (mod 35). 2.24 Prove that for any positive integer n the fraction (12n + 1)/(30n + 2) is in reduced form. 2.25 Suppose a and b are positive integers. (a) Prove that gcd(2a − 1, 2 b − 1) = 2gcd(a,b) − 1. (b) Does it matter if 2 is replaced by an arbitrary prime p? (c) What if 2 is replaced by an arbitrary positive integer n? 2.26 For every positive integer b, show that there exists a positive integer n such that the polynomial x2 − 1 ∈ (Z/nZ)[x] has at least b roots. 2.27 (a) Prove that there is no primitive root modulo 2 n for any n ≥ 3. (b) (*) Prove that (Z/2 nZ)∗ is generated by −1 and 5. 2.28 Let p be an odd prime. (a) (*) Prove that there is a primitive root modulo p2. (Hint: Use that if a, b have orders n, m, with gcd(n, m) = 1, then ab has order nm.) (b) Prove that for any n, there is a primitive root modulo pn. (c) Explicitly ﬁnd a primitive root modulo 125. 2.29 (*) In terms of the prime factorization of n, characterize the integers n such that there is a primitive root modulo n. 2.30 Compute the last two digits of 345. 2.31 Find the integer a such that 0 ≤ a < 113 and 10270 + 1 ≡ a 37 (mod 113). 2.32 Find the proportion of primes p < 1000 such that 2 is a primitive root modulo p. 2.33 Find a prime p such that the smallest primitive root modulo p is 37. 48 2. The Ring of Integers Modulo n This is page 49 Printer: Opaque this 3 Public-key Cryptography In the 1970s, techniques from number theory changed the world forever by providing, for the ﬁrst time ever, a way for two people to communicate secret messages under the assumption that all of their communication is intercepted and read by an adversary. This idea has stood the test of time. In fact, whenever you buy something online, you use such a system, which typically involves working in the ring of integers modulo n. This chapter tells the story of several such systems. 3.1 Playing with Fire I recently watched a TV show called La Femme Nikita about a woman named Nikita who is forced to be an agent for a shady anti-terrorist or- ganization called Section One. Nikita has strong feelings for fellow agent Michael, and she most trusts Walter, Section One’s ex-biker gadgets and ex- plosives expert. Often Nikita’s worst enemies are her superiors and cowork- ers at Section One. A synopsis for a Season Three episode is as follows: PLAYING WITH FIRE On a mission to secure detonation chips from a terrorist or- ganization’s heavily armed base camp, Nikita is captured as a hostage by the enemy. Or so it is made to look. Michael and Nikita have actually created the scenario in order to secretly rendezvous with each other. The ruse works, but when Birkoﬀ 50 3. Public-key Cryptography FIGURE 3.1. Diﬃe and Hellman (photos from [Sin99]) [Section One’s master hacker] accidentally discovers encrypted messages between Michael and Nikita sent with Walter’s help, Birkoﬀ is forced to tell Madeline. Suspecting that Michael and Nikita may be planning a coup d’´etat, Operations and Madeline use a second team of operatives to track Michael and Nikita’s next secret rendezvous... killing them if necessary. What sort of encryption might Walter have helped them to use? I let my imagination run free, and this is what I came up with. After being captured at the base camp, Nikita is given a phone by her captors in hopes that she’ll use it and they’ll be able to ﬁgure out what she is really up to. Everyone is eagerly listening in on her calls. Remark 3.1.1. In this book, we will assume a method is available for pro- ducing random integers. Methods for generating random integers are in- volved and interesting, but we will not discuss them in this book. For an in-depth treatment of random numbers, see [Knu98, Ch. 3]. Nikita remembers a conversation with Walter about a public-key cryp- tosystem called the “Diﬃe-Hellman key exchange.” She remembers that it allows two people to agree on a secret key in the presence of eavesdroppers. Moreover, Walter mentioned that though Diﬃe-Hellman was the ﬁrst ever public-key exchange system, it is still in common use today (for example, in OpenSSH protocol version 2, see http://www.openssh.com/). Nikita pulls out her handheld computer and phone, calls up Michael, and they do the following, which is wrong (try to ﬁgure out what is wrong as you read it). 1. Together they choose a big prime number p and a number g with 1 < g < p. 2. Nikita secretly chooses an integer n. 3.2 The Diﬃe-Hellman Key Exchange 51 3. Michael secretly chooses an integer m. 4. Nikita tells Michael ng (mod p). 5. Michael tells mg (mod p) to Nikita. 6. The “secret key” is s = nmg (mod p), which both Nikita and Michael can easily compute. Here’s a very simple example with small numbers that illustrates what Michael and Nikita do. (They really used much larger numbers.) 1. p = 97, g = 5 2. n = 31 3. m = 95 4. ng ≡ 58 (mod 97) 5. mg ≡ 87 (mod 97) 6. s = nmg = 78 (mod 97) Nikita and Michael are foiled because everyone easily ﬁgures out s: 1. Everyone knows p, g, ng (mod p), and mg (mod p). 2. Using Algorithm 2.3.7, anyone can easily ﬁnd a, b ∈ Z such that ag + bp = 1, which exists because gcd(g, p) = 1. 3. Then, ang ≡ n (mod p), so everyone knows Nikita’s secret key n, and hence can easily compute the shared secret s. To taunt her, Nikita’s captors give her a paragraph from a review of Diﬃe and Hellman’s 1976 paper “New Directions in Cryptography” [DH76]: “The authors discuss some recent results in communications theory [...] The ﬁrst [method] has the feature that an unautho- rized ‘eavesdropper’ will ﬁnd it computationally infeasible to de- cipher the message [...] They propose a couple of techniques for implementing the system, but the reviewer was unconvinced.” 3.2 The Diﬃe-Hellman Key Exchange As night darkens Nikita’s cell, she reﬂects on what has happened. Upon re- alizing that she mis-remembered how the system works, she phones Michael and they do the following: 52 3. Public-key Cryptography 1. Together Michael and Nikita choose a 200-digit integer p that is likely to be prime (see Section 2.4), and choose a number g with 1 < g < p. 2. Nikita secretly chooses an integer n. 3. Michael secretly chooses an integer m. 4. Nikita computes gn (mod p) on her handheld computer and tells Michael the resulting number over the phone. 5. Michael tells Nikita gm (mod p). 6. The shared secret key is then s ≡ (gn)m ≡ (gm) n ≡ gnm (mod p), which both Nikita and Michael can compute. Here is a simpliﬁed example that illustrates what they did, that involves only relatively simple arithmetic. 1. p = 97, g = 5 2. n = 31 3. m = 95 4. gn ≡ 7 (mod p) 5. gm ≡ 39 (mod p) 6. s ≡ (gn)m ≡ 14 (mod p) 3.2.1 The Discrete Log Problem Nikita communicates with Michael by encrypting everything using their agreed upon secret key (for example, using a standard symmetric cipher such as AES, Arcfour, Cast128, 3DES, or Blowﬁsh). In order to understand the conversation, the eavesdropper needs s, but it takes a long time to compute s given only p, g, gn, and gm. One way would be to compute n from knowledge of g and gn; this is possible, but appears to be “computationally infeasible,” in the sense that it would take too long to be practical. Let a, b, and n be real numbers with a, b > 0 and n ≥ 0. Recall that the “log to the base b” function is characterized by logb(a) = n if and only if a = bn. We use the logb function in algebra to solve the following problem: Given a base b and a power a of b, ﬁnd an exponent n such that a = b n. 3.2 The Diﬃe-Hellman Key Exchange 53 That is, given a = b n and b, ﬁnd n. SAGE Example 3.2.1. The number a = 19683 is the nth power of b = 3 for some n. We quickly ﬁnd that n = log3(19683) = log(19683)/ log(3) = 9. sage: log(19683.0) 9.88751059801299 sage: log(3.0) 1.09861228866811 sage: log(19683.0) / log(3.0) 9.00000000000000 Sage can quickly compute a numerical approximation for log(x), for any x, by computing a partial sum of an appropriate rapidly-converging inﬁnite series (at least for x in a certain range). The discrete log problem is the analog of computing logb(a) but where both b and a are elements of a ﬁnite group. Problem 3.2.2 (Discrete Log Problem). Let G be a ﬁnite group, for ex- ample, G = (Z/pZ) ∗. Given b ∈ G and a power a of b, ﬁnd a positive integer n such that bn = a. As far as we know, ﬁnding discrete logarithms in (Z/pZ) ∗ when p is large is “very diﬃcult” in practice. Over the years, many people have been very motivated to try. For example, if Nikita’s captors could eﬃciently solve Problem 3.2.2, then they could read the messages she exchanges with Michael. Unfortunately, we have no formal proof that computing discrete logarithms on a classical computer is diﬃcult. Also, Peter Shor [Sho97] showed that if one could build a suﬃciently complicated quantum com- puter, it could solve the discrete logarithm problem in time bounded by a polynomial function of the number of digits of #G. It is easy to give an ineﬃcient algorithm that solves the discrete log problem. Simply try b1, b2, b 3, etc., until we ﬁnd an exponent n such that bn = a. For example, suppose a = 18, b = 5, and p = 23. Working modulo 23, we have b 1 = 5, b2 = 2, b3 = 10, . . . , b 12 = 18, so n = 12. When p is large, computing the discrete log this way soon be- comes impractical, because increasing the number of digits of the modulus makes the computation take vastly longer. SAGE Example 3.2.3. Perhaps part of the reason that computing discrete logarithms is diﬃcult, is that the logarithm in the real numbers is continu- ous, but the (minimum) logarithm of a number mod n bounces around at random. We illustrate this exotic behavior in Figure 3.2. This draws the continuous plot. 54 3. Public-key Cryptography 2.5 5 7.5 10 -2.5 -2 -1.5 -1 -0.5 0.5 1 1.5 2 2.5 25 50 75 100 25 50 75 100 FIGURE 3.2. Graphs of the continuous log and of the discrete log modulo 53. Which picture looks easier to predict? sage: plot(log, 0.1,10, rgbcolor=(0,0,1)) This draws the discrete plot. sage: p = 53 sage: R = Integers(p) sage: a = R.multiplicative_generator() sage: v = sorted([(a^n, n) for n in range(p-1)]) sage: G = plot(point(v,pointsize=50,rgbcolor=(0,0,1))) sage: H = plot(line(v,rgbcolor=(0.5,0.5,0.5))) sage: G + H 3.2.2 Realistic Diﬃe-Hellman Example In this section, we present an example that uses bigger numbers. First, we prove a proposition that we can use to choose a prime p in such a way that it is easy to ﬁnd a g ∈ (Z/pZ) ∗ with order p − 1. We have already seen in Section 2.5 that for every prime p there exists an element g of order p − 1, and we gave Algorithm 2.5.16 for ﬁnding a primitive root for any prime. The signiﬁcance of Proposition 3.2.4 below is that it suggests an algorithm for ﬁnding a primitive root that is easier to use in practice when p is large, because it does not require factoring p−1. Of course, one could also just use a random g for Diﬃe-Hellman; it is not essential that g generates (Z/pZ) ∗. Proposition 3.2.4. Suppose p is a prime such that (p−1)/2 is also prime. Then each element of (Z/pZ) ∗ has order one of 1, 2, (p − 1)/2, or p − 1. Proof. Since p is prime, the group (Z/pZ) ∗ is of order p−1. By assumption, the prime factorization of p − 1 is 2 · ((p − 1)/2). Let a ∈ (Z/pZ) ∗. Then by Theorem 2.1.20, a p−1 = 1, so the order of a is a divisor of p − 1, which proves the proposition. 3.2 The Diﬃe-Hellman Key Exchange 55 Given a prime p with (p − 1)/2 prime, ﬁnd an element of order p − 1 as follows. If 2 has order p − 1, we are done. If not, 2 has order (p − 1)/2 since 2 does not have order either 1 or 2. Then −2 has order p − 1. Let p = 93450983094850938450983409611. Then p is prime, but (p − 1)/2 is not. So we keep adding 2 to p and testing pseudoprimality using algorithms from Section 2.4 until we ﬁnd that the next pseudoprime after p is q = 93450983094850938450983409623. It turns out that q pseudoprime and (q − 1)/2 is also pseudoprime. We ﬁnd that 2 has order (q − 1)/2, so g = −2 has order q − 1 modulo q, and is hence a generator of (Z/qZ)∗, at least assuming that q is really prime. The secret random numbers generated by Nikita and Michael are n = 18319922375531859171613379181 and m = 82335836243866695680141440300. Nikita sends gn = 45416776270485369791375944998 ∈ (Z/pZ) ∗ to Michael, and Michael sends gm = 15048074151770884271824225393 ∈ (Z/pZ)∗ to Nikita. They agree on the secret key gnm = 85771409470770521212346739540 ∈ (Z/pZ) ∗. SAGE Example 3.2.5. We illustrate the above computations using Sage. sage: q = 93450983094850938450983409623 sage: q.is_prime() True sage: is_prime((q-1)//2) True sage: g = Mod(-2, q) sage: g.multiplicative_order() 93450983094850938450983409622 sage: n = 18319922375531859171613379181 sage: m = 82335836243866695680141440300 sage: g^n 45416776270485369791375944998 sage: g^m 15048074151770884271824225393 sage: (g^n)^m 85771409470770521212346739540 sage: (g^m)^n 85771409470770521212346739540 56 3. Public-key Cryptography 3.2.3 The Man in the Middle Attack Since their ﬁrst system was broken, instead of talking on the phone, Michael and Nikita can now only communicate via text messages. One of her cap- tors, The Man, is watching each of the transmissions; moreover, he can intercept messages and send false messages. When Nikita sends a mes- sage to Michael announcing gn (mod p), The Man intercepts this message, and sends his own number gt (mod p) to Michael. Eventually, Michael and The Man agree on the secret key gtm (mod p), and Nikita and The Man agree on the key gtn (mod p). When Nikita sends a message to Michael she unwittingly uses the secret key gtn (mod p); The Man then intercepts it, decrypts it, changes it, and re-encrypts it using the key gtm (mod p), and sends it on to Michael. This is bad because now The Man can read every message sent between Michael and Nikita, and moreover, he can change them in transmission in subtle ways. One way to get around this attack is to use a digital signature scheme based on the RSA cryptosystem. We will not discuss digital signatures further in this book, but will discuss RSA in the next section. 3.3 The RSA Cryptosystem The Diﬃe-Hellman key exchange has drawbacks. As discussed in Section 3.2.3, it is susceptible to the man in the middle attack. This section is about the RSA public-key cryptosystem of Rivest, Shamir, and Adleman [RSA78], which is an alternative to Diﬃe-Hellman that is more ﬂexible in some ways. We ﬁrst describe the RSA cryptosystem, then discuss several ways to attack it. It is important to be aware of such weaknesses, in order to avoid foolish mistakes when implementing RSA. We barely scratched the surface here of the many possible attacks on speciﬁc implementations of RSA or other cryptosystems. 3.3.1 How RSA works The fundamental idea behind RSA is to try to construct a trap-door or one-way function on a set X. This is an invertible function E : X → X such that it is easy for Nikita to compute E−1, but extremely diﬃcult for anybody else to do so. Here is how Nikita makes a one-way function E on the set of integers modulo n. 1. Using a method hinted at in Section 2.4, Nikita picks two large primes p and q, and lets n = pq. 3.3 The RSA Cryptosystem 57 2. It is then easy for Nikita to compute ϕ(n) = ϕ(p) · ϕ(q) = (p − 1) · (q − 1). 3. Nikita next chooses a random integer e with 1 < e < ϕ(n) and gcd(e, ϕ(n)) = 1. 4. Nikita uses the algorithm from Section 2.3.2 to ﬁnd a solution x = d to the equation ex ≡ 1 (mod ϕ(n)). 5. Finally, Nikita deﬁnes a function E : Z/nZ → Z/nZ by E(x) = xe ∈ Z/nZ. Note that anybody can compute E fairly quickly using the repeated- squaring algorithm from Section 2.3.2. Nikita’s public key is the pair of integers (n, e), which is just enough information for people to easily com- pute E. Nikita knows a number d such that ed ≡ 1 (mod ϕ(n)), so, as we will see, she can quickly compute E−1. To send Nikita a message, proceed as follows. Encode your message, in some way, as a sequence of numbers modulo n (see Section 3.3.2) m1, . . . , mr ∈ Z/nZ, then send E(m1), . . . , E(mr) to Nikita. (Recall that E(m) = me for m ∈ Z/nZ.) When Nikita receives E(mi), she ﬁnds each mi by using that E−1(m) = md, a fact that follows from Proposition 3.3.1 Proposition 3.3.1 (Decryption Key). Let n be an integer that is a product of distinct primes and let d, e ∈ N be such that p − 1 | de − 1 for each prime p | n. Then a de ≡ a (mod n) for all a ∈ Z. Proof. Since n | a de − a, if and only if p | a de − a for each prime divisor p of n, it suﬃces to prove that ade ≡ a (mod p) for each prime divisor p of n. If gcd(a, p) ̸= 1, then a ≡ 0 (mod p), so a de ≡ a (mod p). If gcd(a, p) = 1, then Theorem 2.1.20 asserts that a p−1 ≡ 1 (mod p). Since p − 1 | de − 1, we have a de−1 ≡ 1 (mod p) as well. Multiplying both sides by a shows that a de ≡ a (mod p). Thus to decrypt E(mi) Nikita computes E(mi) d = (me i ) d = mi. 58 3. Public-key Cryptography SAGE Example 3.3.2. We implement the RSA cryptosystem using Sage. The rsa function creates a key with (at most) the given number of bits, i.e., if bits equals 20, it creates a key n = pq such that n is approximately 220. Typical real-life cryptosystems would choose keys that are 512, 1024, or 2048 bits long. Try generating large keys yourself using Sage; how long does it take? sage: def rsa(bits): ... # only prove correctness up to 1024 bits ... proof = (bits <= 1024) ... p = next_prime(ZZ.random_element(2**(bits//2 +1)), ... proof=proof) ... q = next_prime(ZZ.random_element(2**(bits//2 +1)), ... proof=proof) ... n = p * q ... phi_n = (p-1) * (q-1) ... while True: ... e = ZZ.random_element(1,phi_n) ... if gcd(e,phi_n) == 1: break ... d = lift(Mod(e,phi_n)^(-1)) ... return e, d, n ... sage: def encrypt(m,e,n): ... return lift(Mod(m,n)^e) ... sage: def decrypt(c,d,n): ... return lift(Mod(c,n)^d) ... sage: e,d,n = rsa(20) sage: c = encrypt(123, e, n) sage: decrypt(c, d, n) 123 3.3.2 Encoding a Phrase in a Number In order to use the RSA cryptosystem to encrypt messages, it is necessary to encode them as a sequence of numbers of size less than n = pq. We now describe a simple way to do this. Note that in any actual deployed implementation, it is crucial that you add extra random characters (“salt”) at the beginning of each block of the message, so that the same plain text encodes diﬀerently each time. This helps thwart chosen plain text attacks. Suppose s is a sequence of capital letters and spaces, and that s does not begin with a space. We encode s as a number in base 27 as follows: a single space corresponds to 0, the letter A to 1, B to 2, . . ., Z to 26. Thus “RUN 3.3 The RSA Cryptosystem 59 NIKITA” is a number written in base 27. RUN NIKITA ↔ 279 · 18 + 278 · 21 + 277 · 14 + 276 · 0 + 275 · 14 + 274 · 9 + 273 · 11 + 272 · 9 + 27 · 20 + 1 = 143338425831991 (in decimal). To recover the letters from the decimal number, repeatedly divide by 27 and read oﬀ the letter corresponding to each remainder. 143338425831991 = 5308830586370 · 27 + 1 “A” 5308830586370 = 196623355050 · 27 + 20 “T” 196623355050 = 7282346483 · 27 + 9 “I” 7282346483 = 269716536 · 27 + 11 “K” 269716536 = 9989501 · 27 + 9 “I” 9989501 = 369981 · 27 + 14 “N” 369981 = 13703 · 27 + 0 “ ” 13703 = 507 · 27 + 14 “N” 507 = 18 · 27 + 21 “U” 18 = 0 · 27 + 18 “R” If 27 k ≤ n, then any sequence of k letters can be encoded as above using a positive integer ≤ n. Thus if we can encrypt integers of size at most n, then we must break our message up into blocks of size at most log27(n). SAGE Example 3.3.3. We use Sage to implement conversion between a string and a number, though in a bit more generally than in the toy illus- tration above (which used only base 27). The input string s on a computer is stored in a format called ASCII, so each “letter” corresponds to an inte- ger between 0 and 255, inclusive. This number is obtained from the letter using the ord command. sage: def encode(s): ... s = str(s) # make input a string ... return sum(ord(s[i])*256^i for i in range(len(s))) sage: def decode(n): ... n = Integer(n) # make input an integer ... v = [] ... while n != 0: ... v.append(chr(n % 256)) ... n //= 256 # this replaces n by floor(n/256). ... return ’’.join(v) sage: m = encode(’Run Nikita!’); m 40354769014714649421968722 sage: decode(m) ’Run Nikita!’ 60 3. Public-key Cryptography 3.3.3 Some Complete Examples To make the arithmetic easier to follow, we use small prime numbers p and q and encrypt the single letter “X” using the RSA cryptosystem. First, we compute the parameters of an RSA cryptosystem. 1. Choose p and q: Let p = 17, q = 19, so n = pq = 323. 2. Compute ϕ(n): ϕ(n) = ϕ(p · q) = ϕ(p) · ϕ(q) = (p − 1)(q − 1) = pq − p − q + 1 = 323 − 17 − 19 + 1 = 288. 3. Randomly choose an e < 288: We choose e = 95. 4. Solve 95x ≡ 1 (mod 288). Using the GCD algorithm, we ﬁnd that d = 191 solves the equation. We have thus computed the parameters of an RSA public key cryptosystem. The public key is (323, 95), so the encryption function is E(x) = x95, and the decryption function is D(x) = x191. Next, we encrypt the letter “X”. It is encoded as the number 24, since X is the 24th letter of the alphabet. We have E(24) = 2495 = 294 ∈ Z/323Z. To decrypt, we compute E−1: E−1(294) = 294 191 = 24 ∈ Z/323Z. This next example illustrates RSA but with bigger numbers. Let p = 738873402423833494183027176953, q = 3787776806865662882378273. Then, n = p · q = 2798687536910915970127263606347911460948554197853542169 and ϕ(n) = (p − 1)(q − 1) = 2798687536910915970127262867470721260308194351943986944. 3.4 Attacking RSA 61 Using a pseudo-random number generator on a computer, the author ran- domly chose the integer e = 1483959194866204179348536010284716655442139024915720699. Then, d = 2113367928496305469541348387088632973457802358781610803 Since log27(n) ≈ 38.04, we can encode then encrypt single blocks of up to 38 letters. Let’s encrypt the string RUN NIKITA, which encodes as m = 143338425831991. We have E(m) = m e = 1504554432996568133393088878600948101773726800878873990. Remark 3.3.4. In practice, one usually choses e to be small, since that does not seem to reduce the security of RSA, and makes the key size smaller. For example, in the OpenSSL documentation (see http://www.openssl.org/) about their implementation of RSA, it states that “The exponent is an odd number, typically 3, 17 or 65537.” 3.4 Attacking RSA Suppose Nikita’s public key is (n, e) and her decryption key is d, so ed ≡ 1 (mod ϕ(n)). If somehow we compute the factorization n = pq, then we can compute ϕ(n) = (p−1)(q−1) and hence compute d. Thus, if we can factor n then we can break the corresponding RSA public-key cryptosystem. 3.4.1 Factoring n Given ϕ(n) Suppose n = pq. Given ϕ(n), it is very easy to compute p and q. We have ϕ(n) = (p − 1)(q − 1) = pq − (p + q) + 1, so we know both pq = n and p + q = n + 1 − ϕ(n). Thus, we know the polynomial x2 − (p + q)x + pq = (x − p)(x − q) whose roots are p and q. These roots can be found using the quadratic formula. Example 3.4.1. The number n = pq = 31615577110997599711 is a product of two primes, and ϕ(n) = 31615577098574867424. We have f = x2 − (n + 1 − ϕ(n))x + n = x2 − 12422732288x + 31615577110997599711 = (x − 3572144239)(x − 8850588049), 62 3. Public-key Cryptography where the factorization step is easily accomplished using the quadratic formula: −b + √b2 − 4ac 2a = 12422732288 + √124227322882 − 4 · 31615577110997599711 2 = 8850588049. We conclude that n = 3572144239 · 8850588049. SAGE Example 3.4.2. The following Sage function factors n = pq given n and ϕ(n). sage: def crack_rsa(n, phi_n): ... R.<x> = PolynomialRing(QQ) ... f = x^2 - (n+1 -phi_n)*x + n ... return [b for b, _ in f.roots()] sage: crack_rsa(31615577110997599711, 31615577098574867424) [8850588049, 3572144239] 3.4.2 When p and q are Close Suppose that p and q are “close” to each other. Then it is easy to factor n using a factorization method of Fermat called the Fermat Factorization Method. Suppose n = pq with p > q. Then, n = ( p + q 2 )2 − ( p − q 2 )2 . Since p and q are “close,” s = p − q 2 is small, t = p + q 2 is only slightly larger than √n, and t2 − n = s 2 is a perfect square. So, we just try t = ⌈√n⌉, t = ⌈√n⌉ + 1, t = ⌈ √n⌉ + 2, . . . until t2−n is a perfect square s 2. (Here ⌈x⌉ denotes the least integer n ≥ x.) Then p = t + s, q = t − s. Example 3.4.3. Suppose n = 23360947609. Then √n = 152842.88 . . . . 3.4 Attacking RSA 63 If t = 152843, then √t2 − n = 187.18 . . .. If t = 152844, then √t2 − n = 583.71 . . .. If t = 152845, then √t2 − n = 804 ∈ Z. Thus s = 804. We ﬁnd that p = t + s = 153649 and q = t − s = 152041. SAGE Example 3.4.4. We implement the above algorithm for factoring an RSA modulus n = pq, when one of p and q is close to √n. sage: def crack_when_pq_close(n): ... t = Integer(ceil(sqrt(n))) ... while True: ... k = t^2 - n ... if k > 0: ... s = Integer(int(round(sqrt(t^2 - n)))) ... if s^2 + n == t^2: ... return t+s, t-s ... ... t += 1 ... sage: crack_when_pq_close(23360947609) (153649, 152041) For example, you might think that choosing a random prime, and the next prime after would be a good idea, but instead it creates an easy-to- crack cryptosystem. sage: p = next_prime(2^128); p 340282366920938463463374607431768211507 sage: q = next_prime(p) sage: crack_when_pq_close(p*q) (340282366920938463463374607431768211537, 340282366920938463463374607431768211507) 3.4.3 Factoring n Given d In this section, we show that ﬁnding the decryption key d for an RSA cryptosystem is, in practice, at least as diﬃcult as factoring n. We give a probabilistic algorithm that given a decryption key determines the factor- ization of n. Consider an RSA cryptosystem with modulus n and encryption key e. Suppose we somehow ﬁnding an integer d such that a ed ≡ a (mod n) for all a. Then m = ed − 1 satisﬁes am ≡ 1 (mod n) for all a that are coprime to n. As we saw in Section 3.4.1, knowing ϕ(n) leads directly to a factorization of n. Unfortunately, knowing d does not seem to lead easily to 64 3. Public-key Cryptography a factorization of n. However, there is a probabilistic procedure that, given an m such that am ≡ 1 (mod n), will ﬁnd a factorization of n with “high probability” (we will not analyze the probability here). Algorithm 3.4.5 (Probabilistic Algorithm to Factor n). Let n = pq be the product of two distinct odd primes, and suppose m is an integer such that am ≡ 1 (mod n) for all a coprime to n. This probabilistic algorithm factors n with “high probability.” In the steps below, a always denotes an integer coprime to n = pq. 1. [Divide out powers of 2] If m is even and a m/2 ≡ 1 (mod n) for several randomly chosen a, set m = m/2, and go to Step 1, otherwise let a be such that a m/2 ̸≡ 1 (mod n). 2. [Compute GCD] Choose a random a and compute g = gcd(a m/2 − 1, n). 3. [Terminate?] If g is a proper divisor of n, output g and terminate. Otherwise go to Step 2. Before giving the proof, we introduce some more terminology from alge- bra. Deﬁnition 3.4.6 (Group Homomorphism). Let G and H be groups. A map ϕ : G → H is a group homomorphism if for all a, b ∈ G we have ϕ(ab) = ϕ(a)ϕ(b). A group homomorphism is called surjective if for every c ∈ H there is a ∈ G such that ϕ(a) = c. The kernel of a group homomorphism ϕ : G → H is the set ker(ϕ) of elements a ∈ G such that ϕ(a) = 1. A group homomorphism is injective if ker(ϕ) = {1}. Deﬁnition 3.4.7 (Subgroup). If G is a group and H is a subset of G, then H is a subgroup if H is a group under the group operation on G. For example, if ϕ : G → H is a group homomorphism, then ker(ϕ) is a subgroup of G (see Exercise 2.21). We now return to discussing Algorithm 3.4.5. In Step 1, note that m is even since (−1)m ≡ 1 (mod n), so it makes sense to consider m/2. It is not practical to determine whether or not a m/2 ≡ 1 (mod n) for all a, because it would require doing a computation for too many a. Instead, we try a few random a; if a m/2 ≡ 1 (mod n) for the a we check, we divide m by 2. Also note that if there exists even a single a such that a m/2 ̸≡ 1 (mod n), then half the a have this property, since then a 7→ a m/2 is a surjective homomorphism (Z/nZ)∗ → {±1} and the kernel has index 2. Proposition 2.5.3 implies that if x2 ≡ 1 (mod p) then x = ±1 (mod p). In Step 2, since (a m/2) 2 ≡ 1 (mod n), we also have (a m/2) 2 ≡ 1 (mod p) and (a m/2) 2 ≡ 1 (mod q), so a m/2 ≡ ±1 (mod p) and a m/2 ≡ ±1 (mod q). Since a m/2 ̸≡ 1 (mod n), there are three possibilities for these signs, so with positive probability one of the following two possibilities occurs: 1. a m/2 ≡ +1 (mod p) and a m/2 ≡ −1 (mod q) 3.4 Attacking RSA 65 2. a m/2 ≡ −1 (mod p) and a m/2 ≡ +1 (mod q). The only other possibility is that both signs are −1. In the ﬁrst case, p | a m/2 − 1 but q ∤ a m/2 − 1, so gcd(a m/2 − 1, pq) = p, and we have factored n. Similarly, in the second case, gcd(a m/2 − 1, pq) = q, and we again factor n. Example 3.4.8. Somehow we discover that the RSA cryptosystem with n = 32295194023343 and e = 29468811804857 has decryption key d = 11127763319273. We use this information and Al- gorithm 3.4.5 to factor n. If m = ed − 1 = 327921963064646896263108960, then ϕ(pq) | m, so a m ≡ 1 (mod n) for all a coprime to n. For each a ≤ 20 we ﬁnd that a m/2 ≡ 1 (mod n), so we replace m with m 2 = 163960981532323448131554480. Again, we ﬁnd with this new m that for each a ≤ 20, a m/2 ≡ 1 (mod n), so we replace m by 81980490766161724065777240. Yet again, for each a ≤ 20, am/2 ≡ 1 (mod n), so we replace m by 40990245383080862032888620. This is enough, since 2m/2 ≡ 4015382800099 (mod n). Then, gcd(2m/2 − 1, n) = gcd(4015382800098, 32295194023343) = 737531, and we have found a factor of n. Dividing, we ﬁnd that n = 737531 · 43788253. SAGE Example 3.4.9. We implement Algorithm 3.4.5 in Sage. sage: def crack_given_decrypt(n, m): ... n = Integer(n); m = Integer(m); # some type checking ... # Step 1: divide out powers of 2 ... while True: ... if is_odd(m): break ... divide_out = True ... for i in range(5): ... a = randrange(1,n) ... if gcd(a,n) == 1: ... if Mod(a,n)^(m//2) != 1: ... divide_out = False ... break 66 3. Public-key Cryptography ... if divide_out: ... m = m//2 ... else: ... break ... # Step 2: Compute GCD ... while True: ... a = randrange(1,n) ... g = gcd(lift(Mod(a, n)^(m//2)) - 1, n) ... if g != 1 and g != n: ... return g ... We show how to verify Example 3.4.8 using Sage. sage: n=32295194023343; e=29468811804857; d=11127763319273 sage: crack_given_decrypt(n, e*d - 1) 737531 sage: factor(n) 737531 * 43788253 We try a much larger example. sage: e = 22601762315966221465875845336488389513 sage: d = 31940292321834506197902778067109010093 sage: n = 268494924039590992469444675130990465673 sage: p = crack_given_decrypt(n, e*d - 1) sage: p # random output (could be other prime divisor) 13432418150982799907 sage: n % p 0 3.4.4 Further Remarks If one were to implement an actual RSA cryptosystem, there are many ad- ditional tricks and ideas to keep in mind. For example, one can add some extra random letters to each block of text, so that a given string will en- crypt diﬀerently each time it is encrypted. This makes it more diﬃcult for an attacker who knows the encrypted and plaintext versions of one message to gain information about subsequent encrypted messages. In any partic- ular implementation, there might be attacks that would be devastating in practice, but which would not require factorization of the RSA modulus. RSA is in common use, for example, it is used in OpenSSH protocol version 1 (see http://www.openssh.com/). We will consider the ElGamal cryptosystem in Sections 6.4.2. It has a similar ﬂavor to RSA, but is more ﬂexible in some ways. 3.5 Exercises 67 Probably the best general purpose attack on RSA is the number ﬁeld sieve, which is a general algorithm for factoring integers of the form pq. A description of the sieve is beyond the scope of this book. The elliptic curve method is another related general algorithm that we will discuss in detail in Section 6.3. SAGE Example 3.4.10. Here is a simple example of using a variant of the number ﬁeld sieve (called the quadratic sieve) in Sage to factor an RSA key with about 192 bits: sage: set_random_seed(0) sage: p = next_prime(randrange(2^96)) sage: q = next_prime(randrange(2^97)) sage: n = p * q sage: qsieve(n) ([6340271405786663791648052309, 46102313108592180286398757159], ’’) 3.5 Exercises 3.1 This problem concerns encoding phrases using numbers using the encoding of Section 3.3.2. What is the longest that an arbitrary se- quence of letters (no spaces) can be if it must ﬁt in a number that is less than 10 20? 3.2 Suppose Michael creates an RSA cryptosystem with a very large mod- ulus n for which the factorization of n cannot be found in a reasonable amount of time. Suppose that Nikita sends messages to Michael by representing each alphabetic character as an integer between 0 and 26 (A corresponds to 1, B to 2, etc., and a space ␣ to 0), then encrypts each number separately using Michael’s RSA cryptosystem. Is this method secure? Explain your answer. 3.3 For any n ∈ N, let σ(n) be the sum of the divisors of n; for example, σ(6) = 1 + 2 + 3 + 6 = 12 and σ(10) = 1 + 2 + 5 + 10 = 18. Suppose that n = pqr with p, q, and r distinct primes. Devise an “eﬃcient” algorithm that given n, ϕ(n) and σ(n), computes the factorization of n. For example, if n = 105, then p = 3, q = 5, and r = 7, so the input to the algorithm would be n = 105, ϕ(n) = 48, and σ(n) = 192, and the output would be 3, 5, and 7. 3.4 You and Nikita wish to agree on a secret key using the Diﬃe-Hellman key exchange. Nikita announces that p = 3793 and g = 7. Nikita 68 3. Public-key Cryptography secretly chooses a number n < p and tells you that gn ≡ 454 (mod p). You choose the random number m = 1208. What is the secret key? 3.5 You see Michael and Nikita agree on a secret key using the Diﬃe- Hellman key exchange. Michael and Nikita choose p = 97 and g = 5. Nikita chooses a random number n and tells Michael that gn ≡ 3 (mod 97), and Michael chooses a random number m and tells Nikita that gm ≡ 7 (mod 97). Brute force crack their code: What is the secret key that Nikita and Michael agree upon? What is n? What is m? 3.6 In this problem, you will “crack” an RSA cryptosystem. What is the secret decoding number d for the RSA cryptosystem with public key (n, e) = (5352381469067, 4240501142039)? 3.7 Nikita creates an RSA cryptosystem with public key (n, e) = (1433811615146881, 329222149569169). In the following two problems, show the steps you take to factor n. (Don’t simply factor n directly using a computer.) (a) Somehow you discover that d = 116439879930113. Show how to use the probabilistic algorithm of Section 3.4.3 to factor n. (b) In part (a) you found that the factors p and q of n are very close. Show how to use the Fermat Factorization Method of Sec- tion 3.4.2 to factor n. This is page 69 Printer: Opaque this 4 Quadratic Reciprocity A linear equation ax ≡ b (mod n) has a solution if and only if gcd(a, n) divides b (see Proposition 2.1.15). This chapter is about some amazing mathematics motivated by the search for a criterion for whether or not a given quadratic equation ax2 + bx + c ≡ 0 (mod n) has a solution. In many cases, the Chinese Remainder Theorem and the quadratic formula reduce this to the key question of whether a given integer a is a perfect square modulo a prime p. The Quadratic Reciprocity Law of Gauss provides a precise answer to the following question: For which primes p is the image of a in (Z/pZ)∗ a perfect square? A deep fact, which we will completely prove in this chapter, is that the answer depends only on the reduction of p modulo 4a. Thus to decide if a is a square modulo p, one only needs to consider the residue of p modulo 4a, which is extremely surprising. It turns out that this “reciprocity law” goes to the heart of modern number theory and touches on advanced topics such as class ﬁeld theory and the Langlands program. There are over a hundred proofs of the Quadratic Reciprocity Law (see [Lem] for a long list). In this chapter, we give two proofs. The ﬁrst, which we give in Section 4.3, is completely elementary and involves keeping track of integer points in intervals. It is satisfying because one can understand every detail without much abstraction, but it might be unsatisfying if you ﬁnd it diﬃcult to conceptualize what is going on. In contrast, our second 70 4. Quadratic Reciprocity proof, which we give in Section 4.4, is more abstract and uses a conceptual development of properties of Gauss sums. You should read Sections 4.1 and 4.2, then at least one of Section 4.3 or Section 4.4, depending on your taste and how much abstract algebra you know. In Section 4.5, we return to the computational question of actually ﬁnd- ing square roots and solving quadratic equations in practice. 4.1 Statement of the Quadratic Reciprocity Law In this section, we state the Quadratic Reciprocity Law. Deﬁnition 4.1.1 (Quadratic Residue). Fix a prime p. An integer a not divisible by p is a quadratic residue modulo p if a is a square modulo p; otherwise, a is a quadratic nonresidue. For example, the squares modulo 5 are 1 2 = 1, 2 2 = 4, 3 2 = 4, 4 2 = 1, (mod 5) so 1 and 4 are both quadratic residues and 2 and 3 are quadratic non- residues. The quadratic reciprocity theorem is the deepest theorem that we will prove in this book. It connects the question of whether or not a is a quadratic residue modulo p to the question of whether p is a quadratic residue modulo each of the prime divisors of a. To express it precisely, we introduce some new notation. Deﬁnition 4.1.2 (Legendre Symbol). Let p be an odd prime and let a be an integer. Set ( a p ) =  | | 0 if gcd(a, p) ̸= 1, +1 if a is a quadratic residue, and −1 if a is a quadratic nonresidue. We call this symbol the Legendre Symbol. For example, we have ( 1 5 ) = 1, ( 2 5 ) = −1, ( 3 5 ) = −1, ( 4 5 ) = 1, ( 5 5 ) = 1. This notation is well entrenched in the literature even though it is also the notation for “a divided by p;” be careful not to confuse the two. SAGE Example 4.1.3. Use the legendre symbol command to compute the Legendre symbol in Sage. 4.1 Statement of the Quadratic Reciprocity Law 71 sage: legendre_symbol(2,3) -1 sage: legendre_symbol(1,3) 1 sage: legendre_symbol(3,5) -1 sage: legendre_symbol(Mod(3,5), 5) -1 Since ( a p ) only depends on a (mod p), it makes sense to deﬁne ( a p ) for a ∈ Z/pZ to be ( ˜a p ) for any lift ˜a of a to Z. Recall (see Deﬁnition 3.4.6) that a group homomorphism ϕ : G → H is a map such that for every a, b ∈ G we have ϕ(ab) = ϕ(a)ϕ(b). Moreover, we say that ϕ is surjective if for every c ∈ H there is an a ∈ G with ϕ(a) = c. The next lemma explains how the quadratic residue symbol deﬁnes a surjective group homomorphism. Lemma 4.1.4. The map ψ : (Z/pZ)∗ → {±1} given by ψ(a) = ( a p ) is a surjective group homomorphism. Proof. By Theorem 2.5.8, primitive roots exist, so there is g ∈ (Z/pZ)∗ such that the elements of (Z/pZ) ∗ are g, g2, . . . , g(p−1)/2, g(p+1)/2, . . . , gp−1 = 1. Since p − 1 is even, the squares of elements of (Z/pZ)∗ are g2, g4, . . . , g(p−1)/2·2 = 1, gp+1 = g2, . . . , g2(p−1). Note that the powers of g starting with gp+1 = g2 all appeared earlier on the list. Thus, the perfect squares in (Z/pZ) ∗ are exactly the powers gn with n = 2, 4, . . . , p − 1, even, and the nonsquares the powers gn with n = 1, 3, . . . , p − 2, odd. It follows that ψ is a homomorphism since an odd plus an odd is even, the sum of two evens is even, and odd plus an even is odd. Moreover, since g is not a square, ψ(g) = −1, so ψ is surjective. Remark 4.1.5. We rephrase the above proof in the language of group theory. The group G = (Z/pZ) ∗ of order p − 1 is a cyclic group. Since p is odd, p − 1 is even, so the subgroup H of squares of elements of G has index 2 in G. (See Exercise 4.2 for why H is a subgroup.) Since ( a p ) = 1 if and only if a ∈ H, we see that ψ is the composition G → G/H ∼= {±1}, where we identify the nontrivial element of G/H with −1. Remark 4.1.6. We can alternatively prove that ψ is surjective without using that (Z/pZ) ∗ is cyclic, as follows. If a ∈ (Z/pZ) ∗ is a square, say a ≡ b 2 72 4. Quadratic Reciprocity TABLE 4.1. When is 5 a square modulo p? p ( 5 p ) p mod 5 7 −1 2 11 1 1 13 −1 3 17 −1 2 19 1 4 23 −1 3 p ( 5 p ) p mod 5 29 1 4 31 1 1 37 −1 2 41 1 1 43 −1 3 47 −1 2 (mod p), then a (p−1)/2 = bp−1 ≡ 1 (mod p), so a is a root of f = x(p−1)/2 − 1. By Proposition 2.5.3, the polynomial f has at most (p−1)/2 roots. Thus, there must be an a ∈ (Z/pZ) ∗ that is not a root of f , and for that a, we have ψ(a) = ( a p ) = −1, and trivially ψ(1) = 1, so the map ψ is surjective. Note that this argument does not prove that ψ is a homomorphism. The symbol ( a p ) only depends on the residue class of a modulo p, so making a table of values ( a 5 ) for many values of a would be easy. Would it be easy to make a table of ( 5 p ) for many p? Perhaps, since there appears to be a simple pattern in Table 4.1. It seems that ( 5 p ) depends only on the congruence class of p modulo 5. More precisely, ( 5 p ) = 1 if and only if p ≡ 1, 4 (mod 5), i.e., ( 5 p ) = 1 if and only if p is a square modulo 5. Based on similar observations, in the 18th century various mathemati- cians found a conjectural explanation for the mystery suggested by Ta- ble 4.1. Finally, on April 8, 1796, at the age of 19, Gauss proved the fol- lowing theorem. Theorem 4.1.7 (Gauss’s Quadratic Reciprocity Law). Suppose p and q are distinct odd primes. Then ( p q ) = (−1) p−1 2 · q−1 2 ( q p ) . Also ( −1 p ) = (−1)(p−1)/2 and ( 2 p ) = { 1 if p ≡ ±1 (mod 8) −1 if p ≡ ±3 (mod 8). We will give two proofs of Gauss’s formula relating ( p q ) to ( q p ). The ﬁrst elementary proof is in Section 4.3, and the second more algebraic proof is in Section 4.4. 4.2 Euler’s Criterion 73 In our example, Gauss’s theorem implies that ( 5 p ) = (−1)2· p−1 2 ( p 5 ) = ( p 5 ) = { +1 if p ≡ 1, 4 (mod 5) −1 if p ≡ 2, 3 (mod 5). As an application, the following example illustrates how to answer ques- tions like “is a a square modulo b” using Theorem 4.1.7. Example 4.1.8. Is 69 a square modulo the prime 389? We have ( 69 389 ) = ( 3 · 23 389 ) = ( 3 389 ) · ( 23 389 ) = (−1) · (−1) = 1. Here ( 3 389 ) = ( 389 3 ) = ( 2 3 ) = −1, and ( 23 389 ) = ( 389 23 ) = ( 21 23 ) = ( −2 23 ) = ( −1 23 ) ( 2 23 ) = (−1) 23−1 2 · 1 = −1. Thus 69 is a square modulo 389. SAGE Example 4.1.9. We could also do this computation in Sage as follows: sage: legendre_symbol(69,389) 1 Though we know that 69 is a square modulo 389, we don’t know an explicit x such that x2 ≡ 69 (mod 389)! This is reminiscent of how we proved using Theorem 2.1.20 that certain numbers are composite without knowing a factorization. Remark 4.1.10. The Jacobi symbol is an extension of the Legendre symbol to composite moduli. For more details, see Exercise 4.9. 4.2 Euler’s Criterion Let p be an odd prime and a an integer not divisible by p. Euler used the existence of primitive roots to show that ( a p ) is congruent to a (p−1)/2 modulo p. We will use this fact repeatedly below in both proofs of Theo- rem 4.1.7. Proposition 4.2.1 (Euler’s Criterion). We have ( a p ) = 1 if and only if a (p−1)/2 ≡ 1 (mod p). 74 4. Quadratic Reciprocity Proof. The map ϕ : (Z/pZ)∗ → (Z/pZ)∗ given by ϕ(a) = a (p−1)/2 is a group homomorphism, since powering is a group homomorphism of any abelian group (see Exercise 4.2). Let ψ : (Z/pZ) ∗ → {±1} be the homo- morphism ψ(a) = ( a p ) of Lemma 4.1.4. If a ∈ ker(ψ), then a = b2 for some b ∈ (Z/pZ) ∗, so ϕ(a) = a(p−1)/2 = (b2) (p−1)/2 = b p−1 = 1. Thus ker(ψ) ⊂ ker(ϕ). By Lemma 4.1.4, ker(ψ) has index 2 in (Z/pZ) ∗, i.e., #(Z/pZ)∗ = 2 · # ker(ψ). Since the kernel of a homomorphism is a group, and the order of a subgroup divides the order of the group, we have either ker(ϕ) = ker(ψ) or ϕ = 1. If ϕ = 1, the polynomial x(p−1)/2 − 1 has p − 1 roots in the ﬁeld Z/pZ, which contradicts Proposition 2.5.3. Thus ker(ϕ) = ker(ψ), which proves the proposition. SAGE Example 4.2.2. From a computational point of view, Corollary 4.2.3 provides a convenient way to compute ( a p ), which we illustrate in Sage: sage: def kr(a, p): ... if Mod(a,p)^((p-1)//2) == 1: ... return 1 ... else: ... return -1 sage: for a in range(1,5): ... print a, kr(a,5) 1 1 2 -1 3 -1 4 1 Corollary 4.2.3. The equation x2 ≡ a (mod p) has no solution if and only if a (p−1)/2 ≡ −1 (mod p). Thus ( a p ) ≡ a (p−1)/2 (mod p). Proof. This follows from Proposition 4.2.1 and the fact that the polyno- mial x2 − 1 has no roots besides +1 and −1 (which follows from Proposi- tion 2.5.5). As additional computational motivation for the value of Corollary 4.2.3, note that to evaluate ( a p ) using Theorem 4.1.7 would not be practical if a and p are both very large, because it would require factoring a. However, Corollary 4.2.3 provides a method for evaluating ( a p ) without factoring a. Example 4.2.4. Suppose p = 11. By squaring each element of (Z/11Z)∗, we see that the squares modulo 11 are {1, 3, 4, 5, 9}. We compute a (p−1)/2 = a5 4.3 First Proof of Quadratic Reciprocity 75 for each a ∈ (Z/11Z) ∗ and get 15 = 1, 2 5 = −1, 35 = 1, 4 5 = 1, 5 5 = 1, 65 = −1, 7 5 = −1, 8 5 = −1, 9 5 = 1, 105 = −1. Thus the a with a 5 = 1 are {1, 3, 4, 5, 9}, just as Proposition 4.2.1 predicts. Example 4.2.5. We determine whether or not 3 is a square modulo the prime p = 726377359. sage: p = 726377359 sage: Mod(3, p)^((p-1)//2) 726377358 so 3(p−1)/2 ≡ −1 (mod 726377359). Thus 3 is not a square modulo p. This computation wasn’t diﬃcult, but it would have been tedious by hand. Since 3 is small, the Quadratic Reci- procity Law provides a way to answer this question, which could easily be carried out by hand: ( 3 726377359 ) = (−1)(3−1)/2·(726377359−1)/2 ( 726377359 3 ) = (−1) · ( 1 3 ) = −1. 4.3 First Proof of Quadratic Reciprocity Our ﬁrst proof of quadratic reciprocity is elementary. The proof involves keeping track of integer points in intervals. Proving Gauss’s lemma is the ﬁrst step; this lemma computes ( a p ) in terms of the number of integers of a certain type that lie in a certain interval. We next prove Lemma 4.3.3, which controls how the parity of the number of integer points in an inter- val changes when an endpoint of the interval is changed. We then prove that ( a p ) depends only on p modulo 4a by applying Gauss’s Lemma and keeping careful track of intervals as they are rescaled and their endpoints are changed. Finally, in Section 4.3.2, we use some basic algebra to deduce the Quadratic Reciprocity Law using the tools we’ve just developed. Our proof follows the one given in [Dav99] closely. Lemma 4.3.1 (Gauss’s Lemma). Let p be an odd prime and let a be an integer ̸≡ 0 (mod p). Form the numbers a, 2a, 3a, . . . , p − 1 2 a 76 4. Quadratic Reciprocity and reduce them modulo p to lie in the interval (− p 2 , p 2 ), i.e., for each of the above products k · a ﬁnd a number in the interval (− p 2 , p 2 ) that is congruent to k · a modulo p. Let ν be the number of negative numbers in the resulting set. Then ( a p ) = (−1) ν. Proof. In deﬁning ν, we expressed each number in S = {a, 2a, . . . , p − 1 2 a } as congruent to a number in the set {1, −1, 2, −2, . . . , p − 1 2 , − p − 1 2 } . No number 1, 2, . . . , p−1 2 appears more than once, with either choice of sign, because if it did then either two elements of S are congruent modulo p or 0 is the sum of two elements of S, and both events are impossible (the former case cannot occur because of cancellation modulo p, and in the latter case we would have ka + ja ≡ 0 (mod p) for 1 ≤ k, j ≤ (p − 1)/2, so k + j ≡ 0 (mod p), a contradiction). The resulting set must be of the form T = {ε1 · 1, ε2 · 2, . . . , ε(p−1)/2 · p − 1 2 } , where each εi is either +1 or −1. Multiplying together the elements of S and of T , we see that (1a) · (2a) · (3a) · · · ( p − 1 2 a ) ≡ (ε1 · 1) · (ε2 · 2) · · · (ε(p−1)/2 · p − 1 2 ) (mod p), so a (p−1)/2 ≡ ε1 · ε2 · · · ε(p−1)/2 (mod p). The lemma then follows from Proposition 4.2.1, since ( a p ) = a (p−1)/2. SAGE Example 4.3.2. We illustrate Gauss’s Lemma using Sage. The gauss function below prints out a list of the normalized numbers appearing in the statement of Gauss’s Lemma, and returns (−1)ν. In each case below, (−1)ν = ( a p ). sage: def gauss(a, p): ... # make the list of numbers reduced modulo p 4.3 First Proof of Quadratic Reciprocity 77 ... v = [(n*a)%p for n in range(1, (p-1)//2 + 1)] ... # normalize them to be in the range -p/2 to p/2 ... v = [(x if (x < p/2) else x - p) for x in v] ... # sort and print the resulting numbers ... v.sort() ... print v ... # count the number that are negative ... num_neg = len([x for x in v if x < 0]) ... return (-1)^num_neg sage: gauss(2, 13) [-5, -3, -1, 2, 4, 6] -1 sage: legendre_symbol(2,13) -1 sage: gauss(4, 13) [-6, -5, -2, -1, 3, 4] 1 sage: legendre_symbol(4,13) 1 sage: gauss(2,31) [-15, -13, -11, -9, -7, -5, -3, -1, 2, 4, 6, 8, 10, 12, 14] 1 sage: legendre_symbol(2,31) 1 4.3.1 Euler’s Proposition For rational numbers a, b ∈ Q, let (a, b) ∩ Z = {x ∈ Z : a ≤ x ≤ b} be the set of integers between a and b. The following lemma will help us to keep track of how many integers lie in certain intervals. Lemma 4.3.3. Let a, b ∈ Q. Then for any integer n, # ((a, b) ∩ Z) ≡ # ((a, b + 2n) ∩ Z) (mod 2) and # ((a, b) ∩ Z) ≡ # ((a − 2n, b) ∩ Z) (mod 2), provided that each interval involved in the congruence is nonempty. Note that if one of the intervals is empty, then the statement may be false; for example, if (a, b) = (−1/2, 1/2) and n = −1, then #((a, b) ∩ Z) = 1 but #(a, b − 2) ∩ Z = 0. 78 4. Quadratic Reciprocity Proof. Let ⌈x⌉ denotes the least integer ≥ x. Since n > 0, (a, b + 2n) = (a, b) ∪ [b, b + 2n), where the union is disjoint. There are 2n integers ⌈b⌉, ⌈b⌉ + 1, . . . , ⌈b⌉ + 2n − 1 in the interval [b, b + 2n), so the ﬁrst congruence of the lemma is true in this case. We also have (a, b − 2n) = (a, b) minus [b − 2n, b) and [b−2n, b) contains exactly 2n integers, so the lemma is also true when n is negative. The statement about # ((a − 2n, b) ∩ Z) is proved in a similar manner. Once we have proved the following proposition, it will be easy to deduce the Quadratic Reciprocity Law. Proposition 4.3.4 (Euler). Let p be an odd prime and let a be a positive integer with p ∤ a. If q is a prime with q ≡ ±p (mod 4a), then ( a p ) = ( a q ). Proof. We will apply Lemma 4.3.1 to compute ( a p ). Let S = {a, 2a, 3a, . . . , p − 1 2 a } and I = ( 1 2 p, p ) ∪ ( 3 2 p, 2p) ∪ · · · ∪ ((b − 1 2 ) p, bp ) , where b = 1 2 a or 1 2 (a − 1), whichever is an integer. We check that every element of S that is equivalent modulo p to some- thing in the interval (− p 2 , 0) lies in I. First suppose that b = 1 2 a. Then bp = 1 2 ap = p 2 a > p − 1 2 a, so each element of S that is equivalent modulo p to an element of (− p 2 , 0) lies in I. Next suppose that b = 1 2 (a − 1). Then bp + p 2 = a − 1 2 p + p 2 = p − 1 + a 2 > p − 1 2 a, so ((b − 1 2 )p, bp) is the last interval that could contain an element of S that reduces to (− p 2 , 0). Note that the integer endpoints of I are not in S, since 4.3 First Proof of Quadratic Reciprocity 79 those endpoints are divisible by p, but no element of S is divisible by p. Thus, by Lemma 4.3.1, ( a p ) = (−1) #(S∩I). To compute #(S ∩ I), ﬁrst rescale by a to see that #(S ∩ I) = # ( 1 a S ∩ 1 a I) = # (Z ∩ 1 a I) , where 1 a I = (( p 2a , p a ) ∪ ( 3p 2a , 2p a ) ∪ · · · ∪ ( (2b − 1)p 2a , bp a )) , 1 a S = {1, 2, 3, 4, . . . , (p − 1)/2}, and the second equality is because 1 a I ⊂ (0, (p − 1)/2 + 1/2], since pb a ≤ p a 2 a = p 2 = p − 1 2 + 1 2 . Write p = 4ac + r, and let J = (( r 2a , r a ) ∪ ( 3r 2a , 2r a ) ∪ · · · ∪ ( (2b − 1)r 2a , br a )) . The only diﬀerence between 1 a I and J is that the endpoints of intervals are changed by addition of an even integer, since r 2a − p 2a = p 2a − 2c − p 2a = −2c. By Lemma 4.3.3, ν = # ( Z ∩ 1 a I) ≡ #(Z ∩ J) (mod 2). Thus ( a p ) = (−1)ν depends only on r and a, i.e., only on p modulo 4a. Thus if q ≡ p (mod 4a), then ( a p ) = ( a q ). If q ≡ −p (mod 4a), then the only change in the above computation is that r is replaced by 4a − r. This changes J into K = (2 − r 2a , 4 − r a ) ∪ (6 − 3r 2a , 8 − 2r a ) ∪ · · · ∪ (4b − 2 − (2b − 1)r 2a , 4b − br a ) . 80 4. Quadratic Reciprocity Thus K is the same as −J, except even integers have been added to the endpoints. By Lemma 4.3.3, #(K ∩ Z) ≡ # ( 1 a I ∩ Z) (mod 2), so ( a p ) = ( a q ) again, which completes the proof. The following more careful analysis in the special case when a = 2 helps illustrate the proof of the above lemma, and the result is frequently useful in computations. For an alternative proof of the proposition, see Exercise 4.6. Proposition 4.3.5 (Legendre Lymbol of 2). Let p be an odd prime. Then ( 2 p ) = { 1 if p ≡ ±1 (mod 8) −1 if p ≡ ±3 (mod 8). Proof. When a = 2, the set S = {a, 2a, . . . , 2 · p−1 2 } is {2, 4, 6, . . . , p − 1}. We must count the parity of the number of elements of S that lie in the interval I = ( p 2 , p). Writing p = 8c + r, we have # (I ∩ S) = # ( 1 2 I ∩ Z ) = # (( p 4 , p 2 ) ∩ Z) = # ((2c + r 4 , 4c + r 2 ) ∩ Z) ≡ # (( r 4 , r 2 ) ∩ Z ) (mod 2), where the last equality comes from Lemma 4.3.3. The possibilities for r are 1, 3, 5, 7. When r = 1, the cardinality is 0; when r = 3, 5 it is 1; and when r = 7 it is 2. 4.3.2 Proof of Quadratic Reciprocity It is now straightforward to deduce the Quadratic Reciprocity Law. First Proof of Theorem 4.1.7. First suppose that p ≡ q (mod 4). By swap- ping p and q if necessary, we may assume that p > q, and write p − q = 4a. Since p = 4a + q, ( p q ) = ( 4a + q q ) = ( 4a q ) = ( 4 q ) ( a q ) = ( a q ) , and ( q p ) = ( p − 4a p ) = ( −4a p ) = ( −1 p ) · ( a p ) . 4.4 A Proof of Quadratic Reciprocity Using Gauss Sums 81 Proposition 4.3.4 implies that ( a q ) = ( a p ), since p ≡ q (mod 4a). Thus ( p q ) · ( q p ) = ( −1 p ) = (−1) p−1 2 = (−1) p−1 2 · q−1 2 , where the last equality is because p−1 2 is even if and only if q−1 2 is even. Next suppose that p ̸≡ q (mod 4), so p ≡ −q (mod 4). Write p + q = 4a. We have ( p q ) = ( 4a − q q ) = ( a q ) , and ( q p ) = ( 4a − p p ) = ( a p ) . Since p ≡ −q (mod 4a), Proposition 4.3.4 implies that ( a q ) = ( a p ). Since (−1) p−1 2 · q−1 2 = 1, the proof is complete. 4.4 A Proof of Quadratic Reciprocity Using Gauss Sums In this section, we present a beautiful proof of Theorem 4.1.7 using algebraic identities satisﬁed by sums of “roots of unity.” The objects we introduce in the proof are of independent interest, and provide a powerful tool to prove higher-degree analogs of quadratic reciprocity. (For more on higher reciprocity, see [IR90]. See also Section 6 of [IR90], on which the proof below is modeled.) Deﬁnition 4.4.1 (Root of Unity). An nth root of unity is a complex number ζ such that ζ n = 1. A root of unity ζ is a primitive nth root of unity if n is the smallest positive integer such that ζ n = 1. For example, −1 is a primitive second root of unity, and ζ = √−3−1 2 is a primitive cube root of unity. More generally, for any n ∈ N the complex number ζn = cos(2π/n) + i sin(2π/n) is a primitive nth root of unity (this follows from the identity eiθ = cos(θ)+ i sin(θ)). For the rest of this section, we ﬁx an odd prime p and the primitive pth root ζ = ζp of unity. SAGE Example 4.4.2. In Sage, use the CyclotomicField command to create an exact pth root of ζ unity. Expressions in ζ are always re-expressed as polynomials in ζ of degree at most p − 1. sage: K.<zeta> = CyclotomicField(5) sage: zeta^5 1 82 4. Quadratic Reciprocity sage: 1/zeta -zeta^3 - zeta^2 - zeta - 1 Deﬁnition 4.4.3 (Gauss Sum). Fix an odd prime p. The Gauss sum as- sociated to an integer a is ga = p−1∑ n=1 ( n p ) ζ an, where ζ = ζp = cos(2π/p) + i sin(2π/p) = e2πi/p. Note that p is implicit in the deﬁnition of ga. If we were to change p, then the Gauss sum ga associated to a would be diﬀerent. The deﬁnition of ga also depends on our choice of ζ; we’ve chosen ζ = ζp, but could have chosen a diﬀerent ζ and then ga could be diﬀerent. SAGE Example 4.4.4. We deﬁne a gauss sum function and compute the Gauss sum g2 for p = 5: sage: def gauss_sum(a,p): ... K.<zeta> = CyclotomicField(p) ... return sum(legendre_symbol(n,p) * zeta^(a*n) ... for n in range(1,p)) sage: g2 = gauss_sum(2,5); g2 2*zeta^3 + 2*zeta^2 + 1 sage: g2.complex_embedding() -2.2360679775 + 3.33066907388e-16*I sage: g2^2 5 Here, g2 is initially output as a polynomial in ζ5, so there is no loss of precision. The complex embedding command shows some embedding of g2 into the complex numbers, which is only correct to about the ﬁrst 15 digits. Note that g2 2 = 5, so g2 = −√5. We compute a graphical representation of the Gauss sum g2 as follows (see Figure 4.1): zeta = CDF(exp(2*pi*I/5)) v = [legendre_symbol(n,5) * zeta^(2*n) for n in range(1,5)] S = sum([point(tuple(z), pointsize=100) for z in v]) show(S + point(tuple(sum(v)), pointsize=100, rgbcolor=’red’)) Figure 4.1 illustrates the Gauss sum g2 for p = 5. The Gauss sum is obtained by adding the points on the unit circle, with signs as indicated, to obtain the real number − √5. This suggests the following proposition, whose proof will require some work. Proposition 4.4.5 (Gauss Sum). For any a not divisible by p, g2 a = (−1) (p−1)/2p. 4.4 A Proof of Quadratic Reciprocity Using Gauss Sums 83 -2 -1.5 -1 -0.5 -1 -0.75 -0.5 -0.25 0.25 0.5 0.75 1 FIGURE 4.1. The red dot is the Gauss sum g2 for p = 5 SAGE Example 4.4.6. We illustrate using Sage that the proposition is cor- rect for p = 7 and p = 13: sage: [gauss_sum(a, 7)^2 for a in range(1,7)] [-7, -7, -7, -7, -7, -7] sage: [gauss_sum(a, 13)^2 for a in range(1,13)] [13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13] In order to prove the proposition, we introduce a few lemmas. Lemma 4.4.7. For any integer a, p−1∑ n=0 ζ an = {p if a ≡ 0 (mod p), 0 otherwise. Proof. If a ≡ 0 (mod p), then ζ a = 1, so the sum equals the number of summands, which is p. If a ̸≡ 0 (mod p), then we use the identity xp − 1 = (x − 1)(xp−1 + · · · + x + 1) with x = ζ a. We have ζ a ̸= 1, so ζ a − 1 ̸= 0 and p−1∑ n=0 ζ an = ζ ap − 1 ζ a − 1 = 1 − 1 ζ a − 1 = 0. 84 4. Quadratic Reciprocity Lemma 4.4.8. If x and y are arbitrary integers, then p−1∑ n=0 ζ (x−y)n = {p if x ≡ y (mod p), 0 otherwise. Proof. This follows from Lemma 4.4.7 by setting a = x − y. Lemma 4.4.9. We have g0 = 0. Proof. By deﬁnition g0 = p−1∑ n=0 ( n p ) . (4.4.1) By Lemma 4.1.4, the map ( · p ) : (Z/pZ) ∗ → {±1} is a surjective homomorphism of groups. Thus, half the elements of (Z/pZ)∗ map to +1 and half map to −1 (the subgroup that maps to +1 has index 2). Since ( 0 p ) = 0, the sum (4.4.1) is 0. Lemma 4.4.10. For any integer a, ga = ( a p ) g1. Proof. When a ≡ 0 (mod p), the lemma follows from Lemma 4.4.9, so suppose that a ̸≡ 0 (mod p). Then, ( a p ) ga = ( a p ) p−1∑ n=0 ( n p ) ζ an = p−1∑ n=0 ( an p ) ζ an = p−1∑ m=0 ( m p ) ζ m = g1. Here, we use that multiplication by a is an automorphism of Z/pZ. Finally, multiply both sides by ( a p ) and use that ( a p )2 = 1. We have enough lemmas to prove Proposition 4.4.5. Proof of Proposition 4.4.5. We evaluate the sum ∑p−1 a=0 gag−a in two dif- ferent ways. By Lemma 4.4.10, since a ̸≡ 0 (mod p) we have gag−a = ( a p ) g1 ( −a p ) g1 = ( −1 p ) ( a p )2 g2 1 = (−1) (p−1)/2g2 1, where the last step follows from Proposition 4.2.1 and that ( a p ) ∈ {±1}. Thus p−1∑ a=0 gag−a = (p − 1)(−1)(p−1)/2g2 1. (4.4.2) 4.4 A Proof of Quadratic Reciprocity Using Gauss Sums 85 On the other hand, by deﬁnition gag−a = p−1∑ n=0 ( n p ) ζ an · p−1∑ m=0 ( m p ) ζ −am = p−1∑ n=0 p−1∑ m=0 ( n p ) ( m p ) ζ anζ −am = p−1∑ n=0 p−1∑ m=0 ( n p ) ( m p ) ζ an−am. Let δ(n, m) = 1 if n ≡ m (mod p) and 0 otherwise. By Lemma 4.4.8, p−1∑ a=0 gag−a = p−1∑ a=0 p−1∑ n=0 p−1∑ m=0 ( n p ) ( m p ) ζ an−am = p−1∑ n=0 p−1∑ m=0 ( n p ) ( m p ) p−1∑ a=0 ζ an−am = p−1∑ n=0 p−1∑ m=0 ( n p ) ( m p ) pδ(n, m) = p−1∑ n=0 ( n p )2 p = p(p − 1). Equate (4.4.2) and the above equality, then cancel (p − 1) to see that g2 1 = (−1) (p−1)/2p. Since a ̸≡ 0 (mod p), we have ( a p )2 = 1, so by Lemma 4.4.10, g2 a = ( a p )2 g2 1 = g2 1, and the proposition is proved. 4.4.1 Proof of Quadratic Reciprocity We are now ready to prove Theorem 4.1.7 using Gauss sums. Proof. Let q be an odd prime with q ̸= p. Set p ∗ = (−1)(p−1)/2p and recall that Proposition 4.4.5 asserts that p ∗ = g2, where g = g1 = ∑p−1 n=0 ( n p ) ζ n. 86 4. Quadratic Reciprocity Proposition 4.2.1 implies that (p∗) (q−1)/2 ≡ ( p∗ q ) (mod q). We have gq−1 = (g2)(q−1)/2 = (p∗) (q−1)/2, so multiplying both sides of the displayed equation by g yields a congruence gq ≡ g ( p∗ q ) (mod q). (4.4.3) But wait, what does this congruence mean, given that gq is not an inte- ger? It means that the diﬀerence gq − g ( p ∗ q ) is a multiple of q in the ring Z[ζ] of all polynomials in ζ with coeﬃcients in Z. The ring Z[ζ]/(q) has characteristic q, so if x, y ∈ Z[ζ], then (x + y) q ≡ xq + yq (mod q). Applying this to (4.4.3), we see that gq = (p−1∑ n=0 ( n p ) ζ n)q ≡ p−1∑ n=0 ( n p )q ζ nq ≡ p−1∑ n=0 ( n p ) ζ nq ≡ gq (mod q). By Lemma 4.4.10, gq ≡ gq ≡ ( q p ) g (mod q). Combining this with (4.4.3) yields ( q p ) g ≡ ( p∗ q ) g (mod q). Since g2 = p∗ and p ̸= q, we can cancel g from both sides to ﬁnd that( q p ) ≡ ( p∗ q ) (mod q). Since both residue symbols are ±1 and q is odd, it follows that ( q p ) = ( p ∗ q ). Finally, we note using Corollary 4.2.3 that ( p∗ q ) = ( (−1)(p−1)/2p q ) = ( −1 q )(p−1)/2 ( p q ) = (−1) q−1 2 · p−1 2 · ( p q ) . 4.5 Finding Square Roots We return in this section to the question of computing square roots. If K is a ﬁeld in which 2 ̸= 0, and a, b, c ∈ K, with a ̸= 0, then the two solutions to the quadratic equation ax2 + bx + c = 0 are x = −b ± √b2 − 4ac 2a . 4.5 Finding Square Roots 87 Now assume K = Z/pZ, with p an odd prime. Using Theorem 4.1.7, we can decide whether or not b2 − 4ac is a perfect square in Z/pZ, and hence whether or not ax2 + bx + c = 0 has a solution in Z/pZ. However, The- orem 4.1.7 says nothing about how to actually ﬁnd a solution when there is one. Also note that for this problem we do not need the full Quadratic Reciprocity Law; in practice, deciding whether an element of Z/pZ is a perfect square with Proposition 4.2.1 is quite fast, in view of Section 2.3. Suppose a ∈ Z/pZ is a nonzero quadratic residue. If p ≡ 3 (mod 4), then b = a p+1 4 is a square root of a because b 2 = a p+1 2 = a p−1 2 +1 = a p−1 2 · a = ( a p ) · a = a. We can compute b in time polynomial in the number of digits of p using the powering algorithm of Section 2.3. Suppose next that p ≡ 1 (mod 4). Unfortunately, we do not know a deterministic algorithm that takes a and p as input, outputs a square root of a modulo p when one exists, and is polynomial-time in log(p). Remark 4.5.1. There is an algorithm due to Schoof [Sch85] that computes the square root of a in time O((√(|a|) 1/2+ε · log(p))9). This beautiful al- gorithm (which makes use of elliptic curves) is not polynomial time in the sense described above, since for large a it takes exponentially longer than for small a. We next describe a probabilistic algorithm to compute a square root of a modulo p, which is very quick in practice. Recall the notion of ring from Deﬁnition 2.1.3. We will also need the notion of ring homomorphism and isomorphism. Deﬁnition 4.5.2 (Homomorphism of Rings). Let R and S be rings. A homomorphism of rings ϕ : R → S is a map such that for all a, b ∈ R, we have • ϕ(ab) = ϕ(a)ϕ(b), • ϕ(a + b) = ϕ(a) + ϕ(b), and • ϕ(1) = 1. An isomorphism ϕ : R → S of rings is a ring homomorphism that is bijective. Consider the ring R = (Z/pZ)[x]/(x2 − a) deﬁned as follows. We have R = {u + vα : u, v ∈ Z/pZ} 88 4. Quadratic Reciprocity with multiplication deﬁned by (u + vα)(z + wα) = (uz + awv) + (uw + vz)α. Here α corresponds to the class of x in R. SAGE Example 4.5.3. We deﬁne and work with the ring R above in Sage as follows (for p = 13): sage: S.<x> = PolynomialRing(GF(13)) sage: R.<alpha> = S.quotient(x^2 - 3) sage: (2+3*alpha)*(1+2*alpha) 7*alpha + 7 Let b and c be the square roots of a in Z/pZ (though we cannot easily compute b and c yet, we can consider them in order to deduce an algorithm to ﬁnd them). We have ring homomorphisms f : R → Z/pZ and g : R → Z/pZ given by f (u + vα) = u + vb and g(u + vα) = u + vc. Together, these deﬁne a ring isomorphism ϕ : R −→ Z/pZ × Z/pZ given by ϕ(u + vα) = (u + vb, u + vc). Choose in some way a random element z of (Z/pZ)∗, and deﬁne u, v ∈ Z/pZ by u + vα = (1 + zα) p−1 2 , where we compute (1+zα) p−1 2 quickly using an analog of the binary power- ing algorithm of Section 2.3.2. If v = 0, we try again with another random z. If v ̸= 0, we can quickly ﬁnd the desired square roots b and c as follows. The quantity u + vb is a (p − 1)/2 power in Z/pZ, so it equals either 0, 1, or −1, so b = −u/v, (1 − u)/v, or (−1 − u)/v, respectively. Since we know u and v, we can try each of −u/v, (1 − u)/v, and (−1 − u)/v and see which is a square root of a. Example 4.5.4. Continuing Example 4.1.8, we ﬁnd a square root of 69 modulo 389. We apply the algorithm described above in the case p ≡ 1 (mod 4). We ﬁrst choose the random z = 24 and ﬁnd that (1 + 24α) 194 = −1. The coeﬃcient of α in the power is 0, and we try again with z = 51. This time, we have (1 + 51α) 194 = 239α = u + vα. The inverse of 239 in Z/389Z is 153, so we consider the following three possibilities for a square root of 69: − u v = 0 1 − u v = 153 − 1 − u v = −153. Thus, 153 and −153 are the square roots of 69 in Z/389Z. SAGE Example 4.5.5. We implement the above algorithm in Sage and illustrate it with some examples. 4.6 Exercises 89 sage: def find_sqrt(a, p): ... assert (p-1)%4 == 0 ... assert legendre_symbol(a,p) == 1 ... S.<x> = PolynomialRing(GF(p)) ... R.<alpha> = S.quotient(x^2 - a) ... while True: ... z = GF(p).random_element() ... w = (1 + z*alpha)^((p-1)//2) ... (u, v) = (w[0], w[1]) ... if v != 0: break ... if (-u/v)^2 == a: return -u/v ... if ((1-u)/v)^2 == a: return (1-u)/v ... if ((-1-u)/v)^2 == a: return (-1-u)/v ... sage: b = find_sqrt(3,13) sage: b # random: either 9 or 3 9 sage: b^2 3 sage: b = find_sqrt(3,13) sage: b # see, it’s random 4 sage: find_sqrt(5,389) # random: either 303 or 86 303 sage: find_sqrt(5,389) # see, it’s random 86 4.6 Exercises 4.1 Calculate the following by hand: ( 3 97 ), ( 3 389 ), ( 22 11 ), and ( 5! 7 ). 4.2 Let G be an abelian group, and let n be a positive integer. (a) Prove that the map ϕ : G → G given by ϕ(x) = xn is a group homomorphism. (b) Prove that the subset H of G of squares of elements of G is a subgroup. 4.3 Use Theorem 4.1.7 to show that for p ≥ 5 prime, ( 3 p ) = { 1 if p ≡ 1, 11 (mod 12), −1 if p ≡ 5, 7 (mod 12). 90 4. Quadratic Reciprocity 4.4 (*) Use that (Z/pZ) ∗ is cyclic to give a direct proof that ( −3 p ) = 1 when p ≡ 1 (mod 3). (Hint: There is an element c ∈ (Z/pZ) ∗ of order 3. Show that (2c + 1)2 = −3.) 4.5 (*) If p ≡ 1 (mod 5), show directly that ( 5 p ) = 1 by the method of Exercise 4.4. (Hint: Let c ∈ (Z/pZ)∗ be an element of order 5. Show that (c + c 4) 2 + (c + c4) − 1 = 0, etc.) 4.6 (*) Let p be an odd prime. In this exercise, you will prove that ( 2 p ) = 1 if and only if p ≡ ±1 (mod 8). (a) Prove that x = 1 − t2 1 + t2 , y = 2t 1 + t2 is a parameterization of the set of solutions to x2 + y2 ≡ 1 (mod p), in the sense that the solutions (x, y) ∈ Z/pZ are in bijection with the t ∈ Z/pZ∪{∞} such that 1+t2 ̸≡ 0 (mod p). Here, t = ∞ corresponds to the point (−1, 0). (Hint: if (x1, y1) is a solution, consider the line y = t(x + 1) through (x1, y1) and (−1, 0), and solve for x1, y1 in terms of t.) (b) Prove that the number of solutions to x 2 + y2 ≡ 1 (mod p) is p + 1 if p ≡ 3 (mod 4) and p − 1 if p ≡ 1 (mod 4). (c) Consider the set S of pairs (a, b) ∈ (Z/pZ)∗ × (Z/pZ) ∗ such that a + b = 1 and ( a p ) = ( b p ) = 1. Prove that #S = (p + 1 − 4)/4 if p ≡ 3 (mod 4) and #S = (p − 1 − 4)/4 if p ≡ 1 (mod 4). Conclude that #S is odd if and only if p ≡ ±1 (mod 8). (d) The map σ(a, b) = (b, a) that swaps coordinates is a bijection of the set S. It has exactly one ﬁxed point if and only if there is an a ∈ Z/pZ such that 2a = 1 and ( a p ) = 1. Also, prove that 2a = 1 has a solution a ∈ Z/pZ with ( a p ) = 1 if and only if ( 2 p ) = 1. (e) Finish by showing that σ has exactly one ﬁxed point if and only if #S is odd, i.e., if and only if p ≡ ±1 (mod 8). Remark: The method of proof of this exercise can be generalized to give a proof of the full Quadratic Reciprocity Law. 4.7 How many natural numbers x < 2 13 satisfy the equation x2 ≡ 5 (mod 213 − 1)? You may assume that 213 − 1 is prime. 4.6 Exercises 91 4.8 Find the natural number x < 97 such that x ≡ 4 48 (mod 97). Note that 97 is prime. 4.9 In this problem, we will formulate an analog of quadratic reciprocity for a symbol like ( a q ), but without the restriction that q be a prime. Suppose n is an odd positive integer, which we factor as ∏k i=1 p ei i . We deﬁne the Jacobi symbol ( a n ) as follows: ( a n ) = k∏ i=1 ( a pi )ei . (a) Give an example to show that ( a n ) = 1 need not imply that a is a perfect square modulo n. (b) (*) Let n be odd and a and b be integers. Prove that the following holds: i. ( a n ) ( b n ) = ( ab n ). (Thus a 7→ ( a n ) induces a homomorphism from (Z/nZ) ∗ to {±1}.) ii. ( −1 n ) ≡ n (mod 4). iii. ( 2 n ) = 1 if n ≡ ±1 (mod 8) and −1 otherwise. iv. Assume a is positive and odd. Then ( a n ) = (−1) a−1 2 · n−1 2 ( n a ) 4.10 (*) Prove that for any n ∈ Z, the integer n2 + n + 1 does not have any divisors of the form 6k − 1. 92 4. Quadratic Reciprocity This is page 93 Printer: Opaque this 5 Continued Fractions The golden ratio 1+√5 2 is equal to the inﬁnite fraction 1 + 1 1 + 1 1 + 1 1 + · · · , and the fraction 103993 33102 = 3.14159265301190260407 . . . is an excellent approximation to π. Both of these observations are explained by continued fractions. Continued fractions are theoretically beautiful and provide tools that yield powerful algorithms for solving problems in number theory. For ex- ample, continued fractions provide a fast way to write a prime—even a hundred digit prime—as a sum of two squares, when possible. Continued fractions are thus a beautiful algorithmic and conceptual tool in number theory that has many applications. For example, they provide a surprisingly eﬃcient way to recognize a rational number given just the ﬁrst few digits of its decimal expansion, and they give a sense in which e is “less complicated” than π (see Example 5.3.4 and Section 5.4). In Section 5.2, we study continued fractions of ﬁnite length and lay the foundations for our later investigations. In Section 5.3, we give the contin- ued fraction procedure, which associates to a real number x a continued fraction that converges to x. In Section 5.5, we characterize (eventually) 94 5. Continued Fractions periodic continued fractions as the continued fractions of nonrational roots of quadratic polynomials, then discuss an unsolved mystery concerning continued fractions of roots of irreducible polynomials of degree greater than 2. We conclude the chapter with applications of continued fractions to recognizing approximations to rational numbers (Section 5.6) and writ- ing integers as sums of two squares (Section 5.7). The reader is encouraged to read more about continued fractions in [HW79, Ch. X], [Khi63], [Bur89, §13.3], and [NZM91, Ch. 7]. 5.1 The Deﬁnition A continued fraction is an expression of the form a0 + 1 a1 + 1 a2 + 1 a3 + · · · . In this book, we will assume that the ai are real numbers and ai > 0 for i ≥ 1, and the expression may or may not go on indeﬁnitely. More general notions of continued fractions have been extensively studied, but they are beyond the scope of this book. We will be most interested in the case when the ai are all integers. We denote the continued fraction displayed above by [a0, a1, a2, . . .]. For example, [1, 2] = 1 + 1 2 = 3 2 , [3, 7, 15, 1, 292] = 3 + 1 7 + 1 15 + 1 1 + 1 292 = 103993 33102 = 3.14159265301190260407 . . . , 5.2 Finite Continued Fractions 95 and [2, 1, 2, 1, 1, 4, 1, 1, 6] = 2 + 1 1 + 1 2 + 1 1 + 1 1 + 1 4 + 1 1 + 1 1 + 1 6 = 1264 465 = 2.7182795698924731182795698 . . . The second two examples were chosen to foreshadow that continued frac- tions can be used to obtain good rational approximations to irrational numbers. Note that the ﬁrst approximates π, and the second e. 5.2 Finite Continued Fractions This section is about continued fractions of the form [a0, a1, . . . , am] for some m ≥ 0. We give an inductive deﬁnition of numbers pn and qn such that for all n ≤ m [a0, a1, . . . , an] = pn qn . (5.2.1) We then give related formulas for the determinants of the 2 × 2 matrices( pn pn−1 qn qn−1 ) and ( pn pn−2 qn qn−2 ), which we will repeatedly use to deduce prop- erties of the sequence of partial convergents [a0, . . . , ak]. We will use Al- gorithm 1.1.13 to prove that every rational number is represented by a continued fraction, as in (5.2.1). Deﬁnition 5.2.1 (Finite Continued Fraction). A ﬁnite continued fraction is an expression a0 + 1 a1 + 1 a2 + 1 · · · + 1 an where each am is a real number and am > 0 for all m ≥ 1. Deﬁnition 5.2.2 (Simple Continued Fraction). A simple continued frac- tion is a ﬁnite or inﬁnite continued fraction in which the ai are all integers. 96 5. Continued Fractions To get a feeling for continued fractions, observe that [a0] = a0, [a0, a1] = a0 + 1 a1 = a0a1 + 1 a1 , [a0, a1, a2] = a0 + 1 a1 + 1 a2 = a0a1a2 + a0 + a2 a1a2 + 1 . Also, [a0, a1, . . . , an−1, an] = [ a0, a1, . . . , an−2, an−1 + 1 an ] = a0 + 1 [a1, . . . , an] = [a0, [a1, . . . , an]]. SAGE Example 5.2.3. The continued fraction command computes con- tinued fractions: sage: continued_fraction(17/23) [0, 1, 2, 1, 5] sage: continued_fraction(e) [2, 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, 1, 1, 10, 1, 1, 12, 1, 1, 11] Use the optional second argument bits = n to determine the precision (in bits) of the input number that is used to compute the continued fraction. sage: continued_fraction(e, bits=20) [2, 1, 2, 1, 1, 4, 1, 1, 6] sage: continued_fraction(e, bits=30) [2, 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, 1, 1] You can obtain the value of a continued fraction and even do arithmetic with continued fractions: sage: a = continued_fraction(17/23); a [0, 1, 2, 1, 5] sage: a.value() 17/23 sage: b = continued_fraction(6/23); b [0, 3, 1, 5] sage: a + b [1] 5.2 Finite Continued Fractions 97 5.2.1 Partial Convergents Fix a ﬁnite continued fraction [a0, . . . , am]. We do not assume at this point that the ai are integers. Deﬁnition 5.2.4 (Partial convergents). For 0 ≤ n ≤ m, the nth conver- gent of the continued fraction [a0, . . . , am] is [a0, . . . , an]. These convergents for n < m are also called partial convergents. For each n with −2 ≤ n ≤ m, deﬁne real numbers pn and qn as follows: p−2 = 0, p−1 = 1, p0 = a0, · · · pn = anpn−1 + pn−2 · · · , q−2 = 1, q−1 = 0, q0 = 1, · · · qn = anqn−1 + qn−2 · · · . Proposition 5.2.5 (Partial Convergents). For n ≥ 0 with n ≤ m we have [a0, . . . , an] = pn qn . Proof. We use induction. The assertion is obvious when n = 0, 1. Suppose the proposition is true for all continued fractions of length n − 1. Then [a0, . . . , an] = [a0, . . . , an−2, an−1 + 1 an ] = (an−1 + 1 an ) pn−2 + pn−3 (an−1 + 1 an ) qn−2 + qn−3 = (an−1an + 1)pn−2 + anpn−3 (an−1an + 1)qn−2 + anqn−3 = an(an−1pn−2 + pn−3) + pn−2 an(an−1qn−2 + qn−3) + qn−2 = anpn−1 + pn−2 anqn−1 + qn−2 = pn qn . SAGE Example 5.2.6. If c is a continued fraction, use c.convergents() to compute a list of the partial convergents of c. sage: c = continued_fraction(pi,bits=33); c [3, 7, 15, 1, 292, 2] sage: c.convergents() [3, 22/7, 333/106, 355/113, 103993/33102, 208341/66317] As we will see, the convergents of a continued fraction are the best ratio- nal approximations to the value of the continued fraction. In the example above, the listed convergents are the best rational approximations of π with given denominator size. 98 5. Continued Fractions Proposition 5.2.7. For n ≥ 0 with n ≤ m we have pnqn−1 − qnpn−1 = (−1)n−1 (5.2.2) and pnqn−2 − qnpn−2 = (−1) nan. (5.2.3) Equivalently, pn qn − pn−1 qn−1 = (−1)n−1 · 1 qnqn−1 and pn qn − pn−2 qn−2 = (−1) n · an qnqn−2 . Proof. The case for n = 0 is obvious from the deﬁnitions. Now suppose n > 0 and the statement is true for n − 1. Then pnqn−1 − qnpn−1 = (anpn−1 + pn−2)qn−1 − (anqn−1 + qn−2)pn−1 = pn−2qn−1 − qn−2pn−1 = −(pn−1qn−2 − pn−2qn−1) = −(−1)n−2 = (−1)n−1. This completes the proof of (5.2.2). For (5.2.3), we have pnqn−2 − pn−2qn = (anpn−1 + pn−2)qn−2 − pn−2(anqn−1 + qn−2) = an(pn−1qn−2 − pn−2qn−1) = (−1)nan. Remark 5.2.8. Expressed in terms of matrices, the proposition asserts that the determinant of ( pn pn−1 qn qn−1 ) is (−1)n−1, and of ( pn pn−2 qn qn−2 ) is (−1)nan. SAGE Example 5.2.9. We use Sage to verify Proposition 5.2.7 for the ﬁrst few terms of the continued fraction of π. sage: c = continued_fraction(pi); c [3, 7, 15, 1, 292, 1, 1, 1, 2, 1, 3, 1, 14, 3] sage: for n in range(-1, len(c)): ... print c.pn(n)*c.qn(n-1) - c.qn(n)*c.pn(n-1), 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 sage: for n in range(len(c)): ... print c.pn(n)*c.qn(n-2) - c.qn(n)*c.pn(n-2), 3 -7 15 -1 292 -1 1 -1 2 -1 3 -1 14 -3 Corollary 5.2.10 (Convergents in lowest terms). If [a0, a1, . . . , am] is a simple continued fraction, so each ai is an integer, then the pn and qn are integers and the fraction pn/qn is in lowest terms. 5.2 Finite Continued Fractions 99 Proof. It is clear that the pn and qn are integers, from the formula that deﬁnes them. If d is a positive divisor of both pn and qn, then d | (−1)n−1, so d = 1. SAGE Example 5.2.11. We illustrate Corollary 5.2.10 using Sage. sage: c = continued_fraction([1,2,3,4,5]) sage: c.convergents() [1, 3/2, 10/7, 43/30, 225/157] sage: [c.pn(n) for n in range(len(c))] [1, 3, 10, 43, 225] sage: [c.qn(n) for n in range(len(c))] [1, 2, 7, 30, 157] 5.2.2 The Sequence of Partial Convergents Let [a0, . . . , am] be a continued fraction and for n ≤ m let cn = [a0, . . . , an] = pn qn denote the nth convergent. Recall that by deﬁnition of continued frac- tion, an > 0 for n > 0, which gives the partial convergents of a contin- ued fraction additional structure. For example, the partial convergents of [2, 1, 2, 1, 1, 4, 1, 1, 6] are 2, 3, 8/3, 11/4, 19/7, 87/32, 106/39, 193/71, 1264/465. To make the size of these numbers clearer, we approximate them using decimals. We also underline every other number, to illustrate some extra structure. 2, 3, 2.66667, 2.75000, 2.71429, 2.71875, 2.71795, 2.71831, 2.71828 The underlined numbers are smaller than all of the nonunderlined numbers, and the sequence of underlined numbers is strictly increasing, whereas the nonunderlined numbers strictly decrease. SAGE Example 5.2.12. Figure 5.1 illustrates the above pattern on another continued fraction using Sage. sage: c = continued_fraction([1,1,1,1,1,1,1,1]) sage: v = [(i, c.pn(i)/c.qn(i)) for i in range(len(c))] sage: P = point(v, rgbcolor=(0,0,1), pointsize=40) sage: L = line(v, rgbcolor=(0.5,0.5,0.5)) sage: L2 = line([(0,c.value()),(len(c)-1,c.value())], \\ ... thickness=0.5, rgbcolor=(0.7,0,0)) sage: (L+L2+P).show(xmin=0,ymin=1) 100 5. Continued Fractions 2 4 6 1.5 2 FIGURE 5.1. Graph of a Continued Fraction We next prove that this extra structure is a general phenomenon. Proposition 5.2.13 (How Convergents Converge). The even indexed con- vergents c2n increase strictly with n, and the odd indexed convergents c2n+1 decrease strictly with n. Also, the odd indexed convergents c2n+1 are greater than all of the even indexed convergents c2m. Proof. The an are positive for n ≥ 1, so the qn are positive. By Proposi- tion 5.2.7, for n ≥ 2, cn − cn−2 = (−1)n · an qnqn−2 , which proves the ﬁrst claim. Suppose for the sake of contradiction that there exist integers r and m such that c2m+1 < c2r. Proposition 5.2.7 implies that for n ≥ 1, cn − cn−1 = (−1)n−1 · 1 qnqn−1 has sign (−1) n−1, so for all s ≥ 0 we have c2s+1 > c2s. Thus it is impossible that r = m. If r < m, then by what we proved in the ﬁrst paragraph, c2m+1 < c2r < c2m, a contradiction (with s = m). If r > m, then c2r+1 < c2m+1 < c2r, which is also a contradiction (with s = r). 5.2.3 Every Rational Number is Represented Proposition 5.2.14 (Rational Continued Fractions). Every nonzero ra- tional number can be represented by a simple continued fraction. 5.3 Inﬁnite Continued Fractions 101 Proof. Without loss of generality, we may assume that the rational number is a/b, with b ≥ 1 and gcd(a, b) = 1. Algorithm 1.1.13 gives: a = b · a0 + r1, 0 < r1 < b b = r1 · a1 + r2, 0 < r2 < r1 · · · rn−2 = rn−1 · an−1 + rn, 0 < rn < rn−1 rn−1 = rn · an + 0. Note that ai > 0 for i > 0 (also rn = 1, since gcd(a, b) = 1). Rewrite the equations as follows: a/b = a0 + r1/b = a0 + 1/(b/r1), b/r1 = a1 + r2/r1 = a1 + 1/(r1/r2), r1/r2 = a2 + r3/r2 = a2 + 1/(r2/r3), · · · rn−1/rn = an. It follows that a b = [a0, a1, . . . , an]. The proof of Proposition 5.2.14 leads to an algorithm for computing the continued fraction of a rational number. A nonzero rational number can be represented in exactly two ways; for example, 2 = [1, 1] = [2] (see Exercise 5.2). 5.3 Inﬁnite Continued Fractions This section begins with the continued fraction procedure, which associates a sequence a0, a1, . . . of integers to a real number x. After giving several examples, we prove that x = limn→∞[a0, a1, . . . , an] by proving that the odd and even partial convergents become arbitrarily close to each other. We also show that if a0, a1, . . . is any inﬁnite sequence of positive integers, then the sequence of cn = [a0, a1, . . . , an] converges. More generally, if an is an arbitrary sequence of positive reals such that ∑∞ n=0 an diverges then (cn) converges. 5.3.1 The Continued Fraction Procedure Let x ∈ R and write x = a0 + t0 102 5. Continued Fractions with a0 ∈ Z and 0 ≤ t0 < 1. We call the number a0 the ﬂoor of x, and we also sometimes write a0 = ⌊x⌋. If t0 ̸= 0, write 1 t0 = a1 + t1 with a1 ∈ N and 0 ≤ t1 < 1. Thus t0 = 1 a1+t1 = [0, a1 + t1], which is a continued fraction expansion of t0, which need not be simple. Continue in this manner so long as tn ̸= 0 writing 1 tn = an+1 + tn+1 with an+1 ∈ N and 0 ≤ tn+1 < 1. We call this procedure, which associates to a real number x the sequence of integers a0, a1, a2, . . ., the continued fraction process. Example 5.3.1. Let x = 8 3 . Then x = 2 + 2 3 , so a0 = 2 and t0 = 2 3 . Then 1 t0 = 3 2 = 1 + 1 2 , so a1 = 1 and t1 = 1 2 . Then 1 t1 = 2, so a2 = 2, t2 = 0, and the sequence terminates. Notice that 8 3 = [2, 1, 2], so the continued fraction procedure produces the continued fraction of 8 3 . Example 5.3.2. Let x = 1+ √5 2 . Then x = 1 + −1 + √5 2 , so a0 = 1 and t0 = −1+ √5 2 . We have 1 t0 = 2 −1 + √5 = −2 − 2√5 −4 = 1 + √5 2 , so a1 = 1 and t1 = −1+ √5 2 . Likewise, an = 1 for all n. As we will see below, the following exciting equality makes sense. 1 + √5 2 = 1 + 1 1 + 1 1 + 1 1 + 1 1 + 1 1 + · · · SAGE Example 5.3.3. The equality of Example 5.3.2 is consistent with the following Sage calculation: 5.3 Inﬁnite Continued Fractions 103 sage: def cf(bits): ... x = (1 + sqrt(RealField(bits)(5))) / 2 ... return continued_fraction(x) sage: cf(10) [1, 1, 1, 1, 1, 1, 1, 3] sage: cf(30) [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2] sage: cf(50) [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] Example 5.3.4. Suppose x = e = 2.71828182 . . .. Using the continued frac- tion procedure, we ﬁnd that a0, a1, a2, . . . = 2, 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, 1, 1, 10, . . . For example, a0 = 2 is the ﬂoor of 2. Subtracting 2 and inverting, we obtain 1/0.718 . . . = 1.3922 . . ., so a1 = 1. Subtracting 1 and inverting yields 1/0.3922 . . . = 2.5496 . . ., so a2 = 2. We will prove in Section 5.4 that the continued fraction of e obeys a simple pattern. The 5th partial convergent of the continued fraction of e is [a0, a1, a2, a3, a4, a5] = 87 32 = 2.71875, which is a good rational approximation to e, in the sense that \f \f \f \f 87 32 − e\f \f \f \f = 0.000468 . . . . Note that 0.000468 . . . < 1/322 = 0.000976 . . ., which illustrates the bound in Corollary 5.3.11. Let’s do the same thing with π = 3.14159265358979 . . .. Applying the continued fraction procedure, we ﬁnd that the continued fraction of π is a0, a1, a2, . . . = 3, 7, 15, 1, 292, 1, 1, 1, 2, 1, 3, 1, 14, . . . The ﬁrst few partial convergents are 3, 22 7 , 333 106 , 355 113 , 103993 33102 , · · · These are good rational approximations to π; for example, 103993 33102 = 3.14159265301 . . . . Notice that the continued fraction of e exhibits a nice pattern (see Sec- tion 5.4 for a proof), whereas the continued fraction of π exhibits no pattern 104 5. Continued Fractions that is obvious to the author. The continued fraction of π has been exten- sively studied, and over 20 million terms have been computed. The data suggests that every integer appears inﬁnitely often as a partial convergent. For much more about the continued fraction of π, or of any other sequence in this book, type the ﬁrst few terms of the sequence into [Slo]. 5.3.2 Convergence of Inﬁnite Continued Fractions Lemma 5.3.5. For every n such that an is deﬁned, we have x = [a0, a1, . . . , an + tn], and if tn ̸= 0, then x = [a0, a1, . . . , an, 1 tn ]. Proof. We use induction. The statements are both true when n = 0. If the second statement is true for n − 1, then x = [ a0, a1, . . . , an−1, 1 tn−1 ] = [a0, a1, . . . , an−1, an + tn] = [ a0, a1, . . . , an−1, an, 1 tn ] . Similarly, the ﬁrst statement is true for n if it is true for n − 1. Theorem 5.3.6 (Continued Fraction Limit). Let a0, a1, . . . be a sequence of integers such that an > 0 for all n ≥ 1, and for each n ≥ 0, set cn = [a0, a1, . . . an]. Then lim n→∞ cn exists. Proof. For any m ≥ n, the number cn is a partial convergent of [a0, . . . , am]. By Proposition 5.2.13, the even convergents c2n form a strictly increasing sequence and the odd convergents c2n+1 form a strictly decreasing sequence. Moreover, the even convergents are all ≤ c1 and the odd convergents are all ≥ c0. Hence α0 = limn→∞ c2n and α1 = limn→∞ c2n+1 both exist, and α0 ≤ α1. Finally, by Proposition 5.2.7 |c2n − c2n−1| = 1 q2n · q2n−1 ≤ 1 2n(2n − 1) → 0, so α0 = α1. We deﬁne [a0, a1, . . .] = lim n→∞ cn. 5.3 Inﬁnite Continued Fractions 105 Example 5.3.7. We illustrate the theorem with x = π. As in the proof of Theorem 5.3.6, let cn be the nth partial convergent to π. The cn with n odd converge down to π c1 = 3.1428571 . . . , c3 = 3.1415929 . . . , c5 = 3.1415926 . . . whereas the cn with n even converge up to π c2 = 3.1415094 . . . , c4 = 3.1415926 . . . , c6 = 3.1415926 . . . . Theorem 5.3.8. Let a0, a1, a2, . . . be a sequence of real numbers such that an > 0 for all n ≥ 1, and for each n ≥ 0, set cn = [a0, a1, . . . an]. Then lim n→∞ cn exists if and only if the sum ∑∞ n=0 an diverges. Proof. We only prove that if ∑ an diverges, then limn→∞ cn exists. A proof of the converse can be found in [Wal48, Ch. 2, Thm. 6.1]. Let qn be the sequence of “denominators” of the partial convergents, as deﬁned in Section 5.2.1, so q−2 = 1, q−1 = 0, and for n ≥ 0, we have qn = anqn−1 + qn−2. As we saw in the proof of Theorem 5.3.6, the limit limn→∞ cn exists pro- vided that the sequence {qnqn−1} diverges to positive inﬁnity. For n even, qn = anqn−1 + qn−2 = anqn−1 + an−2qn−3 + qn−4 = anqn−1 + an−2qn−3 + an−4qn−5 + qn−6 = anqn−1 + an−2qn−3 + · · · + a2q1 + q0 and for n odd, qn = anqn−1 + an−2qn−3 + · · · + a1q0 + q−1. Since an > 0 for n > 0, the sequence {qn} is increasing, so qi ≥ 1 for all i ≥ 0. Applying this fact to the above expressions for qn, we see that for n even qn ≥ an + an−2 + · · · + a2, and for n odd qn ≥ an + an−2 + · · · + a1. If ∑ an diverges, then at least one of ∑ a2n or ∑ a2n+1 must diverge. The above inequalities then imply that at least one of the sequences {q2n} or {q2n+1} diverge to inﬁnity. Since {qn} is an increasing sequence, it follows that {qnqn−1} diverges to inﬁnity. 106 5. Continued Fractions Example 5.3.9. Let an = 1 n log(n) for n ≥ 2 and a0 = a1 = 0. By the integral test, ∑ an diverges, so by Theorem 5.3.8, the continued fraction [a0, a1, a2, . . .] converges. This convergence is very slow, since, e.g. [a0, a1, . . . , a9999] = 0.5750039671012225425930 . . . yet [a0, a1, . . . , a10000] = 0.7169153932917378550424 . . . . Theorem 5.3.10. Let x ∈ R be a real number. Then x is the value of the (possibly inﬁnite) simple continued fraction [a0, a1, a2, . . .] produced by the continued fraction procedure. Proof. If the sequence is ﬁnite, then some tn = 0 and the result follows by Lemma 5.3.5. Suppose the sequence is inﬁnite. By Lemma 5.3.5, x = [a0, a1, . . . , an, 1 tn ]. By Proposition 5.2.5 (which we apply in a case when the partial quotients of the continued fraction are not integers), we have x = 1 tn · pn + pn−1 1 tn · qn + qn−1 . Thus, if cn = [a0, a1, . . . , an], then x − cn = x − pn qn = 1 tn pnqn + pn−1qn − 1 tn pnqn − pnqn−1 qn ( 1 tn qn + qn−1) . = pn−1qn − pnqn−1 qn ( 1 tn qn + qn−1) = (−1)n qn ( 1 tn qn + qn−1) . Thus |x − cn| = 1 qn ( 1 tn qn + qn−1) < 1 qn(an+1qn + qn−1) = 1 qn · qn+1 ≤ 1 n(n + 1) → 0. 5.4 The Continued Fraction of e 107 In the inequality, we use that an+1 is the integer part of 1 tn , and is hence ≤ 1 tn < 1, since tn < 1. This corollary follows from the proof of Theorem 5.3.10. Corollary 5.3.11 (Convergence of continued fraction). Let a0, a1, . . . de- ﬁne a simple continued fraction, and let x = [a0, a1, . . .] ∈ R be its value. Then for all m, \f \f \f \fx − pm qm \f \f \f \f < 1 qm · qm+1 . Proposition 5.3.12. If x is a rational number, then the sequence a0, a1, . . . produced by the continued fraction procedure terminates. Proof. Let [b0, b1, . . . , bm] be the continued fraction representation of x that we obtain using Algorithm 1.1.13, so the bi are the partial quotients at each step. If m = 0, then x is an integer, so we may assume m > 0. Then x = b0 + 1/[b1, . . . , bm]. If [b1, . . . , bm] = 1, then m = 1 and b1 = 1, which will not happen using Algorithm 1.1.13, since it would give [b0+1] for the continued fraction of the integer b0 + 1. Thus [b1, . . . , bm] > 1, so in the continued fraction algorithm we choose a0 = b0 and t0 = 1/[b1, . . . , bm]. Repeating this argument enough times proves the claim. 5.4 The Continued Fraction of e The continued fraction expansion of e begins [2, 1, 2, 1, 1, 4, 1, 1, 6, . . .]. The obvious pattern in fact does continue, as Euler proved in 1737 (see [Eul85]), and we will prove in this section. As an application, Euler gave a proof that e is irrational by noting that its continued fraction is inﬁnite. The proof we give below draws heavily on the proof in [Coh], which describes a slight variant of a proof of Hermite (see [Old70]). The continued fraction representation of e is also treated in the German book [Per57], but the proof requires substantial background from elsewhere in that text. 5.4.1 Preliminaries First, we write the continued fraction of e in a slightly diﬀerent form. Instead of [2, 1, 2, 1, 1, 4, . . .], we can start the sequence of coeﬃcients [1, 0, 1, 1, 2, 1, 1, 4, . . .] to make the pattern the same throughout. (Everywhere else in this chap- ter we assume that the partial quotients an for n ≥ 1 are positive, but 108 5. Continued Fractions temporarily relax that condition here and allow a1 = 0.) The numerators and denominators of the convergents given by this new sequence satisfy a simple recurrence. Using ri as a stand-in for pi or qi, we have r3n = r3n−1 + r3n−2 r3n−1 = r3n−2 + r3n−3 r3n−2 = 2(n − 1)r3n−3 + r3n−4. Our ﬁrst goal is to collapse these three recurrences into one recurrence that only makes mention of r3n, r3n−3, and r3n−6. We have r3n = r3n−1 + r3n−2 = (r3n−2 + r3n−3) + (2(n − 1)r3n−3 + r3n−4) = (4n − 3)r3n−3 + 2r3n−4. This same method of simpliﬁcation also shows us that r3n−3 = 2r3n−7 + (4n − 7)r3n−6. To get rid of 2r3n−4 in the ﬁrst equation, we make the substitutions 2r3n−4 = 2(r3n−5 + r3n−6) = 2((2(n − 2)r3n−6 + r3n−7) + r3n−6) = (4n − 6)r3n−6 + 2r3n−7. Substituting for 2r3n−4 and then 2r3n−7, we ﬁnally have the needed col- lapsed recurrence, r3n = 2(2n − 1)r3n−3 + r3n−6. 5.4.2 Two Integral Sequences We deﬁne the sequences xn = p3n, yn = q3n. Since the 3n-convergents will converge to the same real number that the n convergents do, xn/yn also converges to the limit of the continued fraction. Each sequence {xn}, {yn} will obey the recurrence relation derived in the previous section (where zn is a stand-in for xn or yn): zn = 2(2n − 1)zn−1 + zn−2, for all n ≥ 2. (5.4.1) The two sequences can be found in Table 5.1. (The initial conditions x0 = 1, x1 = 3, y0 = y1 = 1 are taken straight from the ﬁrst few convergents of the original continued fraction.) Notice that since we are skipping several convergents at each step, the ratio xn/yn converges to e very quickly. 5.4 The Continued Fraction of e 109 TABLE 5.1. Convergents n 0 1 2 3 4 · · · xn 1 3 19 193 2721 · · · yn 1 1 7 71 1001 · · · xn/yn 1 3 2.714 . . . 2.71830 . . . 2.7182817 . . . · · · 5.4.3 A Related Sequence of Integrals Now, we deﬁne a sequence of real numbers T0, T1, T2, . . . by the following integrals: Tn = ∫ 1 0 tn(t − 1)n n! etdt. Below, we compute the ﬁrst two terms of this sequence explicitly. (When we compute T1, we are doing the integration by parts u = t(t−1), dv = etdt. Since the integral runs from 0 to 1, the boundary condition is 0 when evaluated at each of the endpoints. This vanishing will be helpful when we do the integral in the general case.) T0 = ∫ 1 0 e tdt = e − 1, T1 = ∫ 1 0 t(t − 1)etdt = − ∫ 1 0 ((t − 1) + t)etdt = −(t − 1)et\f \f \f \f \f 1 0 − tet\f \f \f \f \f 1 0 + 2 ∫ 1 0 etdt = −1 − e + 2(e − 1) = e − 3. The reason that we deﬁned this series now becomes apparent: T0 = y0e − x0 and T1 = y1e − x1. In general, it will be true that Tn = yne − xn. We will now prove this fact. It is clear that if Tn were to satisfy the same recurrence that the xi and yi do in (5.4.1), then the above statement holds by induction. (The initial conditions are correct, as needed.) So, we simplify Tn by integrating by 110 5. Continued Fractions parts twice in succession: Tn = ∫ 1 0 tn(t − 1)n n! etdt = − ∫ 1 0 tn−1(t − 1)n + tn(t − 1)n−1 (n − 1)! etdt = ∫ 1 0 ( tn−2(t − 1)n (n − 2)! + n tn−1(t − 1)n−1 (n − 1)! + n tn−1(t − 1)n−1 (n − 1)! + tn(t − 1) n−2 (n − 2)! )e tdt = 2nTn−1 + ∫ 1 0 tn−2(t − 1)n−2 (n − 2)! (2t2 − 2t + 1) etdt = 2nTn−1 + 2 ∫ 1 0 tn−1(t − 1)n−1 (n − 2)! e tdt + ∫ 1 0 t n−2(t − 1) n−2 (n − 2)! etdt = 2nTn−1 + 2(n − 1)Tn−1 + Tn−2 = 2(2n − 1)Tn−1 + Tn−2, which is the desired recurrence. Therefore, Tn = yne − xn. To conclude the proof, we consider the limit as n approaches inﬁnity: lim n→∞ ∫ 1 0 tn(t − 1)n n! etdt = 0, by inspection, and therefore lim n→∞ xn yn = lim n→∞(e − Tn yn ) = e. Therefore, the ratio xn/yn approaches e, and the continued fraction expan- sion [2, 1, 2, 1, 1, 4, 1, 1, . . .] does in fact converge to e. 5.4.4 Extensions of the Argument The method of proof of this section generalizes to show that the continued fraction expansion of e1/n is [1, (n − 1), 1, 1, (3n − 1), 1, 1, (5n − 1), 1, 1, (7n − 1), . . .] for all n ∈ N (see Exercise 5.6). 5.5 Quadratic Irrationals The main result of this section is that the continued fraction expansion of a number is eventually repeating if and only if the number is a quadratic 5.5 Quadratic Irrationals 111 irrational. This can be viewed as an analog for continued fractions of the familiar fact that the decimal expansion of x is eventually repeating if and only if x is rational. The proof that continued fractions of quadratic irra- tionals eventually repeats is surprisingly diﬃcult and involves an interesting ﬁniteness argument. Section 5.5.2 emphasizes our striking ignorance about continued fractions of real roots of irreducible polynomials over Q of degree bigger than 2. Deﬁnition 5.5.1 (Quadratic Irrational). A quadratic irrational is a real number α ∈ R that is irrational and satisﬁes a quadratic polynomial with coeﬃcients in Q. Thus, for example, (1 + √5)/2 is a quadratic irrational. Recall that 1 + √5 2 = [1, 1, 1, . . .]. The continued fraction of √2 is [1, 2, 2, 2, 2, 2, . . .], and the continued frac- tion of √389 is [19, 1, 2, 1, 1, 1, 1, 2, 1, 38, 1, 2, 1, 1, 1, 1, 2, 1, 38, . . .]. Does the [1, 2, 1, 1, 1, 1, 2, 1, 38] pattern repeat over and over again? SAGE Example 5.5.2. We compute more terms of the continued fraction expansion of √389 using Sage: sage: def cf_sqrt_d(d, bits): ... x = sqrt(RealField(bits)(d)) ... return continued_fraction(x) sage: cf_sqrt_d(389,50) [19, 1, 2, 1, 1, 1, 1, 2, 1, 38, 1, 2, 1, 1, 1, 1, 2, 1, 38] sage: cf_sqrt_d(389,100) [19, 1, 2, 1, 1, 1, 1, 2, 1, 38, 1, 2, 1, 1, 1, 1, 2, 1, 38, 1, 2, 1, 1, 1, 1, 2, 1, 38, 1, 2, 1, 1, 1, 1, 2, 1, 38, 1, 2, 1, 1] 5.5.1 Periodic Continued Fractions Deﬁnition 5.5.3 (Periodic Continued Fraction). A periodic continued fraction is a continued fraction [a0, a1, . . . , an, . . .] such that an = an+h for some ﬁxed positive integer h and all suﬃciently large n. We call the minimal such h the period of the continued fraction. 112 5. Continued Fractions Example 5.5.4. Consider the periodic continued fraction [1, 2, 1, 2, . . .] = [1, 2]. What does it converge to? We have [1, 2] = 1 + 1 2 + 1 1 + 1 2 + 1 1 + · · · , so if α = [1, 2] then α = 1 + 1 2 + 1 α = 1 + 1 2α + 1 α = 1 + α 2α + 1 = 3α + 1 2α + 1 Thus 2α2 − 2α − 1 = 0, so α = 1 + √3 2 . Theorem 5.5.5 (Periodic Characterization). An inﬁnite simple continued fraction is periodic if and only if it represents a quadratic irrational. Proof. (=⇒) First suppose that [a0, a1, . . . , an, an+1, . . . , an+h] is a periodic continued fraction. Set α = [an+1, an+2, . . .]. Then α = [an+1, . . . , an+h, α], so by Proposition 5.2.5 α = αpn+h + pn+h−1 αqn+h + qn+h−1 . Here we use that α is the last partial quotient. Thus, α satisﬁes a quadratic equation with coeﬃcients in Q. Computing as in Example 5.5.4 and ratio- nalizing the denominators, and using that the ai are all integers, shows that [a0, a1, . . .] = [a0, a1, . . . , an, α] = a0 + 1 a1 + 1 a2 + · · · + 1 α is of the form c + dα, with c, d ∈ Q, so [a0, a1, . . .] also satisﬁes a quadratic polynomial over Q. 5.5 Quadratic Irrationals 113 The continued fraction procedure applied to the value of an inﬁnite sim- ple continued fraction yields that continued fraction back, so by Proposi- tion 5.3.12, α ̸∈ Q because it is the value of an inﬁnite continued fraction. (⇐=) Suppose α ∈ R is an irrational number that satisﬁes a quadratic equation aα2 + bα + c = 0 (5.5.1) with a, b, c ∈ Z and a ̸= 0. Let [a0, a1, . . .] be the continued fraction expan- sion of α. For each n, let rn = [an, an+1, . . .], so α = [a0, a1, . . . , an−1, rn]. We will prove periodicity by showing that the set of rn’s is ﬁnite. If we have shown ﬁniteness, then there exists n, h > 0 such that rn = rn+h, so [a0, . . . , an−1, rn] = [a0, . . . , an−1, an, . . . , an+h−1, rn+h] = [a0, . . . , an−1, an, . . . , an+h−1, rn] = [a0, . . . , an−1, an, . . . , an+h−1, an, . . . , an+h−1, rn+h] = [a0, . . . , an−1, an, . . . , an+h−1]. It remains to show there are only ﬁnitely many distinct rn. We have α = pn qn = rnpn−1 + pn−2 rnqn−1 + qn−2 . Substituting this expression for α into the quadratic equation (5.5.1), we see that Anr2 n + Bnrn + Cn = 0, where An = ap2 n−1 + bpn−1qn−1 + cq2 n−1, Bn = 2apn−1pn−2 + b(pn−1qn−2 + pn−2qn−1) + 2cqn−1qn−2, and Cn = ap2 n−2 + bpn−2qn−2 + cq2 n−2. Note that An, Bn, Cn ∈ Z, that Cn = An−1, and that B2 n − 4AnCn = (b2 − 4ac)(pn−1qn−2 − qn−1pn−2) 2 = b2 − 4ac. Recall from the proof of Theorem 5.3.10 that \f \f \f \fα − pn−1 qn−1 \f \f \f \f < 1 qnqn−1 . 114 5. Continued Fractions Thus, |αqn−1 − pn−1| < 1 qn < 1 qn−1 , so pn−1 = αqn−1 + δ qn−1 with |δ| < 1. Hence, An = a ( αqn−1 + δ qn−1 )2 + b (αqn−1 + δ qn−1 ) qn−1 + cq2 n−1 = (aα2 + bα + c)q2 n−1 + 2aαδ + a δ2 q2 n−1 + bδ = 2aαδ + a δ2 q2 n−1 + bδ. Thus, |An| = \f \f \f \f2aαδ + a δ2 q2 n−1 + bδ\f \f \f \f < 2|aα| + |a| + |b|. We conclude that there are only ﬁnitely many possibilities for the integer An. Also, |Cn| = |An−1| and |Bn| = √ b2 − 4(ac − AnCn), so there are only ﬁnitely many triples (An, Bn, Cn), and hence only ﬁnitely many possibilities for rn as n varies, which completes the proof. (The proof above closely follows [HW79, Thm. 177, pg.144–145].) 5.5.2 Continued Fractions of Algebraic Numbers of Higher Degree Deﬁnition 5.5.6 (Algebraic Number). An algebraic number is a root of a polynomial f ∈ Q[x]. Open Problem 5.5.7. Give a simple description of the complete contin- ued fractions expansion of the algebraic number 3√2. It begins [1, 3, 1, 5, 1, 1, 4, 1, 1, 8, 1, 14, 1, 10, 2, 1, 4, 12, 2, 3, 2, 1, 3, 4, 1, 1, 2, 14, 3, 12, 1, 15, 3, 1, 4, 534, 1, 1, 5, 1, 1, . . .] The author does not see a pattern, and the 534 reduces his conﬁdence that he will. Lang and Trotter (see [LT72]) analyzed many terms of the continued fraction of 3√2 statistically, and their work suggests that 3√2 has an “unusual” continued fraction; later work in [LT74] suggests that maybe it does not. 5.6 Recognizing Rational Numbers 115 Khintchine (see [Khi63, pg. 59]) No properties of the representing continued fractions, analogous to those which have just been proved, are known for algebraic numbers of higher degree [as of 1963]. [...] It is of interest to point out that up till the present time no continued fraction development of an algebraic number of higher degree than the second is known [emphasis added]. It is not even known if such a development has bounded elements. Generally speaking the problems associated with the continued fraction expansion of al- gebraic numbers of degree higher than the second are extremely diﬃcult and virtually unstudied. Richard Guy (see [Guy94, pg. 260]) Is there an algebraic number of degree greater than two whose simple continued fraction has unbounded partial quotients? Does every such number have unbounded partial quotients? Baum and Sweet [BS76] answered the analog of Richard Guy’s question, but with algebraic numbers replaced by elements of a ﬁeld K other than Q. (The ﬁeld K is F2((1/x)), the ﬁeld of Laurent series in the variable 1/x over the ﬁnite ﬁeld with two elements. An element of K is a polynomial in x plus a formal power series in 1/x.) They found an α of degree 3 over K whose continued fraction has all terms of bounded degree, and other elements of various degrees greater than 2 over K whose continued fractions have terms of unbounded degree. 5.6 Recognizing Rational Numbers Suppose that somehow you can compute approximations to some rational number, and want to ﬁgure what the rational number probably is. Com- puting the approximation to high enough precision to ﬁnd a period in the decimal expansion is not a good approach, because the period can be huge (see below). A much better approach is to compute the simple continued fraction of the approximation, and truncate it before a large partial quo- tient an, then compute the value of the truncated continued fraction. This results in a rational number that has a relatively small numerator and de- nominator, and is close to the approximation of the rational number, since the tail end of the continued fraction is at most 1/an. We begin with a contrived example, which illustrates how to recognize a rational number. Let x = 9495/3847 = 2.46815700545879906420587470756433584611385 . . . . 116 5. Continued Fractions The continued fraction of the truncation 2.468157005458799064 is [2, 2, 7, 2, 1, 5, 1, 1, 1, 1, 1, 1, 328210621945, 2, 1, 1, 1, . . .] We have [2, 2, 7, 2, 1, 5, 1, 1, 1, 1, 1, 1] = 9495 3847 . Notice that no repetition is evident in the digits of x given above, though we know that the decimal expansion of x must be eventually periodic, since all decimal expansions of rational numbers are eventually periodic. In fact, the length of the period of the decimal expansion of 1/3847 is 3846, which is the order of 10 modulo 3847 (see Exercise 5.7). For a slightly less contrived application of this idea, suppose f (x) ∈ Z[x] is a polynomial with integer coeﬃcients, and we know for some reason that one root of f is a rational number. We can ﬁnd that rational number, by using Newton’s method to approximate each root, and continued fractions to decide whether each root is a rational number (we can substitute the value of the continued fraction approximation into f to see if it is actually a root). One could also use the well-known Rational Root Theorem, which asserts that any rational root n/d of f , with n, d ∈ Z coprime, has the property that n divides the constant term of f and d the leading coeﬃcient of f . However, using that theorem to ﬁnd n/d would require factoring the constant and leading terms of f , which could be completely impractical if they have a few hundred digits (see Section 1.1.3). In contrast, New- ton’s method and continued fractions should quickly ﬁnd n/d, assuming the degree of f isn’t too large. For example, suppose f = 3847x2 − 14808904x + 36527265. To apply Newton’s method, let x0 be a guess for a root of f . Iterate using the recur- rence xn+1 = xn − f (xn) f ′(xn) . Choosing x0 = 0, approximations of the ﬁrst two iterates are x1 = 2.466574501394566404103909378, and x2 = 2.468157004807401923043166846. The continued fraction of the approximations x1 and x2 are [2, 2, 6, 1, 47, 2, 1, 4, 3, 1, 5, 8, 2, 3] and [2, 2, 7, 2, 1, 5, 1, 1, 1, 1, 1, 1, 103, 8, 1, 2, 3, . . .]. Truncating the continued fraction of x2 before 103 gives [2, 2, 7, 2, 1, 5, 1, 1, 1, 1, 1, 1], which evaluates to 9495/3847, which is a rational root of f . 5.7 Sums of Two Squares 117 SAGE Example 5.6.1. We do the above calculation using SAGE. First we implement the Newton iteration: sage: def newton_root(f, iterates=2, x0=0, prec=53): ... x = RealField(prec)(x0) ... R = PolynomialRing(ZZ,’x’) ... f = R(f) ... g = f.derivative() ... for i in range(iterates): ... x = x - f(x)/g(x) ... return x Next we run the Newton iteration, and compute the continued fraction of the result: sage: a = newton_root(3847*x^2 - 14808904*x + 36527265); a 2.46815700480740 sage: cf = continued_fraction(a); cf [2, 2, 7, 2, 1, 5, 1, 1, 1, 1, 1, 1, 103, 8, 1, 2, 3, 1, 1] We truncate the continued fraction and compute its value. sage: c = cf[:12]; c [2, 2, 7, 2, 1, 5, 1, 1, 1, 1, 1, 1] sage: c.value() 9495/3847 Another computational application of continued fractions, which we can only hint at, is that there are functions in certain parts of advanced number theory (that are beyond the scope of this book) that take rational values at certain points, and which can only be computed eﬃciently via approx- imations; using continued fractions as illustrated above to evaluate such functions is crucial. 5.7 Sums of Two Squares In this section, we apply continued fractions to prove the following theorem. Theorem 5.7.1. A positive integer n is a sum of two squares if and only if all prime factors of p | n such that p ≡ 3 (mod 4) have even exponent in the prime factorization of n. We ﬁrst consider some examples. Notice that 5 = 12 + 22 is a sum of two squares, but 7 is not a sum of two squares. Since 2001 is divisible by 3 (because 2 + 1 is divisible by 3), but not by 9 (since 2 + 1 is not), Theorem 5.7.1 implies that 2001 is not a sum of two squares. The theorem also implies that 2 · 3 4 · 5 · 72 · 13 is a sum of two squares. 118 5. Continued Fractions SAGE Example 5.7.2. We use Sage to write a short program that naively determines whether or not an integer n is a sum of two squares, and if so returns a, b such that a 2 + b2 = n. sage: def sum_of_two_squares_naive(n): ... for i in range(int(sqrt(n))): ... if is_square(n - i^2): ... return i, (Integer(n-i^2)).sqrt() ... return \"%s is not a sum of two squares\"%n We next use our function in a couple of cases. sage: sum_of_two_squares_naive(23) ’23 is not a sum of two squares’ sage: sum_of_two_squares_naive(389) (10, 17) sage: sum_of_two_squares_naive(2007) ’2007 is not a sum of two squares’ sage: sum_of_two_squares_naive(2008) ’2008 is not a sum of two squares’ sage: sum_of_two_squares_naive(2009) (28, 35) sage: 28^2 + 35^2 2009 sage: sum_of_two_squares_naive(2*3^4*5*7^2*13) (189, 693) Deﬁnition 5.7.3 (Primitive). A representation n = x2 + y2 is primitive if x and y are coprime. Lemma 5.7.4. If n is divisible by a prime p ≡ 3 (mod 4), then n has no primitive representations. Proof. Suppose n has a primitive representation, n = x2 + y2, and let p be any prime factor of n. Then p | x2 + y2 and gcd(x, y) = 1, so p ∤ x and p ∤ y. Since Z/pZ is a ﬁeld, we may divide by y2 in the equation x2 + y2 ≡ 0 (mod p) to see that (x/y)2 ≡ −1 (mod p). Thus the Legendre symbol ( −1 p ) equals +1. However, by Proposition 4.2.1, ( −1 p ) = (−1)(p−1)/2 so ( −1 p ) = 1 if and only if (p − 1)/2 is even, which is to say p ≡ 1 (mod 4). 5.7 Sums of Two Squares 119 Proof of Theorem 5.7.1 (=⇒). Suppose that p ≡ 3 (mod 4) is a prime, that p r | n but pr+1 ∤ n with r odd, and that n = x2 + y2. Letting d = gcd(x, y), we have x = dx ′, y = dy′, and n = d 2n′ with gcd(x′, y′) = 1 and (x′)2 + (y′) 2 = n′. Because r is odd, p | n′, so Lemma 5.7.4 implies that gcd(x′, y′) > 1, which is a contradiction. To prepare for our proof of the implication (⇐=) of Theorem 5.7.1, we reduce the problem to the case when n is prime. Write n = n 2 1n2, where n2 has no prime factors p ≡ 3 (mod 4). It suﬃces to show that n2 is a sum of two squares, since (x2 1 + y2 1)(x2 2 + y2 2) = (x1x2 − y1y2)2 + (x1y2 + x2y1) 2, (5.7.1) so a product of two numbers that are sums of two squares is also a sum of two squares. Since 2 = 1 2 + 1 2 is a sum of two squares, it suﬃces to show that any prime p ≡ 1 (mod 4) is a sum of two squares. Lemma 5.7.5. If x ∈ R and n ∈ N, then there is a fraction a b in lowest terms such that 0 < b ≤ n and \f \f \fx − a b \f \f \f ≤ 1 b(n + 1) . Proof. Consider the continued fraction [a0, a1, . . .] of x. By Corollary 5.3.11, for each m \f \f \f \fx − pm qm \f \f \f \f < 1 qm · qm+1 . Since qm+1 ≥ qm + 1 and q0 = 1, either there exists an m such that qm ≤ n < qm+1, or the continued fraction expansion of x is ﬁnite and n is larger than the denominator of the rational number x, in which case we take a b = x and are done. In the ﬁrst case, \f \f \f \fx − pm qm \f \f \f \f < 1 qm · qm+1 ≤ 1 qm · (n + 1) , so a b = pm qm satisﬁes the conclusion of the lemma. Proof of Theorem 5.7.1 (⇐=). As discussed above, it suﬃces to prove that any prime p ≡ 1 (mod 4) is a sum of two squares. Since p ≡ 1 (mod 4), (−1)(p−1)/2 = 1, 120 5. Continued Fractions Proposition 4.2.1 implies that −1 is a square modulo p; i.e., there exists r ∈ Z such that r2 ≡ −1 (mod p). Lemma 5.7.5, with n = ⌊√p⌋ and x = − r p , implies that there are integers a, b such that 0 < b < √p and \f \f \f \f− r p − a b \f \f \f \f ≤ 1 b(n + 1) < 1 b√p . Letting c = rb + pa, we have that |c| < pb b√p = p √p = √p so 0 < b 2 + c 2 < 2p. But c ≡ rb (mod p), so b2 + c2 ≡ b 2 + r2b2 ≡ b2(1 + r2) ≡ 0 (mod p). Thus b2 + c 2 = p. Remark 5.7.6. Our proof of Theorem 5.7.1 leads to an eﬃcient algorithm to compute a representation of any p ≡ 1 (mod 4) as a sum of two squares. SAGE Example 5.7.7. We next use Sage and Theorem 5.7.1 to give an eﬃcient algorithm for writing a prime p ≡ 1 (mod 4) as a sum of two squares. First we implement the algorithm that comes out of the proof of the theorem. sage: def sum_of_two_squares(p): ... p = Integer(p) ... assert p%4 == 1, \"p must be 1 modulo 4\" ... r = Mod(-1,p).sqrt().lift() ... v = continued_fraction(-r/p) ... n = floor(sqrt(p)) ... for x in v.convergents(): ... c = r*x.denominator() + p*x.numerator() ... if -n <= c and c <= n: ... return (abs(x.denominator()),abs(c)) Next we use the algorithm to write the ﬁrst 10-digit prime ≡ 1 (mod 4) as a sum of two squares: sage: p = next_prime(next_prime(10^10)) sage: sum_of_two_squares(p) (55913, 82908) The above calculation was essentially instantanoues. If instead we use the naive algorithm from before, it takes several seconds to write p as a sum of two squares. sage: sum_of_two_squares_naive(p) (55913, 82908) 5.8 Exercises 121 5.8 Exercises 5.1 If cn = pn/qn is the nth convergent of [a0, a1, . . . , an] and a0 > 0, show that [an, an−1, . . . , a1, a0] = pn pn−1 and [an, an−1, . . . , a2, a1] = qn qn−1 . (Hint: In the ﬁrst case, notice that pn pn−1 = an + pn−2 pn−1 = an + 1 pn−1 pn−2 .) 5.2 Show that every nonzero rational number can be represented in ex- actly two ways by a ﬁnite simple continued fraction. (For example, 2 can be represented by [1, 1] and [2], and 1/3 by [0, 3] and [0, 2, 1].) 5.3 Evaluate the inﬁnite continued fraction [2, 1, 2, 1]. 5.4 Determine the inﬁnite continued fraction of 1+√13 2 . 5.5 Let a0 ∈ R and a1, . . . , an and b be positive real numbers. Prove that [a0, a1, . . . , an + b] < [a0, a1, . . . , an] if and only if n is odd. 5.6 (*) Extend the method presented in the text to show that the con- tinued fraction expansion of e1/k is [1, (k − 1), 1, 1, (3k − 1), 1, 1, (5k − 1), 1, 1, (7k − 1), . . .] for all k ∈ N. (a) Compute p0, p3, q0, and q3 for the above continued fraction. Your answers should be in terms of k. (b) Condense three steps of the recurrence for the numerators and denominators of the above continued fraction. That is, produce a simple recurrence for r3n in terms of r3n−3 and r3n−6 whose coeﬃcients are polynomials in n and k. (c) Deﬁne a sequence of real numbers by Tn(k) = 1 kn ∫ 1/k 0 (kt) n(kt − 1)n n! etdt. i. Compute T0(k), and verify that it equals q0e1/k − p0. ii. Compute T1(k), and verify that it equals q3e1/k − p3. 122 5. Continued Fractions iii. Integrate Tn(k) by parts twice in succession, as in Sec- tion 5.4, and verify that Tn(k), Tn−1(k), and Tn−2(k) satisfy the recurrence produced in part 6b, for n ≥ 2. (d) Conclude that the continued fraction [1, (k − 1), 1, 1, (3k − 1), 1, 1, (5k − 1), 1, 1, (7k − 1), . . .] represents e1/k. 5.7 Let d be an integer that is coprime to 10. Prove that the decimal expansion of 1 d has a period equal to the order of 10 modulo d. (Hint: For every positive integer r, we have 1 1−10r = ∑ n≥1 10 −rn.) 5.8 Find a positive integer that has at least three diﬀerent representations as the sum of two squares, disregarding signs and the order of the summands. 5.9 Show that if a natural number n is the sum of two rational squares it is also the sum of two integer squares. 5.10 (*) Let p be an odd prime. Show that p ≡ 1, 3 (mod 8) if and only if p can be written as p = x2 +2y2 for some choice of integers x and y. 5.11 Prove that of any four consecutive integers, at least one is not repre- sentable as a sum of two squares. This is page 123 Printer: Opaque this 6 Elliptic Curves Elliptic curves are number theoretic objects that are central to both pure and applied number theory. Deep problems in number theory such as the congruent number problem—which integers are the area of a right triangle with rational side lengths?—translate naturally into questions about ellip- tic curves. Other questions, such as the famous Birch and Swinnerton-Dyer conjecture, describe mysterious structure that mathematicians expect el- liptic curves to have. One can also associate ﬁnite abelian groups to elliptic curves, and in many cases these groups are well suited to the construc- tion of cryptosystems. In particular, elliptic curves are widely believed to provide good security with smaller key sizes, something that is useful in many applications, for example, if we are going to print an encryption key on a postage stamp, it is helpful if the key is short! Morover, there is a way to use elliptic curves to factor integers, which plays a crucial role in sophisticated attacks on the RSA public-key cryptosystem of Section 3.3. This chapter is a brief introduction to elliptic curves that builds on the ideas of Chapters 1–3 and introduces several deep theorems and ideas that we will not prove. In Section 6.1, we deﬁne elliptic curves and draw some pictures of them, and then in Section 6.2 we describe how to put a group structure on the set of points on an elliptic curve. Sections 6.3 and 6.4 are about how to apply elliptic curves to two cryptographic problems— constructing public-key cryptosystems and factoring integers. Finally, in Section 6.5, we consider elliptic curves over the rational numbers, and ex- plain a deep connection between elliptic curves and a 1,000-year old un- solved problem. 124 6. Elliptic Curves -3 -2 -1 1 2 3 4 -6 -5 -4 -3 -2 -1 1 2 3 4 5 6 FIGURE 6.1. The elliptic curve y2 = x3 − 5x + 4 over R 6.1 The Deﬁnition Deﬁnition 6.1.1 (Elliptic Curve). An elliptic curve over a ﬁeld K is a curve deﬁned by an equation of the form y2 = x3 + ax + b, where a, b ∈ K and −16(4a 3 + 27b2) ̸= 0. The condition that −16(4a 3 + 27b 2) ̸= 0 implies that the curve has no “singular points,” which will be essential for the applications we have in mind (see Exercise 6.1). SAGE Example 6.1.2. We use the EllipticCurve command to create an elliptic curve over the rational ﬁeld Q and draw the plot in Figure 6.1. sage: E = EllipticCurve([-5, 4]) sage: E Elliptic Curve defined by y^2 = x^3 - 5*x + 4 over Rational Field sage: P = E.plot(thickness=4,rgbcolor=(0.1,0.7,0.1)) sage: P.show(figsize=[4,6]) We will use elliptic curves over ﬁnite ﬁelds to factor integers in Section 6.3 and to construct cryptosystems in Section 6.4. The following Sage code creates an elliptic curve over the ﬁnite ﬁeld of order 37 and plots it, as illustrated in Figure 6.2. 6.2 The Group Structure on an Elliptic Curve 125 sage: E = EllipticCurve(GF(37), [1,0]) sage: E Elliptic Curve defined by y^2 = x^3 + x over Finite Field of size 37 sage: E.plot(pointsize=45) 5 10 15 20 25 30 35 5 10 15 20 25 30 35 FIGURE 6.2. The elliptic curve y2 = x3 + x over Z/37Z In Section 6.2, we will put a natural abelian group structure on the set E(K) = {(x, y) ∈ K × K : y2 = x3 + ax + b} ∪ {O} of K-rational points on an elliptic curve E over K. Here, O may be thought of as a point on E “at inﬁnity.” Figure 6.2 contains a plot of the points of y2 = x3 + x over the ﬁnite ﬁeld Z/37Z, though note that we do not explicitly draw the point at O at inﬁnity. Remark 6.1.3. If K has characteristic 2 (i.e., we have 1 + 1 = 0 in K), then for any choice of a, b, the quantity −16(4a 3 + 27b2) ∈ K is 0, so according to Deﬁnition 6.1.1 there are no elliptic curves over K. There is a similar problem in characteristic 3. If we instead consider equations of the form y2 + a1xy + a3y = x3 + a2x2 + a4x + a6, we obtain a more general deﬁnition of elliptic curves, which correctly allows for elliptic curves in characteristics 2 and 3; these elliptic curves are popular in cryptography because arithmetic on them is often easier to eﬃciently implement on a computer. 6.2 The Group Structure on an Elliptic Curve Let E be an elliptic curve over a ﬁeld K, given by an equation y2 = x3 + ax + b. We begin by deﬁning a binary operation + on E(K). 126 6. Elliptic Curves Algorithm 6.2.1 (Elliptic Curve Group Law). Given P1, P2 ∈ E(K), this algorithm computes a third point R = P1 + P2 ∈ E(K). 1. [Is Pi = O?] If P1 = O set R = P2 or if P2 = O set R = P1 and terminate. Otherwise write (xi, yi) = Pi. 2. [Negatives] If x1 = x2 and y1 = −y2, set R = O and terminate. 3. [Compute λ] Set λ = { (3x2 1 + a)/(2y1) if P1 = P2, (y1 − y2)/(x1 − x2) otherwise. 4. [Compute Sum] Then R = (λ 2 − x1 − x2, −λx3 − ν), where ν = y1 − λx1 and x3 = λ2 − x1 − x2 is the x-coordinate of R. Note that in Step 3, if P1 = P2, then y1 ̸= 0; otherwise, we would have terminated in the previous step. Theorem 6.2.2. The binary operation + deﬁned in Algorithm 6.2.1 en- dows the set E(K) with an abelian group structure, with identity O. Before discussing why the theorem is true, we reinterpret + geometri- cally, so that it will be easier for us to visualize. We obtain the sum P1 + P2 by ﬁnding the third point P3 of intersection between E and the line L deter- mined by P1 and P2, then reﬂecting P3 about the x-axis. (This description requires suitable interpretation in cases 1 and 2, and when P1 = P2.) This is illustrated in Figure 6.3, in which (0, 2) + (1, 0) = (3, 4) on y2 = x3 − 5x + 4. SAGE Example 6.2.3. We create the elliptic curve y2 = x3 −5x+4 in Sage, then add together P = (1, 0) and Q = (0, 2). We also compute P +P , which is the point O at inﬁnity, which is represented in Sage by (0 : 1 : 0), and compute the sum P + Q + Q + Q + Q, which is surprisingly large. sage: E = EllipticCurve([-5,4]) sage: P = E([1,0]); Q = E([0,2]) sage: P + Q (3 : 4 : 1) sage: P + P (0 : 1 : 0) sage: P + Q + Q + Q + Q (350497/351649 : 16920528/208527857 : 1) To further clarify the above geometric interpretation of the group law, we prove the following proposition. Proposition 6.2.4 (Geometric Group Law). Suppose Pi = (xi, yi), i = 1, 2 are distinct points on an elliptic curve y2 = x3 + ax + b, and that x1 ̸= x2. Let L be the unique line through P1 and P2. Then L intersects the graph of E at exactly one other point Q = (λ2 − x1 − x2, λx3 + ν) , where λ = (y1 − y2)/(x1 − x2) and ν = y1 − λx1. 6.2 The Group Structure on an Elliptic Curve 127 -3 -2 -1 1 2 3 4 -6 -4 -2 2 4 6 8 FIGURE 6.3. The Group Law: (1, 0) + (0, 2) = (3, 4) on y2 = x 3 − 5x + 4 Proof. The line L through P1, P2 is y = y1 + (x − x1)λ. Substituting this into y2 = x3 + ax + b, we get (y1 + (x − x1)λ)2 = x3 + ax + b. Simplifying, we get f (x) = x3 − λ2x2 + · · · = 0, where we omit the co- eﬃcients of x and the constant term since they will not be needed. Since P1 and P2 are in L ∩ E, the polynomial f has x1 and x2 as roots. By Proposition 2.5.3, the polynomial f can have at most three roots. Writing f = ∏ (x − xi) and equating terms, we see that x1 + x2 + x3 = λ 2. Thus, x3 = λ2 − x1 − x2, as claimed. Also, from the equation for L we see that y3 = y1 + (x3 − x1)λ = λx3 + ν, which completes the proof. To prove Theorem 6.2.2 means to show that + satisﬁes the three axioms of an abelian group with O as identity element: existence of inverses, com- mutativity, and associativity. The existence of inverses follows immediately from the deﬁnition, since (x, y) + (x, −y) = O. Commutativity is also clear from the deﬁnition of group law, since in Parts 1–3, the recipe is unchanged if we swap P1 and P2; in Part 4 swapping P1 and P2 does not change the line determined by P1 and P2, so by Proposition 6.2.4 it does not change the sum P1 + P2. It is more diﬃcult to prove that + satisﬁes the associative axiom, i.e., that (P1 + P2) + P3 = P1 + (P2 + P3). This fact can be understood from at least three points of view. One is to reinterpret the group law geometrically (extending Proposition 6.2.4 to all cases), and thus transfer the problem to a question in plane geometry. This approach is beautifully explained 128 6. Elliptic Curves with exactly the right level of detail in [ST92, §I.2]. Another approach is to use the formulas that deﬁne + to reduce associativity to checking speciﬁc algebraic identities; this is something that would be extremely tedious to do by hand, but can be done using a computer (also tedious). A third approach (see [Sil86] or [Har77]) is to develop a general theory of “divisors on algebraic curves,” from which associativity of the group law falls out as a natural corollary. The third approach is the best, because it opens up many new vistas; however, we will not pursue it further because it is beyond the scope of this book. SAGE Example 6.2.5. In the following Sage session, we use the formula from Algorithm 6.2.1 to verify that the group law holds for any choice of points P1, P2, P3 on any elliptic curve over Q such that the points P1, P2, P3, P1 + P2, P2 + P3 are all distinct and nonzero. We deﬁne a poly- nomial ring R in 8 variables. sage: R.<x1,y1,x2,y2,x3,y3,a,b> = QQ[] We deﬁne the relations the xi will satisfy, and a quotient ring Q in which those relations are satisﬁed. (Quotients of polynomial rings are a general- ization of the construction Z/nZ that may be viewed as the quotient of the ring Z of integers by the relation that sets n to equal 0.) sage: rels = [y1^2 - (x1^3 + a*x1 + b), ... y2^2 - (x2^3 + a*x2 + b), ... y3^2 - (x3^3 + a*x3 + b)] ... sage: Q = R.quotient(rels) We deﬁne the group operation, which assumes the points are distinct. sage: def op(P1,P2): ... x1,y1 = P1; x2,y2 = P2 ... lam = (y1 - y2)/(x1 - x2); nu = y1 - lam*x1 ... x3 = lam^2 - x1 - x2; y3 = -lam*x3 - nu ... return (x3, y3) We deﬁne three points, add them together via P1 + (P2 + P3) and (P1 + (P2 + P3)), and observe that the results are the same modulo the relations. sage: P1 = (x1,y1); P2 = (x2,y2); P3 = (x3,y3) sage: Z = op(P1, op(P2,P3)); W = op(op(P1,P2),P3) sage: (Q(Z[0].numerator()*W[0].denominator() - ... Z[0].denominator()*W[0].numerator())) == 0 True sage: (Q(Z[1].numerator()*W[1].denominator() - ... Z[1].denominator()*W[1].numerator())) == 0 True 6.3 Integer Factorization Using Elliptic Curves 129 6.3 Integer Factorization Using Elliptic Curves In 1987, Hendrik Lenstra published the landmark paper [Len87] that intro- duces and analyzes the Elliptic Curve Method (ECM), which is a powerful algorithm for factoring integers using elliptic curves. Lenstra’s method is also described in [ST92, §IV.4], [Dav99, §VIII.5], and [Coh93, §10.3]. Lenstra’s algorithm is well suited for ﬁnding “medium-sized” factors of an integer N , which to- day means between 10 to 40 decimal digits. The ECM method is not directly used for factoring RSA challenge numbers (see Section 1.1.3), but it is used on auxiliary numbers as a crucial step in the “number ﬁeld sieve,” which is the best known al- gorithm for hunting for such factorizations. Also, implementation of ECM typically requires little memory. H. Lenstra 6.3.1 Pollard’s (p − 1)-Method Lenstra’s discovery of ECM was inspired by Pollard’s (p−1)-method, which we describe in this section. Deﬁnition 6.3.1 (Power Smooth). Let B be a positive integer. If n is a positive integer with prime factorization n = ∏ p ei i , then n is B-power smooth if p ei i ≤ B for all i. For example, 30 = 2·3·5 is B power smooth for B = 5, 7, but 150 = 2·3·5 2 is not 5-power smooth (it is B = 25-power smooth). We will use the following algorithm in both the Pollard p − 1 and elliptic curve factorization methods. Algorithm 6.3.2 (Least Common Multiple of First B Integers). Given a positive integer B, this algorithm computes the least common multiple of the positive integers up to B. 1. [Sieve] Using, for example, the prime sieve (Algorithm 1.2.3), compute a list P of all primes p ≤ B. 2. [Multiply] Compute and output the product ∏ p∈P p ⌊logp(B)⌋. Proof. Set m = lcm(1, 2, . . . , B). Then, ordp(m) = max({ordp(n) : 1 ≤ n ≤ B}) = ordp(p r), where pr is the largest power of p that satisﬁes p r ≤ B. Since p r ≤ B < pr+1, we have r = ⌊logp(B)⌋. 130 6. Elliptic Curves SAGE Example 6.3.3. We implement Algorithm 6.3.2 in Sage and compute the least common multiple for B = 100 using both the above algorithm and a naive algorithm. We use math.log below so that logp(B) is computed quickly using double precision numbers. sage: def lcm_upto(B): ... return prod([p^int(math.log(B)/math.log(p)) ... for p in prime_range(B+1)]) sage: lcm_upto(10^2) 69720375229712477164533808935312303556800 sage: LCM([1..10^2]) 69720375229712477164533808935312303556800 Algorithm 6.3.2 as implemented above in Sage takes about a second for B = 10 6. Let N be a positive integer that we wish to factor. We use the Pollard (p − 1)-method to look for a nontrivial factor of N as follows. First, we choose a positive integer B, usually with at most six digits. Suppose that there is a prime divisor p of N such that p − 1 is B-power smooth. We try to ﬁnd p using the following strategy. If a > 1 is an integer not divisible by p, then by Theorem 2.1.20, a p−1 ≡ 1 (mod p). Let m = lcm(1, 2, 3, . . . , B), and observe that our assumption that p − 1 is B-power smooth implies that p − 1 | m, so a m ≡ 1 (mod p). Thus p | gcd(a m − 1, N ) > 1. If gcd(a m−1, N ) < N also then gcd(a m−1, N ) is a nontrivial factor of N . If gcd(a m − 1, N ) = N , then a m ≡ 1 (mod qr) for every prime power divisor qr of N . In this case, repeat the above steps but with a smaller choice of B or possibly a diﬀerent choice of a. Also, it is a good idea to check from the start whether or not N is not a perfect power M r and, if so, replace N by M . We formalize the algorithm as follows: Algorithm 6.3.4 (Pollard p − 1 Method). Given a positive integer N and a bound B, this algorithm attempts to ﬁnd a nontrivial factor g of N . (Each prime p | g is likely to have the property that p − 1 is B-power smooth.) 1. [Compute lcm] Use Algorithm 6.3.2 to compute m = lcm(1, 2, . . . , B). 2. [Initialize] Set a = 2. 3. [Power and gcd] Compute x = am − 1 (mod N ) and g = gcd(x, N ). 4. [Finished?] If g ̸= 1 or N , output g and terminate. 6.3 Integer Factorization Using Elliptic Curves 131 5. [Try Again?] If a < 10 (say), replace a by a + 1 and go to step 3. Otherwise, terminate. For ﬁxed B, Algorithm 6.3.4 often splits N when N is divisible by a prime p such that p − 1 is B-power smooth. Approximately 15 percent of primes p in the interval from 10 15 and 10 15 + 10000 are such that p − 1 is 106 power smooth, so the Pollard method with B = 10 6 already fails nearly 85 percent of the time at ﬁnding 15-digit primes in this range (see also Exercise 6.10). We will not analyze Pollard’s method further, since it was mentioned here only to set the stage for the elliptic curve factorization method. The following examples illustrate the Pollard (p − 1)-method. Example 6.3.5. In this example, Pollard works perfectly. Let N = 5917. We try to use the Pollard p − 1 method with B = 5 to split N . We have m = lcm(1, 2, 3, 4, 5) = 60; taking a = 2, we have 2 60 − 1 ≡ 3416 (mod 5917) and gcd(260 − 1, 5917) = gcd(3416, 5917) = 61, so 61 is a factor of 5917. Example 6.3.6. In this example, we replace B with a larger integer. Let N = 779167. With B = 5 and a = 2, we have 260 − 1 ≡ 710980 (mod 779167), and gcd(260 − 1, 779167) = 1. With B = 15, we have m = lcm(1, 2, . . . , 15) = 360360, 2 360360 − 1 ≡ 584876 (mod 779167), and gcd(2360360 − 1, N ) = 2003, so 2003 is a nontrivial factor of 779167. Example 6.3.7. In this example, we replace B by a smaller integer. Let N = 4331. Suppose B = 7, so m = lcm(1, 2, . . . , 7) = 420, 2420 − 1 ≡ 0 (mod 4331), and gcd(2420 − 1, 4331) = 4331, so we do not obtain a factor of 4331. If we replace B by 5, Pollard’s method works: 2 60 − 1 ≡ 1464 (mod 4331), and gcd(260 − 1, 4331) = 61, so we split 4331. 132 6. Elliptic Curves Example 6.3.8. In this example, a = 2 does not work, but a = 3 does. Let N = 187. Suppose B = 15, so m = lcm(1, 2, . . . , 15) = 360360, 2 360360 − 1 ≡ 0 (mod 187), and gcd(2 360360 − 1, 187) = 187, so we do not obtain a factor of 187. If we replace a = 2 by a = 3, then Pollard’s method works: 3360360 − 1 ≡ 66 (mod 187), and gcd(3360360 − 1, 187) = 11. Thus 187 = 11 · 17. SAGE Example 6.3.9. We implement the Pollard (p − 1)-method in Sage and use our implementation to do all of the above examples. sage: def pollard(N, B=10^5, stop=10): ... m = prod([p^int(math.log(B)/math.log(p)) ... for p in prime_range(B+1)]) ... for a in [2..stop]: ... x = (Mod(a,N)^m - 1).lift() ... if x == 0: continue ... g = gcd(x, N) ... if g != 1 or g != N: return g ... return 1 sage: pollard(5917,5) 61 sage: pollard(779167,5) 1 sage: pollard(779167,15) 2003 sage: pollard(4331,7) 1 sage: pollard(4331,5) 61 sage: pollard(187, 15, 2) 1 sage: pollard(187, 15) 11 6.3.2 Motivation for the Elliptic Curve Method Fix a positive integer B. If N = pq with p and q prime, and we assume that p − 1 and q − 1 are not B-power smooth, then the Pollard (p − 1)- method is unlikely to work. For example, let B = 20 and suppose that N = 59 · 101 = 5959. Note that neither 59 − 1 = 2 · 29 nor 101 − 1 = 4 · 25 is B-power smooth. With m = lcm(1, 2, 3, . . . , 20) = 232792560, we have 2 m − 1 ≡ 5944 (mod N ), 6.3 Integer Factorization Using Elliptic Curves 133 and gcd(2m − 1, N ) = 1, so we do not ﬁnd a factor of N . As remarked above, the problem is that p − 1 is not 20-power smooth for either p = 59 or p = 101. However, notice that p − 2 = 3 · 19 is 20-power smooth. Lenstra’s ECM replaces (Z/pZ) ∗, which has order p − 1, by the group of points on an elliptic curve E over Z/pZ. It is a theorem that #E(Z/pZ) = p + 1 ± s for some nonnegative integer s < 2 √p (see [Sil86, §V.1] for a proof). Also, every value of s subject to this bound occurs, as one can see using “complex multiplication theory.” For example, if E is the elliptic curve y2 = x3 + x + 54 over Z/59Z, then by enumerating points one sees that E(Z/59Z) is cyclic of order 57. The set of numbers 59 + 1 ± s for s ≤ 15 contains 14 numbers that are B-power smooth for B = 20, which illustrates that working with an elliptic curve gives us more ﬂexibility. For example, 60 = 59 + 1 + 0 is 5-power smooth and 70 = 59 + 1 + 10 is 7-power smooth. 6.3.3 Lenstra’s Elliptic Curve Factorization Method Algorithm 6.3.10 (Elliptic Curve Factorization Method). Given a posi- tive integer N and a bound B, this algorithm attempts to ﬁnd a nontrivial factor g of N or outputs “Fail.” 1. [Compute lcm] Use Algorithm 6.3.2 to compute m = lcm(1, 2, . . . , B). 2. [Choose Random Elliptic Curve] Choose a random a ∈ Z/N Z such that 4a 3 + 27 ∈ (Z/N Z)∗. Then P = (0, 1) is a point on the elliptic curve y2 = x3 + ax + 1 over Z/N Z. 3. [Compute Multiple] Attempt to compute mP using an elliptic curve analog of Algorithm 2.3.13. If at some point we cannot compute a sum of points because some denominator in Step 3 of Algorithm 6.2.1 is not coprime to N , we compute the greatest common divisor g of this denominator with N . If g is a nontrivial divisor, output it. If every denominator is coprime to N , output “Fail.” If Algorithm 6.3.10 fails for one random elliptic curve, there is an option that is unavailable with Pollard’s (p−1)-method—we may repeat the above algorithm with a diﬀerent elliptic curve. With Pollard’s method we always work with the group (Z/N Z) ∗, but here we can try many groups E(Z/N Z) for many curves E. As mentioned above, the number of points on E over Z/pZ is of the form p + 1 − t for some t with |t| < 2 √p; Algorithm 6.3.10 thus has a chance if p + 1 − t is B-power smooth for some t with |t| < 2√p. 134 6. Elliptic Curves 6.3.4 Examples For simplicity, we use an elliptic curve of the form y2 = x3 + ax + 1, which has the point P = (0, 1) already on it. We factor N = 5959 using the elliptic curve method. Let m = lcm(1, 2, . . . , 20) = 232792560 = 11011110000000100001111100002, where x2 means x is written in binary. First, we choose a = 1201 at random and consider y2 = x3 + 1201x + 1 over Z/5959Z. Using the formula for P + P from Algorithm 6.2.1 we compute 2 i · P = 2 i · (0, 1) for i ∈ B = {4, 5, 6, 7, 8, 13, 21, 22, 23, 24, 26, 27}. Then ∑ i∈B 2iP = mP . It turns out that during no step of this computation does a number not coprime to 5959 appear in any denominator, so we do not split N using a = 1201. Next, we try a = 389 and at some stage in the computation we add P = (2051, 5273) and Q = (637, 1292). When computing the group law explicitly, we try to compute λ = (y1 − y2)/(x1 − x2) in (Z/5959Z) ∗, but we fail since x1 − x2 = 1414 and gcd(1414, 5959) = 101. We thus ﬁnd a nontrivial factor 101 of 5959. SAGE Example 6.3.11. We implement elliptic curve factorization in Sage, then use it to do the above example and some other examples. sage: def ecm(N, B=10^3, trials=10): ... m = prod([p^int(math.log(B)/math.log(p)) ... for p in prime_range(B+1)]) ... R = Integers(N) ... # Make Sage think that R is a field: ... R.is_field = lambda : True ... for _ in range(trials): ... while True: ... a = R.random_element() ... if gcd(4*a.lift()^3 + 27, N) == 1: break ... try: ... m * EllipticCurve([a, 1])([0,1]) ... except ZeroDivisionError, msg: ... # msg: \"Inverse of <int> does not exist\" ... return gcd(Integer(str(msg).split()[2]), N) ... return 1 sage: set_random_seed(2) sage: ecm(5959, B=20) 101 sage: ecm(next_prime(10^20)*next_prime(10^7), B=10^3) 10000019 6.4 Elliptic Curve Cryptography 135 6.3.5 A Heuristic Explanation Let N be a positive integer and, for simplicity of exposition, assume that N = p1 · · · pr with the pi distinct primes. It follows from Lemma 2.2.5 that there is a natural isomorphism f : (Z/N Z)∗ −→ (Z/p1Z) ∗ × · · · × (Z/prZ)∗. When using Pollard’s method, we choose an a ∈ (Z/N Z)∗, compute a m, then compute gcd(a m − 1, N ). This gcd is divisible exactly by the primes pi such that am ≡ 1 (mod pi). To reinterpret Pollard’s method using the above isomorphism, let (a1, . . . , ar) = f (a). Then (am 1 , . . . , am r ) = f (a m), and the pi that divide gcd(a m − 1, N ) are exactly the pi such that a m i = 1. By Theorem 2.1.20, these pi include the primes pj such that pj − 1 is B-power smooth, where m = lcm(1, . . . , m). We will not deﬁne E(Z/N Z) when N is composite, since this is not needed for the algorithm (where we assume that N is prime and hope for a contradiction). However, for the remainder of this paragraph, we pretend that E(Z/N Z) is meaningful and describe a heuristic connection between Lenstra and Pollard’s methods. The signiﬁcant diﬀerence between Pollard’s method and the elliptic curve method is that the isomorphism f is replaced by an isomorphism (in quotes) “g : E(Z/N Z) → E(Z/p1Z) × · · · × E(Z/prZ)” where E is y2 = x3 + ax + 1, and the a of Pollard’s method is replaced by P = (0, 1). We put the isomorphism in quotes to emphasize that we have not deﬁned E(Z/N Z). When carrying out the elliptic curve factorization algorithm, we attempt to compute mP , and if some components of f (Q) are O, for some point Q that appears during the computation, but others are nonzero, we ﬁnd a nontrivial factor of N . 6.4 Elliptic Curve Cryptography The idea to use elliptic curves in cryptography was independently proposed by Neil Koblitz and Victor Miller in the mid 1980s. In this section, we discuss an analog of Diﬃe-Hellman that uses an elliptic curve instead of (Z/pZ)∗. We then discuss the ElGamal elliptic curve cryptosystem. 6.4.1 Elliptic Curve Analogs of Diﬃe-Hellman The Diﬃe-Hellman key exchange from Section 3.2 works well on an elliptic curve with no serious modiﬁcation. Michael and Nikita agree on a secret key as follows: 136 6. Elliptic Curves 1. Michael and Nikita agree on a prime p, an elliptic curve E over Z/pZ, and a point P ∈ E(Z/pZ). 2. Michael secretly chooses a random m and sends mP . 3. Nikita secretly chooses a random n and sends nP . 4. The secret key is nmP , which both Michael and Nikita can compute. Presumably, an adversary can not compute nmP without solving the dis- crete logarithm problem (see Problem 3.2.2 and Section 6.4.3 below) in E(Z/pZ). For well-chosen E, P , and p, experience suggests that the dis- crete logarithm problem in E(Z/pZ) is much more diﬃcult than the discrete logarithm problem in (Z/pZ)∗ (see Section 6.4.3 for more on the elliptic curve discrete log problem). 6.4.2 The ElGamal Cryptosystem and Digital Rights Management This section is about the ElGamal cryptosystem, which works well on an elliptic curve. This section draws on a paper by a computer hacker named Beale Screamer who cracked a “Digital Rights Management” (DRM) sys- tem. The elliptic curve used in the DRM is an elliptic curve over the ﬁnite ﬁeld k = Z/pZ, where p = 785963102379428822376694789446897396207498568951. The number p in base 16 is 89ABCDEF012345672718281831415926141424F7, which includes counting in hexadecimal, and digits of e, π, and √2. The elliptic curve E is y2 = x3 + 317689081251325503476317476413827693272746955927x + 79052896607878758718120572025718535432100651934. We have #E(k) = 785963102379428822376693024881714957612686157429, and the group E(k) is cyclic with generator B = (771507216262649826170648268565579889907769254176, 390157510246556628525279459266514995562533196655). 6.4 Elliptic Curve Cryptography 137 Our heroes Nikita and Michael share digital music when they are not out ﬁghting terrorists. When Nikita installed the DRM software on her computer, it generated a private key n = 670805031139910513517527207693060456300217054473, which it hides in bits and pieces of ﬁles. In order for Nikita to play Juno Reactor’s latest hit juno.wma, her web browser contacts a website that sells music. After Nikita sends her credit card number, that website allows Nikita to download a license ﬁle that allows her audio player to unlock and play juno.wma. As we will see below, the license ﬁle was created using the ElGamal public-key cryptosystem in the group E(k). Nikita can now use her license ﬁle to unlock juno.wma. However, when she shares both juno.wma and the license ﬁle with Michael, he is frustrated because even with the license, his computer still does not play juno.wma. This is because Michael’s computer does not know Nikita’s computer’s private key (the integer n above), so Michael’s computer can not decrypt the license ﬁle. We now describe the ElGamal cryptosystem, which lends itself well to implementation in the group E(Z/pZ). To illustrate ElGamal, we describe how Nikita would set up an ElGamal cryptosystem that anyone could use to encrypt messages for her. Nikita chooses a prime p, an elliptic curve E over Z/pZ, and a point B ∈ E(Z/pZ), and publishes p, E, and B. She also chooses a random integer n, which she keeps secret, and publishes nB. Her public key is the four-tuple (p, E, B, nB). Suppose Michael wishes to encrypt a message for Nikita. If the message is encoded as an element P ∈ E(Z/pZ), Michael computes a random integer r and the points rB and P + r(nB) on E(Z/pZ). Then P is encrypted as the pair (rB, P + r(nB)). To decrypt the encrypted message, Nikita multiplies rB by her secret key n to ﬁnd n(rB) = r(nB), then subtracts this from P + r(nB) to obtain P = P + r(nB) − r(nB). Remark 6.4.1. It also make sense to construct an ElGamal cryptosystem in the group (Z/pZ) ∗. Returning to our story, Nikita’s license ﬁle is an encrypted message to her. It contains the pair of points (rB, P + r(nB)), where rB = (179671003218315746385026655733086044982194424660, 697834385359686368249301282675141830935176314718) and P + r(nB) = (137851038548264467372645158093004000343639118915, 110848589228676224057229230223580815024224875699). 138 6. Elliptic Curves When Nikita’s computer plays juno.wma, it loads the secret key n = 670805031139910513517527207693060456300217054473 into memory and computes n(rB) = (328901393518732637577115650601768681044040715701, 586947838087815993601350565488788846203887988162). It then subtracts this from P + r(nB) to obtain P = (14489646124220757767, 669337780373284096274895136618194604469696830074). The x-coordinate 14489646124220757767 is the key that unlocks juno.wma. If Nikita knew the private key n that her computer generated, she could compute P herself and unlock juno.wma and share her music with Michael. Beale Screamer found a weakness in the implementation of this system that allows Nikita to detetermine n, which is not a huge surprise since n is stored on her computer after all. SAGE Example 6.4.2. We do the above examples in Sage: sage: p = 785963102379428822376694789446897396207498568951 sage: E = EllipticCurve(GF(p), \\ ... [317689081251325503476317476413827693272746955927, ... 79052896607878758718120572025718535432100651934]) sage: E.cardinality() 785963102379428822376693024881714957612686157429 sage: E.cardinality().is_prime() True sage: B = E([ ... 771507216262649826170648268565579889907769254176, ... 390157510246556628525279459266514995562533196655]) sage: n=670805031139910513517527207693060456300217054473 sage: r=70674630913457179596452846564371866229568459543 sage: P = E([14489646124220757767, ... 669337780373284096274895136618194604469696830074]) sage: encrypt = (r*B, P + r*(n*B)) sage: encrypt[1] - n*encrypt[0] == P # decrypting works True 6.4.3 The Elliptic Curve Discrete Logarithm Problem Problem 6.4.3 (Elliptic Curve Discrete Log Problem). Suppose E is an elliptic curve over Z/pZ and P ∈ E(Z/pZ). Given a multiple Q of P , the elliptic curve discrete log problem is to ﬁnd n ∈ Z such that nP = Q. 6.4 Elliptic Curve Cryptography 139 For example, let E be the elliptic curve given by y2 = x3 + x + 1 over the ﬁeld Z/7Z. We have E(Z/7Z) = {O, (2, 2), (0, 1), (0, 6), (2, 5)}. If P = (2, 2) and Q = (0, 6), then 3P = Q, so n = 3 is a solution to the discrete logarithm problem. If E(Z/pZ) has order p or p ± 1, or is a product of reasonably small primes, then there are some methods for attacking the discrete log problem on E, which are beyond the scope of this book. It is therefore important to be able to compute #E(Z/pZ) eﬃciently, in order to verify that the elliptic curve one wishes to use for a cryptosystem doesn’t have any obvious vulnerabilities. The naive algorithm to compute #E(Z/pZ) is to try each value of x ∈ Z/pZ and count how often x3+ax+b is a perfect square mod p, but this is of no use when p is large enough to be useful for cryptography. Fortunately, there is an algorithm due to Schoof, Elkies, and Atkin for computing #E(Z/pZ) eﬃciently (polynomial time in the number of digits of p), but this algorithm is beyond the scope of this book. In Section 3.2.1, we discussed the discrete log problem in (Z/pZ) ∗. There are general attacks called “index calculus attacks” on the discrete log prob- lem in (Z/pZ) ∗ that are slow, but still faster than the known algorithms for solving the discrete log in a “general” group (one with no extra struc- ture). For most elliptic curves, there is no known analog of index calculus attacks on the discrete log problem. At present, it appears that given p, the discrete log problem in E(Z/pZ) is much harder than the discrete log problem in the multiplicative group (Z/pZ)∗. This suggests that by us- ing an elliptic curve-based cryptosystem instead of one based on (Z/pZ) ∗, one gets equivalent security with much smaller numbers, which is one rea- son why building cryptosystems using elliptic curves is attractive to some cryptographers. For example, Certicom, a company that strongly supports elliptic curve cryptography, claims: “[Elliptic curve crypto] devices require less storage, less power, less memory, and less bandwidth than other systems. This al- lows you to implement cryptography in platforms that are con- strained, such as wireless devices, handheld computers, smart cards, and thin-clients. It also provides a big win in situations where eﬃciency is important.” For an up-to-date list of elliptic curve discrete log challenge problems that Certicom sponsors, see [Cer]. For example, in April 2004, a speciﬁc cryptosystem was cracked that was based on an elliptic curve over Z/pZ, where p has 109 bits. The ﬁrst unsolved challenge problem involves an elliptic curve over Z/pZ, where p has 131 bits, and the next challenge after that is one in which p has 163 bits. Certicom claims at [Cer] that the 163-bit challenge problem is computationally infeasible. 140 6. Elliptic Curves FIGURE 6.4. Louis J. Mordell 6.5 Elliptic Curves Over the Rational Numbers Let E be an elliptic curve deﬁned over Q. The following is a deep theorem about the group E(Q). Theorem 6.5.1 (Mordell). The group E(Q) is ﬁnitely generated. That is, there are points P1, . . . , Ps ∈ E(Q) such that every element of E(Q) is of the form n1P1 + · · · + nsPs for integers n1, . . . ns ∈ Z. Mordell’s theorem implies that it makes sense to ask whether or not we can compute E(Q), where by “compute” we mean ﬁnd a ﬁnite set P1, . . . , Ps of points on E that generate E(Q) as an abelian group. There is a systematic approach to computing E(Q) called “descent” (see, for example, [Cre97, Cre, Sil86]). It is widely believed that the method of descent will always succeed, but nobody has yet proved that it will. Proving that descent works for all curves is one of the central open problems in number theory, and is closely related to the Birch and Swinnerton-Dyer conjecture (one of the Clay Math Institute’s million dollar prize problems). The crucial diﬃculty amounts to deciding whether or not certain explicitly given curves have any rational points on them or not (these are curves that have points over R and modulo n for all n). The details of using descent to compute E(Q) are beyond the scope of this book. In several places below, we will simply assert that E(Q) has a certain structure or is generated by certain elements. In each case, we computed E(Q) using a computer implementation of this method. 6.5.1 The Torsion Subgroup of E(Q) For any abelian group G, let Gtor be the subgroup of elements of ﬁnite order. If E is an elliptic curve over Q, then E(Q)tor is a subgroup of E(Q), which must be ﬁnite because of Theorem 6.5.1 (see Exercise 6.6). 6.5 Elliptic Curves Over the Rational Numbers 141 One can also prove that E(Q)tor is ﬁnite by showing that there is a prime p and an injective reduction homomorphism E(Q)tor ,→ E(Z/pZ), then noting that E(Z/pZ) is ﬁnite. For example, if E is y2 = x 3 − 5x + 4, then E(Q)tor = {O, (1, 0)} ∼= Z/2Z. The possibilities for E(Q)tor are known. Theorem 6.5.2 (Mazur, 1976). Let E be an elliptic curve over Q. Then E(Q)tor is isomorphic to one of the following 15 groups: Z/nZ for n ≤ 10 or n = 12, Z/2Z × Z/2n for n ≤ 4. SAGE Example 6.5.3. We compute the structure of the torsion subgroups of some elliptic curves. In each case, the output of the function T (a, b) below is a pair c, d ∈ Z (or integer c) such that the torsion subgroup of y3 = x3 + ax + b is Z/cZ × Z/dZ. sage: T = lambda v: EllipticCurve(v ... ).torsion_subgroup().invariants() sage: T([-5,4]) [2] sage: T([-43,166]) [7] sage: T([-4,0]) [2, 2] sage: T([-1386747, 368636886]) [8, 2] 6.5.2 The Rank of E(Q) The quotient E(Q)/E(Q)tor is a ﬁnitely generated free abelian group, so it is isomorphism to Zr for some integer r, called the rank of E(Q). For example, one can prove that if E is y2 = x 3 − 5x + 4, then E(Q)/E(Q)tor is generated by the point (0, 2). SAGE Example 6.5.4. We use Sage to compute the ranks of some elliptic curves y2 = x3 + ax + b. The function r(a, b) below returns the rank of this curve over Q. sage: r = lambda v: EllipticCurve(v).rank() sage: r([-5,4]) 1 sage: r([0,1]) 0 sage: r([-3024, 46224]) 2 sage: r([-112, 400]) 142 6. Elliptic Curves 3 sage: r([-102627, 12560670]) 4 The following is a folklore conjecture, not associated with any particular mathematician: Conjecture 6.5.5. There are elliptic curves over Q of arbitrarily large rank. The world record is the following curve, whose rank is at least 28: y2+xy + y = x3 − x2− 20067762415575526585033208209338542750930230312178956502x+ 344816117950305564670329856903907203748559443593191803612 . . . . . . 66008296291939448732243429 It was discovered in May 2006 by Noam Elkies of Harvard University. 6.5.3 The Congruent Number Problem Deﬁnition 6.5.6 (Congruent Number). We call a nonzero rational num- ber n a congruent number if ±n is the area of a right triangle with rational side lengths. Equivalently, n is a congruent number if the system of two equations a 2 + b2 = c2 1 2 ab = n has a solution with a, b, c ∈ Q. For example, 6 is the area of the right triangle with side lengths 3, 4, and 5, so 6 is a congruent number. Less obvious is that 5 is also a congruent number; it is the area of the right triangle with side lengths 3/2, 20/3, and 41/6. It is nontrivial to prove that 1, 2, 3, and 4 are not congruent numbers. Here is a list of the integer congruent numbers up to 50: 5, 6, 7, 13, 14, 15, 20, 21, 22, 23, 24, 28, 29, 30, 31, 34, 37, 38, 39, 41, 45, 46, 47. Every congruence class modulo 8 except 3 is represented in this list, which incorrectly suggests that if n ≡ 3 (mod 8) then n is not a congruent number. Though no n ≤ 218 with n ≡ 3 (mod 8) is a congruent number, n = 219 is a congruent number and 219 ≡ 3 (mod 8). Deciding whether an integer n is a congruent number can be subtle, since the simplest triangle with area n can be very complicated. For example, 6.5 Elliptic Curves Over the Rational Numbers 143 as Zagier pointed out, the number 157 is a congruent number, and the “simplest” rational right triangle with area 157 has side lengths a = 6803298487826435051217540 411340519227716149383203 and b = 411340519227716149383203 21666555693714761309610 . This solution would be diﬃcult to ﬁnd by a brute force search. We call congruent numbers “congruent” because of the following proposi- tion, which asserts that any congruent number is the common “congruence” between three perfect squares. Proposition 6.5.7. Suppose n is the area of a right triangle with rational side lengths a, b, c, with a ≤ b < c. Let A = (c/2) 2. Then A − n, A, and A + n are all perfect squares of rational numbers. Proof. We have a 2 + b2 = c2 1 2 ab = n Add or subtract 4 times the second equation to the ﬁrst to get a 2 ± 2ab + b2 = c2 ± 4n (a ± b) 2 = c2 ± 4n ( a ± b 2 )2 = ( c 2 )2 ± n = A ± n The main motivating open problem related to congruent numbers is to give a systematic way to recognize them. Open Problem 6.5.8. Give an algorithm which, given n, outputs whether or not n is a congruent number. Fortunately, the vast theory developed about elliptic curves has some- thing to say about the above problem. In order to understand this connec- tion, we begin with an elementary algebraic proposition that establishes a link between elliptic curves and the congruent number problem. Proposition 6.5.9 (Congruent numbers and elliptic curves). Let n be a rational number. There is a bijection between A = {(a, b, c) ∈ Q 3 : ab 2 = n, a2 + b 2 = c2} 144 6. Elliptic Curves and B = { (x, y) ∈ Q2 : y2 = x3 − n2x, with y ̸= 0 } given explicitly by the maps f (a, b, c) = (− nb a + c , 2n2 a + c ) and g(x, y) = ( n2 − x2 y , − 2xn y , n2 + x2 y ) . The proof of this proposition is not deep, but involves substantial (ele- mentary) algebra and we will not prove it in this book. For n ̸= 0, let En be the elliptic curve y2 = x3 − n2x. Proposition 6.5.10 (Congruent number criterion). The rational num- ber n is a congruent number if and only if there is a point P = (x, y) ∈ En(Q) with y ̸= 0. Proof. The number n is a congruent number if and only if the set A from Proposition 6.5.9 is nonempty. By the proposition A is nonempty if and only if B is nonempty. Example 6.5.11. Let n = 5. Then En is y2 = x3 − 25x, and we notice that (−4, −6) ∈ En(Q). We next use the bijection of Proposition 6.5.9 to ﬁnd the corresponding right triangle: g(−4, −6) = ( 25 − 16 −6 , − −40 −6 , 25 + 16 −6 ) = (− 3 2 , − 20 3 , − 41 6 ) . Multiplying through by −1 yields the side lengths of a rational right triangle with area 5. Are there any others? Observe that we can apply g to any point in En(Q) with y ̸= 0. Using the group law, we ﬁnd that 2(−4, −6) = (1681/144, 62279/1728) and g(2(−4, −6)) = (− 1519 492 , − 4920 1519 , 3344161 747348 ) . This example foreshadows Theorem 6.5.14. Example 6.5.12. Let n = 1, so E1 is deﬁned by y2 = x3 − x. Since 1 is not a congruent number, the elliptic curve E1 has no point with y ̸= 0. See Exercise 6.11. SAGE Example 6.5.13. We implement the cong function in Sage, which returns a triple (a, b, c) whose entries are the sides of a rational right triangle of area n if one exists, and returns False if there are no such triangles. 6.5 Elliptic Curves Over the Rational Numbers 145 sage: def cong(n): ... G = EllipticCurve([-n^2,0]).gens() ... if len(G) == 0: return False ... x,y,_ = G[0] ... return ((n^2-x^2)/y,-2*x*n/y,(n^2+x^2)/y) sage: cong(6) (3, 4, 5) sage: cong(5) (3/2, 20/3, 41/6) sage: cong(1) False sage: cong(13) (323/30, 780/323, 106921/9690) sage: (323/30 * 780/323)/2 13 sage: (323/30)^2 + (780/323)^2 == (106921/9690)^2 True Theorem 6.5.14 (Inﬁnitely Many Triangles). If n is a congruent number, then there are inﬁnitely many distinct right triangles with rational side lengths and area n. We will not prove this theorem, except to note that one proves it by showing that En(Q)tor = {O, (0, 0), (n, 0), (−n, 0)}, so the elements of the set B in Proposition 6.5.9 all have inﬁnite order. Hence, B is inﬁnite so A is inﬁnite. Tunnell has proved that the Birch and Swinnerton-Dyer conjecture (al- luded to above), implies the existence of an elementary way to decide whether or not an integer n is a congruent number. We state Tunnell’s elementary way in the form of a conjecture. Conjecture 6.5.15. Let a, b, c denote integers. If n is an even square-free integer, then n is a congruent number if and only if # { (a, b, c) ∈ Z3 : 4a 2 + b 2 + 8c2 = n 2 : c is even } = # { (a, b, c) : 4a 2 + b2 + 8c 2 = n 2 : c is odd} . If n is odd and square free then n is a congruent number if and only if # { (a, b, c) : 2a 2 + b2 + 8c2 = n : c is even } = # {(a, b, c) : 2a2 + b2 + 8c2 = n : c is odd } . Enough of the Birch and Swinnerton-Dyer conjecture is known to prove one direction of Conjecture 6.5.15. In particular, it is a very deep theorem that if we do not have equality of the displayed cardinalities, then n is not a congruent number. 146 6. Elliptic Curves The even more diﬃcult (and still open!) part of Conjecture 6.5.15 is the converse: If one has equality of the displayed cardinalities, prove that n is a congruent number. The diﬃculty in this direction, which appears to be very deep, is that we must somehow construct (or prove the existence of) elements of En(Q). This has been accomplished in some cases due to the groundbreaking work of Gross and Zagier ([GZ86]) but much work remains to be done. The excellent book [Kob84] is about congruent numbers and Conjec- ture 6.5.15, and we encourage the reader to consult it. The Birch and Swinnerton-Dyer conjecture is a Clay Math Institute million dollar millen- nium prize problem (see [Cla, Wil00]). 6.6 Exercises 6.1 Write down an equation y2 = x3 + ax + b over a ﬁeld K such that −16(4a 3+27b2) = 0. Precisely what goes wrong when trying to endow the set E(K) = {(x, y) ∈ K × K : y2 = x3 + ax + b} ∪ {O} with a group structure? 6.2 One rational solution to the equation y2 = x3 − 2 is (3, 5). Find a rational solution with x ̸= 3 by drawing the tangent line to (3, 5) and computing the second point of intersection. 6.3 Let E be the elliptic curve over the ﬁnite ﬁeld K = Z/5Z deﬁned by the equation y2 = x3 + x + 1. (a) List all 9 elements of E(K). (b) What is the structure of E(K), as a product of cyclic groups? 6.4 Let E be the elliptic curve deﬁned by the equation y2 = x 3 + 1. For each prime p ≥ 5, let Np be the cardinality of the group E(Z/pZ) of points on this curve having coordinates in Z/pZ. For example, we have that N5 = 6, N7 = 12, N11 = 12, N13 = 12, N17 = 18, N19 = 12, , N23 = 24, and N29 = 30 (you do not have to prove this). (a) For the set of primes satisfying p ≡ 2 (mod 3), can you see a pattern for the values of Np? Make a general conjecture for the value of Np when p ≡ 2 (mod 3). (b) (*) Prove your conjecture. 6.5 Let E be an elliptic curve over the real numbers R. Prove that E(R) is not a ﬁnitely generated abelian group. 6.6 (*) Suppose G is a ﬁnitely generated abelian group. Prove that the subgroup Gtor of elements of ﬁnite order in G is ﬁnite. 6.6 Exercises 147 6.7 Suppose y2 = x3 + ax + b with a, b ∈ Q deﬁnes an elliptic curve. Show that there is another equation Y 2 = X 3 + AX + B with A, B ∈ Z whose solutions are in bijection with the solutions to y2 = x3 +ax+b. 6.8 Suppose a, b, c are relatively prime integers with a 2 + b2 = c 2. Then there exist integers x and y with x > y such that c = x2 + y2 and either a = x2 − y2, b = 2xy or a = 2xy, b = x2 − y2. 6.9 (*) Fermat’s Last Theorem for exponent 4 asserts that any solution to the equation x4 + y4 = z4 with x, y, z ∈ Z satisﬁes xyz = 0. Prove Fermat’s Last Theorem for exponent 4, as follows. (a) Show that if the equation x2 + y4 = z4 has no integer solutions with xyz ̸= 0, then Fermat’s Last Theorem for exponent 4 is true. (b) Prove that x2 + y4 = z4 has no integer solutions with xyz ̸= 0 as follows. Suppose n2 + k4 = m 4 is a solution with m > 0 minimal among all solutions. Show that there exists a solution with m smaller using Exercise 6.8 (consider two cases). 6.10 This problem requires a computer. (a) Show that the set of numbers 59 + 1 ± s for s ≤ 15 contains 14 numbers that are B-power smooth for B = 20. (b) Find the proportion of primes p in the interval from 1012 and 1012 + 1000 such that p − 1 is B = 10 5 power smooth. 6.11 (*) Prove that 1 is not a congruent number by showing that the elliptic curve y2 = x3 − x has no rational solutions except (0, ±1) and (0, 0), as follows: (a) Write y = p q and x = r s , where p, q, r, s are all positive integers and gcd(p, q) = gcd(r, s) = 1. Prove that s | q, so q = sk for some k ∈ Z. (b) Prove that s = k2, and substitute to see that p2 = r3 − rk4. (c) Prove that r is a perfect square by supposing that there is a prime ℓ such that ordℓ(r) is odd, and analyzing ordℓ of both sides of p 2 = r3 − rk4. (d) Write r = m 2, and substitute to see that p2 = m6 − m 2k4. Prove that m | p. (e) Divide through by m 2 and deduce a contradiction to Exer- cise 6.9. 148 6. Elliptic Curves This is page 149 Printer: Opaque this Answers and Hints • Chapter 1. Prime Numbers 2. They are 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97. 3. Emulate the proof of Proposition 1.2.5. • Chapter 2. The Ring of Integers Modulo n 2. They are 5, 13, 3, and 8. 3. For example, x = 22, y = −39. 4. Hint: Use the binomial theorem and prove that if r ≥ 1, then p divides (p r). 7. For example, S1 = {0, 1, 2, 3, 4, 5, 6}, S2 = {1, 3, 5, 7, 9, 11, 13}, S3 = {0, 2, 4, 6, 8, 10, 12}, and S4 = {2, 3, 5, 7, 11, 13, 29}. In each we ﬁnd Si by listing the ﬁrst seven numbers satisfying the ith condition, then adjust the last number if necessary so that the reductions will be distinct modulo 7. 8. An integer is divisible by 5 if and only if the last digits is 0 or 5. An integer is divisible by 9 if and only if the sum of the digits is divisible by 9. An integer is divisible by 11 if and only if the alternating sum of the digits is divisible by 11. 9. Hint for part (a): Use the divisibility rule you found in Exer- cise 1.8. 150 6. Elliptic Curves 10. 71 11. 8 12. As explained on page 23, we know that Z/nZ is a ring for any n. Thus to show that Z/pZ is a ﬁeld it suﬃces to show that every nonzero element a ∈ Z/pZ has an inverse. Lift a to an element a ∈ Z, and set b = p in Proposition 2.3.1. Because p is prime, gcd(a, p) = 1, so there exists x, y such that ax+py = 1. Reducing this equality modulo p proves that a has an inverse x (mod p). Alternatively, one could argue just like after Deﬁnition 2.1.16 that am = 1 for some m, so some power of a is the inverse of a. 13. 302 15. Only for n = 1, 2. If n > 2, then n is either divisible by an odd prime p or 4. If 4 | n, then 2e − 2 e−1 divides ϕ(n) for some e ≥ 2, so ϕ(n) is even. If an odd p divides n, then the even number p e − p e−1 divides ϕ(n) for some e ≥ 1. 16. The map ψ is a homomorphism since both reduction maps Z/mnZ → Z/mZ and Z/mnZ → Z/nZ are homomorphisms. It is injective because if a ∈ Z is such that ψ(a) = 0, then m | a and n | a, so mn | a (since m and n are coprime), so a ≡ 0 (mod mn). The cardinality of Z/mnZ is mn and the cardinality of the product Z/mZ × Z/nZ is also mn, so ψ must be an isomorphism. The units (Z/mnZ) ∗ are thus in bijection with the units (Z/mZ)∗ × (Z/nZ) ∗. For the second part of the exercise, let g = gcd(m, n) and set a = mn/g. Then a ̸≡ 0 (mod mn), but m | a and n | a, so a ker(ψ). 17. We express the question as a system of linear equations modulo various numbers, and use the Chinese remainder theorem. Let x be the number of books. The problem asserts that x ≡ 6 (mod 7) x ≡ 2 (mod 6) x ≡ 1 (mod 5) x ≡ 0 (mod 4) Applying CRT to the ﬁrst pair of equations, we ﬁnd that x ≡ 20 (mod 42). Applying CRT to this equation and the third, we ﬁnd that x ≡ 146 (mod 210). Since 146 is not divisible by 4, we add multiples of 210 to 146 until we ﬁnd the ﬁrst x that is divisible by 4. The ﬁrst multiple works, and we ﬁnd that the aspiring mathematicians have 356 math books. 6.6 Exercises 151 18. Note that p = 3 works, since 11 = 3 2 + 2 is prime. Now suppose p ̸= 3 is any prime such that p and p 2 + 2 are both prime. We must have p ≡ 1 (mod 3) or p ≡ 2 (mod 3). Then p2 ≡ 1 (mod 3), so p 2 + 2 ≡ 0 (mod 3). Since p 2 + 2 is prime, we must have p2 + 2 = 3, so p = 1, a contradiction as p is assumed prime. 19. For (a) n = 1, 2, see solution to Exercise 2.15. For (b), yes there are many such examples. For example, m = 2, n = 4. 20. By repeated application of multiplicativity and Equation (2.2.2) on page 31, we see that if n = ∏ i p ei i is the prime factorization of n, then ϕ(n) = ∏ i (p ei i − p ei−1 i ) = ∏ i pei−1 i · ∏ i (pi − 1). 23. 1, 6, 29, 34 24. Let g = gcd(12n+1, 30n+2). Then g | 30n+2−2·(12n+1) = 6n. For the same reason, g also divides 12n + 1 − 2 · (6n) = 1, so g = 1, as claimed. 27. There is no primitive root modulo 8, since (Z/8Z)∗ has order 4, but every element of (Z/8Z)∗ has order 2. Prove that if ζ is a primitive root modulo 2 n, for n ≥ 3, then the reduction of ζ mod 8 is a primitive root, a contradiction. 28. 2 is a primitive root modulo 125. 29. Let ∏m i=1 pei i be the prime factorization of n. Slightly generaliz- ing Exercise 16, we see that (Z/nZ) ∗ ∼= ∏ (Z/pei i Z)∗. Thus (Z/nZ)∗ is cyclic if and only if the product (Z/pei i Z)∗ is cyclic. If 8 | n, then there is no chance (Z/nZ) ∗ is cyclic, so assume 8 ∤ n. Then by Exercise 2.28, each group (Z/pei i Z)∗ is itself cyclic. A product of cyclic groups is cyclic if and only the orders of the factors in the product are coprime (this follows from Exercise 2.16). Thus (Z/nZ)∗ is cyclic if and only if the numbers pi(pi − 1), for i = 1, . . . , m are pairwise coprime. Since pi − 1 is even, there can be at most one odd prime in the factorization of n, and we see that (Z/nZ) ∗ is cyclic if and only if n is an odd prime power, twice an odd prime power, or n = 4. • Chapter 3. Public-Key Cryptography 1. The best case is that each letter is A. Then the question is to ﬁnd the largest n such that 1 + 27 + · · · + 27 n ≤ 10 20. By computing 152 6. Elliptic Curves log27(10 20), we see that 2713 < 10 20 and 2714 > 1020. Thus n ≤ 13, and since 1 + 27 + · · · + 27n−1 < 27n, and 2 · 27 13 < 1020, it follows that n = 13. 2. This is not secure, since it is just equivalent to a “Ceaser Ci- pher,” that is a permutation of the letters of the alphabet, which is well-known to be easily broken using a frequency analysis. 3. If we can compute the polynomial f = (x−p)(x−q)(x−r) = x3−(p+q+r)x2+(pq+pr+qr)x−pqr, then we can factor n by ﬁnding the roots of f , for example, using Newton’s method (or Cardona’s formula for the roots of a cubic). Because p, q, r, are distinct odd primes, we have ϕ(n) = (p − 1)(q − 1)(r − 1) = pqr − (pq + pr + qr) + p + q + r, and σ(n) = 1 + (p + q + r) + (pq + pr + qr) + pqr. Since we know n, ϕ(n), and σ(n), we know σ(n) − 1 − n = (p + q + r) + (pq + pr + qr), and ϕ(n) − n = (p + q + r) − (pq + pr + qr). We can thus compute both p + q + r and pq + pr + qr, hence deduce f and ﬁnd p, q, r. • Chapter 4. Quadratic Reciprocity 1. They are all 1, −1, 0, and 1. 3. By Proposition 4.3.4, the value of ( 3 p ) depends only on the re- duction ±p (mod 12). List enough primes p such that ±p reduce to 1, 5, 7, 11 modulo 12 and verify that the asserted formula holds for each of them. 7. Since p = 213 − 1 is prime, there are either two solutions or no solutions to x2 ≡ 5 (mod p), and we can decide which using quadratic reciprocity. We have ( 5 p ) = (−1)(p−1)/2·(5−1)/2 ( p 5 ) = ( p 5 ) , so there are two solutions if and only if p = 2 13 − 1 is ±1 mod 5. In fact, p ≡ 1 (mod 5), so there are two solutions. 8. We have 4 48 = 2 96. By Euler’s Theorem, 296 = 1, so x = 1. 6.6 Exercises 153 9. For (a), take a = 19 and n = 20. We found this example us- ing the Chinese remainder theorem applied to 4 (mod 5) and 3 (mod 4), and used that ( 19 20 ) = ( 19 5 ) · ( 19 4 ) = (−1)(−1) = 1, yet 19 is not a square modulo either 5 or 4, so is certainly not a square modulo 20. 10. Hint: First reduce to the case that 6k − 1 is prime, by using that if p and q are primes not of the form 6k − 1, then neither is their product. If p = 6k − 1 divides n2 + n + 1, it divides 4n2 + 4n + 4 = (2n + 1)2 + 3, so −3 is a quadratic residue modulo p. Now use quadratic reciprocity to show that −3 is not a quadratic residue modulo p. • Chapter 5. Continued Fractions 9. Suppose n = x2 + y2, with x, y ∈ Q. Let d be such that dx, dy ∈ Z. Then d2n = (dx)2 + (dy) 2 is a sum of two integer squares, so by Theorem 5.7.1, if p | d 2n and p ≡ 3 (mod 4), then ordp(d 2n) is even. We have ordp(d 2n) is even if and only if ordp(n) is even, so Theorem 5.7.1 implies that n is also a sum of two squares. 11. The squares modulo 8 are 0, 1, 4, so a sum of two squares reduces modulo 8 to one of 0, 1, 2, 4, or 5. Four consecutive integers that are sums of squares would reduce to four consecutive integers in the set {0, 1, 2, 4, 5}, which is impossible. • Chapter 6. Elliptic Curves 2. The second point of intersection is (129/100, 383/1000). 3. The group is cyclic of order 9, generated by (4, 2). The elements of E(K) are {O, (4, 2), (3, 4), (2, 4), (0, 4), (0, 1), (2, 1), (3, 1), (4, 3)}. 4. In part (a), the pattern is that Np = p + 1. For part (b), a hint is that when p ≡ 2 (mod 3), the map x 7→ x3 on (Z/pZ)∗ is an automorphism, so x 7→ x3 + 1 is a bijection. Now use what you learned about squares in Z/pZ from Chapter 4. 5. For all suﬃciently large real x, the equation y2 = x3 + ax + b has a real solution y. Thus, the group E(R) is not countable, since R is not countable. But any ﬁnitely generated group is countable. 6. In a course on abstract algebra, one often proves the nontrivial fact that every subgroup of a ﬁnitely generated abelian group is ﬁnitely generated. In particular, the torsion subgroup Gtor is 154 6. Elliptic Curves ﬁnitely generated. However, a ﬁnitely generated abelian torsion group is ﬁnite. 7. Hint: Multiply both sides of y2 = x3 + ax + b by a power of a common denominator, and “absorb” powers into x and y. 8. Hint: see Exercise 4.6. This is page 155 Printer: Opaque this References [ACD+99] K. Aardal, S. Cavallar, B. Dodson, A. Lenstra, W. Lioen, P. L. Montgomery, B. Murphy, J. Gilchrist, G. Guillerm, P. Leyland, J. Marchand, F. Morain, A. Muﬀett, C.&C. Putnam, and P. Zim- mermann, Factorization of a 512-bit RSA key using the Number Field Sieve, http://www.loria.fr/~zimmerma/records/RSA155 (1999). [AGP94] W. R. Alford, Andrew Granville, and Carl Pomerance, There are inﬁnitely many Carmichael numbers, Ann. of Math. (2) 139 (1994), no. 3, 703–722. MR 95k:11114 [AKS02] M. Agrawal, N. Kayal, and N. Saxena, PRIMES is in P , to appear in Annals of Math., http://www.cse.iitk.ac.in/users/manindra/primality.ps (2002). [BS76] Leonard E. Baum and Melvin M. Sweet, Continued fractions of algebraic power series in characteristic 2, Ann. of Math. (2) 103 (1976), no. 3, 593–610. MR 53 #13127 [Bur89] D. M. Burton, Elementary Number Theory, second ed., W. C. Brown Publishers, Dubuque, IA, 1989. MR 90e:11001 [Cal] C. Caldwell, The Largest Known Primes, http://www.utm.edu/research/primes/largest.html. 156 References [Cer] Certicom, The certicom ECC challenge, http://www.certicom.com/ index.php?action=res,ecc challenge. [Cla] Clay Mathematics Institute, Millennium prize problems, http://www.claymath.org/millennium prize problems/. [Coh] H. Cohn, A short proof of the continued fraction expansion of e, http://research.microsoft.com/~cohn/publications.html. [Coh93] H. Cohen, A Course in Computational Algebraic Number Theory, Graduate Texts in Mathematics, vol. 138, Springer-Verlag, Berlin, 1993. MR 94i:11105 [Con97] John H. Conway, The Sensual (Quadratic) Form, Carus Mathe- matical Monographs, vol. 26, Mathematical Association of Amer- ica, Washington, DC, 1997, With the assistance of Francis Y. C. Fung. MR 98k:11035 [CP01] R. Crandall and C. Pomerance, Prime Numbers, Springer-Verlag, New York, 2001, A computational perspective. MR 2002a:11007 [Cre] J. E. Cremona, mwrank (computer software), http://www.maths.nott.ac.uk/personal/jec/ftp/progs/. [Cre97] , Algorithms for modular elliptic curves, second ed., Cam- bridge University Press, Cambridge, 1997. [Dav99] H. Davenport, The Higher Arithmetic, seventh ed., Cambridge University Press, Cambridge, 1999, An introduction to the theory of numbers, Chapter VIII by J. H. Davenport. MR 2000k:11002 [DH76] W. Diﬃe and M. E. Hellman, New directions in cryptography, IEEE Trans. Information Theory IT-22 (1976), no. 6, 644–654. MR 55 #10141 [Eul85] Leonhard Euler, An essay on continued fractions, Math. Systems Theory 18 (1985), no. 4, 295–328, Translated from the Latin by B. F. Wyman and M. F. Wyman. MR 87d:01011b [FT93] A. Fr¨ohlich and M. J. Taylor, Algebraic Number Theory, Cam- bridge University Press, Cambridge, 1993. MR 94d:11078 [Guy94] R. K. Guy, Unsolved Problems in Number Theory, second ed., Springer-Verlag, New York, 1994, Unsolved Problems in Intuitive Mathematics, I. MR 96e:11002 [GZ86] B. Gross and D. Zagier, Heegner points and derivatives of L- series, Invent. Math. 84 (1986), no. 2, 225–320. MR 87j:11057 References 157 [Har77] R. Hartshorne, Algebraic Geometry, Springer-Verlag, New York, 1977, Graduate Texts in Mathematics, No. 52. [Hoo67] C. Hooley, On Artin’s conjecture, J. Reine Angew. Math. 225 (1967), 209–220. MR 34 #7445 [HW79] G. H. Hardy and E. M. Wright, An Introduction to the Theory of Numbers, ﬁfth ed., The Clarendon Press Oxford University Press, New York, 1979. MR 81i:10002 [IBM01] IBM, IBM’s Test-Tube Quantum Computer Makes History, http://www.research.ibm.com/resources/news/ 20011219 quantum.shtml. [IR90] K. Ireland and M. Rosen, A Classical Introduction to Modern Number Theory, second ed., Springer-Verlag, New York, 1990. MR 92e:11001 [Khi63] A. Ya. Khintchine, Continued fractions, Translated by Peter Wynn, P. Noordhoﬀ Ltd., Groningen, 1963. MR 28 #5038 [Knu97] Donald E. Knuth, The Art of Computer Programming, third ed., Addison-Wesley Publishing Co., Reading, Mass.-London- Amsterdam, 1997, Volume 1: Fundamental algorithms, Addison- Wesley Series in Computer Science and Information Processing. [Knu98] , The Art of Computer Programming. Vol. 2, second ed., Addison-Wesley Publishing Co., Reading, Mass., 1998, Seminu- merical algorithms, Addison-Wesley Series in Computer Science and Information Processing. MR 83i:68003 [Kob84] N. Koblitz, Introduction to Elliptic Curves and Modular Forms, Graduate Texts in Mathematics, vol. 97, Springer-Verlag, New York, 1984. MR 86c:11040 [Leh14] D. N. Lehmer, List of Primes Numbers from 1 to 10,006,721, Carnegie Institution Washington, D.C. (1914). [Lem] F. Lemmermeyer, Proofs of the Quadratic Reciprocity Law, http://www.rzuser.uni-heidelberg.de/~hb3/rchrono.html. [Len87] H. W. Lenstra, Jr., Factoring integers with elliptic curves, Ann. of Math. (2) 126 (1987), no. 3, 649–673. MR 89g:11125 [LL93] A. K. Lenstra and H. W. Lenstra, Jr. (eds.), The Development of the Number Field Sieve, Lecture Notes in Mathematics, vol. 1554, Springer-Verlag, Berlin, 1993. MR 96m:11116 158 References [LMG+01] Vandersypen L. M., Steﬀen M., Breyta G., Yannoni C. S., Sher- wood M. H., and Chuang I. L., Experimental realization of Shor’s quantum factoring algorithm using nuclear magnetic resonance, Nature 414 (2001), no. 6866, 883–887. [LT72] S. Lang and H. Trotter, Continued fractions for some algebraic numbers, J. Reine Angew. Math. 255 (1972), 112–134; addendum, ibid. 267 (1974), 219–220; MR 50 #2086. MR 46 #5258 [LT74] , Addendum to: Continued fractions for some algebraic numbers (J. Reine Angew. Math. 255 (1972), 112–134), J. Reine Angew. Math. 267 (1974), 219–220. MR 50 #2086 [Mor93] P. Moree, A note on Artin’s conjecture, Simon Stevin 67 (1993), no. 3-4, 255–257. MR 95e:11106 [MS08] B. Mazur and W. Stein, What is Riemann’s Hypothesis?, 2008, In preparation. [NZM91] I. Niven, H. S. Zuckerman, and H. L. Montgomery, An Introduc- tion to the Theory of Numbers, ﬁfth ed., John Wiley & Sons Inc., New York, 1991. MR 91i:11001 [Old70] C. D. Olds, The Simple Continued Fraction Expression of e, Amer. Math. Monthly 77 (1970), 968–974. [Per57] O. Perron, Die Lehre von den Kettenbr¨uchen. Dritte, verbesserte und erweiterte Auﬂ. Bd. II. Analytisch-funktionentheoretische Kettenbr¨uche, B. G. Teubner Verlagsgesellschaft, Stuttgart, 1957. MR 19,25c [RSA] RSA, The New RSA Factoring Challenge, http://www.rsasecurity.com/rsalabs/challenges/factoring. [RSA78] R. L. Rivest, A. Shamir, and L. Adleman, A method for obtaining digital signatures and public-key cryptosystems, Comm. ACM 21 (1978), no. 2, 120–126. MR 83m:94003 [Sag08] Sage, Free Open Source Mathematical Software (Version 3.0.4), 2008, http://www.sagemath.org. [Sch85] R. Schoof, Elliptic curves over ﬁnite ﬁelds and the computation of square roots mod p, Mathematics of Computation 44 (1985), no. 170, 483–494. [Sho97] P. W. Shor, Polynomial-time algorithms for prime factorization and discrete logarithms on a quantum computer, SIAM J. Com- put. 26 (1997), no. 5, 1484–1509. MR 98i:11108 References 159 [Sho05] V. Shoup, A Computational Introduction to Number Theory and Algebra, Cambridge University Press, Cambridge, 2005. MR MR2151586 (2006g:11003) [Sil86] J. H. Silverman, The arithmetic of elliptic curves, Graduate Texts in Mathematics, vol. 106, Springer-Verlag, New York, 1986. MR 87g:11070 [Sin99] S. Singh, The Code Book: The Science of Secrecy from Ancient Egypt to Quantum Cryptography, Doubleday, 1999. [Slo] N. J. A. Sloane, The On-Line Encyclopedia of Integer Sequences, http://www.research.att.com/~njas/sequences/. [ST92] J. H. Silverman and J. Tate, Rational points on elliptic curves, Un- dergraduate Texts in Mathematics, Springer-Verlag, New York, 1992. MR 93g:11003 [Wal48] H. S. Wall, Analytic Theory of Continued Fractions, D. Van Nos- trand Company, Inc., New York, N. Y., 1948. MR 10,32d [Wei03] E. W. Weisstein, RSA-576 Factored, http://mathworld.wolfram.com/news/2003-12-05/rsa/. [Wil00] A. J. Wiles, The Birch and Swinnerton-Dyer Conjecture, http://www.claymath.org/prize problems/birchsd.htm. [Zag75] D. Zagier, The ﬁrst 50 million prime numbers, http://modular.fas.harvard.edu/scans/papers/zagier/. This is page 160 Printer: Opaque this Index B-power smooth, 129 ⌈x⌉, 62 Z/nZ, 21 ( a p ), 70 abelian group, 22 algebraic number, 114 algorithm, 4 Chinese Remainder Theorem, 29 Compute Power, 35 Division Algorithm, 5 Elliptic Curve Factorization Method, 133 Elliptic Curve Group Law, 126 Extended Euclidean Algorithm, 33 Greatest Common Division, 5 Inverse Modulo n, 33 Least Common Multiple of First B Integers, 129 Miller-Rabin Primality Test, 38 Pollard p − 1 Method, 130 Prime Sieve, 12 Primitive Root, 44 Probabilistic Algorithm to Fac- tor n, 64 Write a number in binary, 34 Artin, 43 Artin’s conjecture, 43 binary, writing number in, 34 cancellation proposition, 23 Carmichael numbers, 37 Certicom challenges, 139 Chinese remainder theorem, 29 commutative ring, 22 complete set of residues, 24, 24 composite, 2 compute continued fraction, 101 gcd, 5 greatest common divisor, 4 inverse modulo n, 31 powers modulo n, 31, 34 square roots mod p, 86–89 congruences, 22 Index 161 congruent number, 142 157 is, 143 all ≤ 50 are, 142 and arithmetic progression, 143 and elliptic curves, 143 problem, 142 why called congruent, 143 congruent number criterion propo- sition, 144 congruent numbers and elliptic curves proposition, 143 conjecture Artin, 43 continued fraction, 94, 94–122 algorithm, 101 convergents, 99 every rational number has, 100 of 3√2, 114 of √2, 111 of e, 103, 107 of algebraic number, 115 of ﬁnite length, 95 of higher degree number, 114 of quadratic irrational, 110 partial convergents of, 97 periodic, 111 recognizing rational numbers, 115 continued fraction convergence the- orem, 105 continued fraction existence the- orem, 106 continued fraction limit theorem, 104 continued fraction procedure, 107 continued fraction process, 102 convergence of continued fraction proposition, 107 convergent, 97 convergents partial, 99 convergents in lowest terms corol- lary, 98 corollary convergents in lowest terms, 98 cryptography, 13 using elliptic curves, 135 cryptosystem Diﬃe-Hellman, 50, 51 ElGamal, 136, 137 RSA, 56–66 decryption key proposition, 57 density of primes, 14 deterministic primality test, 38 Diﬃe-Hellman cryptosystem, 50, 51 on elliptic curve, 135 digital signatures, 56 Dirichlet theorem, 14 discrete log problem, 52, 53 diﬃculty of, 53 on elliptic curve, 136 on elliptic curve, 138 divides, 2, 2 divisibility by 3 proposition, 23 divisibility tests, 23 division algorithm, 5 divisor, 2 does not divide, 2 ECM, 129 ElGamal cryptosystem, 136, 137 elliptic curve, 124 and congruent numbers, 143 cryptography, 135 Diﬃe-Hellman, 135 discrete log problem, 136, 138 factorization, 129, 133 group structure, 125 rank, 142 rational points on, 140 torsion subgroup, 140 elliptic curve discrete log problem, 138 elliptic curve group law theorem, 126 equivalence relation 162 Index congruence modulo n, 22 Euclid, 2 Euclid theorem, 7 Euclid’s theorem on divisibility, 7 Euler, 73, 107 phi function, 22, 26, 30 is multiplicative, 31 Euler ϕ-function, 30 Euler proposition, 78 Euler’s criterion proposition, 73 Euler’s proposition, 77 Euler’s theorem, 25, 26 group-theoretic interpretation, 26 extended Euclidean algorithm, 33 extended Euclidean proposition, 32 factorization and breaking RSA, 61, 63 diﬃculty of, 8 Pollard’s (p−1)-method, 129– 132 quantum, 8 using elliptic curves, 129 Fermat Factorization Method, 62 ﬁeld, 23 of integers modulo p, 23, 46 ﬁnite continued fraction, 95 ﬁnite ﬁeld, 23 ﬂoor, 102 fundamental theorem of arithmetic, 3, 7, 10 Gauss, 15, 69, 72, 73, 75 Gauss sum, 82 Gauss sum proposition, 82 Gauss’s lemma, 75 gcd, 3 gcd algorithm, 5 Generalized Riemann Hypothesis, 44 geometric group law proposition, 126 graph of group law, 127 greatest common divisor, 3 group, 22 (Z/mZ) ∗, 26 of units, 22 structure of elliptic curve, 125 group homomorphism, 64 group law illustrated, 127 Hadamard, 16 homomorphism of rings, 87 Hooley, 44 how convergents converge propo- sition, 100 inﬁnitely many primes proposition, 13 inﬁnitely many primes theorem, 11 inﬁnitely many triangles theorem, 145 injective, 64 integers, 2 factor, 7 factor uniquely, 3, 10 modulo n, 22 integers modulo n, 22 isomorphism, 87 joke, 11 kernel, 64 Lagrange, 27 Lang, 114 largest known elliptic curve rank, 142 prime, 12 value of π(x), 16 Legendre Symbol, 70 Legendre symbol of 2 proposition, 80 Lenstra, 11, 129–133 lift, 23 Index 163 linear equations modulo n, 23 long division proposition, 4 man in the middle attack, 56 Mazur theorem, 141 Mersenne prime, 13 Michael, 56, 135, 137 modular arithmetic and linear equations, 23 order of element, 25 Mordell, 140 Mordell theorem, 140 multiplicative, 31 functions, 30 order, 22 multiplicative of Euler’s function proposition, 31 natural numbers, 2 Nikita, 61, 135, 137 normal, 46 notation, x number of primitive roots propo- sition, 43 one-way function, 56 open problem congruent numbers, 142 decide if congruent number, 143 fast integer factorization, 8 order, 25, 42 of element, 25 partial convergents, 97 partial convergents proposition, 97 period continued fraction theorem, 112 period of the continued fraction, 111 periodic continued fraction, 111 ϕ function, 22 phi function is multiplicative, 31 Pieter, 44 Pollard’s (p−1)-method, 129–132 polynomial time, 8 polynomials over Z/pZ, 40 power smooth, 129 powering algorithm, 34 primality test deterministic, 38 Miller-Rabin, 37 probabilistic, 31 pseudoprime, 36 prime, 2 prime factorization proposition, 7 prime number theorem, 11, 16 primes, 2 density of, 14 inﬁnitely many, 11 largest known, 12 Mersenne, 13 of form 4x − 1, 13 of form ax + b, 13 of the form 6x − 1, 19 sequence of, 10 testing for, 36 primitive, 81, 118 representation, 118 primitive root, 40 existence, 42 mod power of two, 40 primitive root mod prime powers theorem, 43 primitive root of unity, 81 primitive root theorem, 42 proposition cancellation, 23 congruent number criterion, 144 congruent numbers and ellip- tic curves, 143 convergence of continued frac- tion, 107 decryption key, 57 divisibility by 3, 23 Euler, 78 Euler’s criterion, 73 164 Index extended Euclidean, 32 Gauss sum, 82 geometric group law, 126 how convergents converge, 100 inﬁnitely many primes, 13 Legendre symbol of 2, 80 long division, 4 multiplicative of Euler’s func- tion, 31 number of primitive roots, 43 partial convergents, 97 prime factorization, 7 rational continued fractions, 100 root bound, 40 solvability, 25 units, 24 Wilson, 27 Pseudoprimality theorem, 36 pseudoprime, 36 public key, 57 quadratic irrational, 111 continued fraction of, 110 quadratic nonresidue, 70 quadratic reciprocity, 69 elementary proof, 75–81 Gauss sums proof, 81 quadratic reciprocity theorem, 72 quadratic residue, 70 quantum computer, 8, 53 rank, 141, 142 rational continued fractions propo- sition, 100 rational point, 140 recognizing rational numbers, 115 reduction modulo n, 23 Riemann Hypothesis, 18 Riemann Hypothesis, 11, 15 bound on π(x), 18 ring, 22 root bound proposition, 40 root of unity, 81 primitive, 81 RSA cryptosystem, 56–66 RSA-155, 9 RSA-576, 8 Shor, 8, 53 simple continued fraction, 95 smooth, 129 solvability proposition, 25 square roots how to ﬁnd mod p, 86–89 squares sum of two, 117 subgroup, 64 sum of two squares theorem, 117 sums of two squares, 117 surjective, 64 table comparing π(x) to x/(log(x)− 1), 17 values of π(x), 16 when 5 a square mod p, 72 The Man, 56 theorem Chinese remainder, 29 continued fraction convergence, 105 continued fraction existence, 106 continued fraction limit, 104 Dirichlet, 14 elliptic curve group law, 126 Euclid, 7 Euler’s, 25, 26 inﬁnitely many primes, 11 inﬁnitely many triangles, 145 Mazur, 141 Mordell, 140 of Dirichlet, 11 of Wilson, 27 period continued fraction, 112 prime number, 16 primitive root, 42 primitive root mod prime pow- ers, 43 Index 165 Pseudoprimality, 36 quadratic reciprocity, 72 sum of two squares, 117 unique factorization, 3 torsion subgroup, 140 Trotter, 114 unique factorization, 3 unique factorization theorem, 3 unit group, 22 units of Z/pZ are cyclic, 39 roots of unity, 81 units proposition, 24 Vall´ee Poussin, 16 Wilson proposition, 27 Wilson’s theorem, 27 Zagier, 143","libVersion":"0.3.1","langs":""}