{"path":"iCloudDrive/bks/Number Theory/Number Theory 2/Franz/Algebraic NT/ch7.pdf","text":"Chapter 7 The Theorem of Euler-Fermat In this chapter we will discuss the generalization of Fermat’s Little Theorem to composite values of the modulus. We will also discuss applications in cryptog- raphy. 7.1 The Theorem of Euler-Fermat Consider the unit group (Z/15Z) × of Z/15Z. It consists of the eight residue classes [1], [2], [4], [7], [8], [11], [13], [14]. If we multiply each of these classes e.g. by [7] (or [8], [9]), then we get [1] · [7] = [7] [1] · [8] = [8] [1] · [9] = [9] [2] · [7] = [14] [2] · [8] = [1] [2] · [9] = [3] [4] · [7] = [13] [4] · [8] = [2] [4] · [9] = [6] [7] · [7] = [4] [7] · [8] = [11] [7] · [9] = [3] [8] · [7] = [11] [8] · [8] = [4] [8] · [9] = [12] [11] · [7] = [2] [11] · [8] = [13] [11] · [9] = [9] [13] · [7] = [1] [13] · [8] = [14] [13] · [9] = [12] [14] · [7] = [8] [14] · [8] = [7] [14] · [9] = [6] As in our proof of Fermat’s Little Theorem, the resulting residue classes (for multiplication by [7] and [8]) are the classes we started with in a diﬀerent order. Multiplying these equations we get ∏ (a,15)=1[a] = ∏ (a,15)=1[7a] = [7] 8 ∏ (a,15)=1[a]. Since the a are coprime to 15, so is their product; thus we may cancel, and we ﬁnd [7] 8 = [1], or 7 8 ≡ 1 mod 15. Similarly, we ﬁnd 88 ≡ 1 mod 15; for multiplication by 9, however, the classes on the right hand side diﬀer from 66 those on the left (they’re all divisible by 3 since both 9 and 15 are), and we do not get 9 8 ≡ 1 mod 15. The same idea works in general. Let m ≥ 2 be an integer, and let ϕ(m) denote the number of residue classes coprime to m, that is, ϕ(m) = #(Z/mZ) ×. Then we have the following result, which is usually referred to as the Euler- Fermat Theorem: it is due to Euler, but contains Fermat’s Little Theorem as a special case. Theorem 7.1. If a is an integer coprime to m ≥ 2, then a ϕ(m) ≡ 1 mod m. For m = p prime, we have ϕ(p) = p − 1, and Euler’s Theorem becomes Fermat’s Little Theorem. Proof. Let [ri], i = 1, . . . , t = ϕ(m), denote the residue classes in (Z/mZ) ×. Then we claim that [ar1], . . . , [art] are pairwise distinct. In fact, assume that [ari] = [arj] with i ̸= j, that is, ari ≡ arj mod m. Since gcd(a, m) = 1, we may cancel a, and get [ri] = [rj]: contradiction. Since the classes [ar1], . . . , [art] are all in (Z/mZ) × and diﬀerent, and since there are only t diﬀerent classes in (Z/mZ) ×, we must have (Z/mZ) × = {[ar1], . . . , [art]}. But then ∏t i=1[ri] = ∏t i=1[ari] = [a] ϕ(m) ∏t i=1[ri]. Since the [ri] are coprime to m, so is their product. Cancelling then gives [a] ϕ(m) = [1], which proves the claim. 7.2 Euler’s Phi Function For the application of Euler-Fermat we need a formula that allows us to compute ϕ(n). Let us ﬁrst compute ϕ(n) directly for some small n. For n = 6, there are 6 diﬀerent residue classes modulo 6; the classes [0], [2], [3] and [4] are not coprime to 6 (or, in other words, do not have a multiplicative inverse), which leaves the classes [1] and 5 as the only ones that are coprime to 6: thus ϕ(6) = 2. The classes mod 8 coprime to 8 are [1], [3], [5], [7], hence ϕ(8) = 4. If p is prime, then all the p − 1 classes [1], [2], . . . , [p − 1] are coprime to p, hence ϕ(p) = p − 1. n 3 4 5 6 7 8 9 10 12 15 ϕ(n) 2 2 4 2 6 4 6 4 4 8 We can easily compute ϕ(pk) (Euler’s phi function for prime powers): start- ing with all the nonzero classes [1], [2], . . . , [p2 − 1] (there are p2 − 1 of them) we have to eliminate those that are not coprime to p2, that is, exactly the multiples of p smaller than p2: these are p, 2p, 3p, . . . , (p − 1)p (note that p · p = p2 > p2 − 1); since there are exactly p − 1 of these multiples of p, there will be exactly p2 − 1 − (p − 1) = p2 − p = p(p − 1) classes left: thus ϕ(p2) = p(p − 1). The same method works for pk: there are exactly pk − 1 nonzero classes, namely [1], [2], . . . , [pk − 1]. The multiples of p among these classes are [p], [2p], . . . , pk − p = (pk−1 − 1)p, and there are exactly pk−1 − 1 of them. Thus ϕ(pk) = pk − 1 − (pk−1 − 1) = pk − pk−1 = pk−1(p − 1). 67 We have proved Proposition 7.2. For primes p and integers k ≥ 1, we have ϕ(pk) = pk−1(p − 1). Let us now compute ϕ(pq) for a product of two diﬀerent primes. We have pq − 1 nonzero residue classes [1], [2], . . . , [pq − 1]. The classes that have a factor in common with pq are multiples of p and multiples of q, namely [p], [2p], . . . , [(q − 1)p and [q], [2q], . . . , [(p − 1)q]. Since there are no multiples of p that are multiples of q (like [0], [pq], etc) among these, there will be exactly pq − 1 − (p − 1) − (q − 1) = pq − p − q + 1 = (p − 1)(q − 1) classes left after eliminating multiples of p or q. Thus ϕ(pq) = (p − 1)(q − 1) = ϕ(p)ϕ(q). The general result is Proposition 7.3. If m and n are coprime integers, then ϕ(mn) = ϕ(m)ϕ(n). Before we turn to the proof, let’s see how it works in a speciﬁc example like m = 5 and n = 3. What we’ll do is take a residue class modulo 15 and coprime to 15, and map it to a pair of residue classes mod 3 and mod 5: a mod 15 1 2 4 7 8 11 13 14 a mod 3 1 2 1 1 2 2 1 2 a mod 5 1 2 4 2 3 1 3 4 Thus we have the following pairs of residue classes modulo 3 and 5: (1, 1), (1, 2), (1, 3), (1, 4) and (2, 1), (2, 2), (2, 3), (2, 4). In particular, there are ϕ(5) = 4 pairs with a ≡ 1 mod 3 and 4 pairs with a ≡ 2 mod 3. Proof of Prop. 7.3. We have to ﬁnd a map sending a residue class modulo mn to two residue classes modulo m and n. Let’s try ψ : (Z/mnZ) × −→ (Z/mZ) × × (Z/nZ) × : [a]mn 7−→ ([a]m, [a]n). All that’s left to do is check that it works. First observe that gcd(ab, n) = 1 if and only if gcd(a, n) = gcd(b, n) = 1. Surjectivity: We have to show that, given residue classes [r]m and [s]n, there exists a residue class [a]mn such that [a]m = [r]m and [a]n = [s]n. At this point, Bezout comes in again: since gcd(m, n) = 1, there exist x, y ∈ Z such that 1 = mx + ny. Now put a = ryn + sxm: then a = ryn + sxm ≡ ryn ≡ 1 mod m since yn ≡ 1 mod m from the Bezout representation, and similarly a = ryn + sxm ≡ sxm ≡ s mod n. Injectivity: Assume that there are residue classes [a]mn and [b]mn such that [a]m = [b]m and [a]n = [b]n. Then m | (b − a) and n | (b − a), and since gcd(m, n) = 1, this implies that [a]mn = [b]mn and proves the injectivity of ϕ. Here is how one could come up with the application of Bezout in the above proof. Given coprime residue classes r mod m and s mod m, we want a formula 68 for computing an integer a such that a ≡ r mod m and a ≡ s mod n. The ﬁrst idea is to see whether a can be written as a linear combination of r and s, that is, to look for integers x, y such that a = xr + ys. Reduction modulo m gives r ≡ a = xr + ys mod m. (7.1) The simplest way to achieve this is by taking x = 1 and y = 0. But observe that we also need s ≡ a ≡ xr + ys mod n. (7.2) Thus we need more leeway. The right idea is to observe that (7.1) will be satisﬁed if only x ≡ 1 mod m, y ≡ 0 mod m. Similarly, (7.2) will be satisﬁed if x ≡ 0 mod n and y ≡ 1 mod n. Is it possible to satisfy these four congruences simultaneously? Let’s see: x ≡ 0 mod n and y ≡ 0 mod m mean x = an and y = bm for some a, b ∈ Z. The two other congruences boil down to x = an ≡ 1 mod m and y = bm ≡ 1 mod n. But these are both solvable since gcd(m, n) = 1, so n has an inverse a modulo m, and m has an inverse b modulo n. Inverses can be computed using Bezout, and collecting everything we now can see where the formulas in the above proof were coming from. Combining the formulas for Euler’s phi function for prime powers and for products of coprime integers, we now ﬁnd that an integer m = pa1 1 · · · par r has exactly ϕ(m) = (p1 − 1)pa1−1 1 · · · (pr − 1)par−1 r = pa1 1 · · · par r · p1 − 1 p1 · · · pr − 1 pr = m (1 − 1 p1 ) · · · (1 − 1 pr ) residue classes coprime to m. Chinese Remainder Theorem In the proof of the multiplicativity of Euler’s phi function we have shown that, given a system of congruences x ≡ a mod m y ≡ b mod n can always be solved if m and n are coprime. This result, or rather its gener- alization to system of arbitrarily many such congruences, is called the Chinese Remainder Theorem. 69 The Abstract Version There is more to the bijection ψ : (Z/mnZ) × −→ (Z/mZ) × × (Z/nZ) × : [a]mn 7−→ ([a]m, [a]n) constructed above than meets the eye: we claim that ψ induces an isomorphism (Z/mnZ) × −→ (Z/mZ) × × (Z/nZ) ×. A homomorphism between groups (G, ◦) and (H, ∗) is a map f : G −→ H that respects the group laws in the sense that we have f (g ◦ g′) = f (g) ∗ f (g′). Here are some examples: 1. the exponential function is a homomorphism exp : (R, +) −→ (R>0, ·) because exp(a + b) = exp(a) exp(b). 2. the logarithm is a homomorphism log : (R>0, ·) −→ (R, +) because log ab = log a + log b. Note that exp and log are inverse maps of each other. 3. The set C ∞ of all inﬁnitely often diﬀerentiable functions (0, 1) −→ R is an additive group, and d dx : C ∞ −→ C ∞ is a homomorphism because (f + g) ′ = f ′ + g′. 4. If f : V −→ W is a linear map between K-vector spaces V and W , then f is also a homomorphism between the additive groups (V, +) and (W, +). 5. The map ψ : (Z/mnZ) × −→ (Z/mZ) × × (Z/nZ) × is a homomorphism. In fact we have ψ([ab]mn) = ([ab]m, [ab]n), ψ([a]mn) = ([a]m, [a]n), ψ([b]mn) = ([b]m, [b]n), and by the group law in direct products we see that ψ([ab]mn) = ψ([a]mn)ψ([b]mn). If (G, ◦) and (H, ∗) are groups, then the cartesian product G × H can be given a group structure by deﬁning (g, h)(g′, h′) = (g ◦ g′, h ◦ h′). Checking the axioms is straightforward. Also, if G × H is abelian if and only if G and H are. Observe that if f : G −→ H is a homomorphism between additively written groups, then f (0) = 0 and f (−g) = −f (g). This follows easily from the axioms. Since we have already seen that ψ is bijective, we can conclude that it is an isomorphism. Note that for any bijective homomorphism f : G −→ H there exists a homomorphism g : H −→ G such that f ◦ g and g ◦ f are the identity maps on H and G, respectively. We can play this game also with rings: a map from a ring R to some ring S is called a ring homomorphism if f (r + r′) = f (r) + f (r′), f (rr′) = f (r)f (r′), and f (1) = 1. It is then easy to show that ψ actually induces a ring isomorphism Z/mnZ −→ Z/mZ × Z/nZ: this is the abstract formulation of the Chinese Remainder Theorem. 70 7.3 The Order of Residue Classes Assume that we are given an integer m and an integer a coprime to m. The smallest exponent n > 0 such that a n ≡ 1 mod m is called the order of a mod m; we write n = ord m(a). Note that we always have ord m(1) = 1. Here’s a table for the orders of elements in (Z/7Z) ×: a mod 7 1 2 3 4 5 6 ord 7(a) 1 3 6 3 6 2 If m = p is prime, then Fermat’s Little Theorem gives us a p−1 ≡ 1 mod p, i.e., the order of a mod p is at most p − 1. In general, the order of a is not p − 1; it is, however, always a divisor of p − 1 (as the table above suggested): Proposition 7.4. Given a prime p and an integer a coprime to p, let n denote the order of a modulo p. If m is any integer such that a m ≡ 1 mod p, then n | m. In particular, n divides p − 1. Proof. Write d = gcd(n, m) and d = nx + my; then a d = a nx+my ≡ 1 mod p since a n ≡ a m ≡ 1 mod p. The minimality of n implies that n ≤ d, but then d | n shows that we must have d = n, hence n | m. Here comes a pretty application to prime divisors of Mersenne and Fermat numbers. Corollary 7.5. If p is an odd prime and if q | Mp, then q ≡ 1 mod 2p. Proof. It suﬃces to prove this for prime values of q (why?). So assume that q | 2p − 1; then 2 p ≡ 1 mod q. By Proposition 7.4, the order of 2 mod p divides p, and since p is prime, we ﬁnd that p = ord p(a). On the other hand, we also have 2 q−1 ≡ 1 mod p by Fermat’s little theorem, so Proposition 7.4 gives p | (q − 1), and this proves the claim because we clearly have q ≡ 1 mod 2. Example: M11 = 2047 = 23 · 89. Fermat numbers are integers Fn = 2 2n + 1 (thus F1 = 5, F2 = 17, F3 = 257, F4 = 65537, . . . ), and Fermat conjectured (and once even seemed to claim he had a proof) that these integers are all primes. These integers became much more interesting when Gauss succeeded in proving that a regular p-gon, p an odd prime, can be constructed with ruler and compass if p is a Fermat prime. Gauss also stated that he had proved the converse, namely that if a regular p-gon can be constructed by ruler and compass, then p is a Fermat prime, but the ﬁrst (almost) complete proof was given by Pi`erre Wantzel. 1 Corollary 7.6. If q divides Fn, then q ≡ 1 mod 2n+1. 1Pi`erre Wantzel, 1814 (Paris) – 1848 (Paris). 71 Proof. It is suﬃcient to prove this for prime divisors q. Assume that q | Fn; then 22n + 1 ≡ 1 mod q, hence 2 2n ≡ −1 mod q and 2 2n+1 ≡ 1 mod q. We claim that actually 2n+1 = ord q(2): in fact, Proposition 7.4 says that the order divides 2n+1, hence is a power of 2. But 2 n+1 is clearly the smallest power of 2 that does it. On the other hand, 2q−1 ≡ 1 mod q by Fermat’s Little Theorem, and Propo- sition 7.4 gives 2 n+1 | (q − 1), which proves the claim. In particular, the possible prime divisors of F5 = 4294967297 are of the form q = 64m + 1. After a few trial divisions one ﬁnds F5 = 641 · 6700417. This is how Euler disproved Fermat’s conjecture. Today we know the prime factorization of Fn for all n ≤ 11, we know that Fn is composite for 5 ≤ n ≤ 30 (and several larger values up to n = 382447), and we don’t know any factors for n = 14, 20, 22 and 24. See http://www.prothsearch.net/fermat.html for more. 7.4 RSA Cryptography deals with methods that allow us to transmit information safely, that is, in such a way that eavesdroppers have no chance of reading it. Simple methods for encrypting messages were known and widely used in military circles for several millenia; basically all of these codes are easy to break with computers. An example of such a classical code is Caesar’s cipher: permute the letters of the alphabet by sending X 7−→ A, Y 7−→ B, Z 7−→ C, A 7−→ D etc; the text “ET TU, BRUTE” would be encrypted as “BQ QR, YORQB”. For longer texts, analyzing the frequency of letters (for given languages) makes breaking this and similar codes a breeze, in particular if you are equipped with a computer. Another common feature of these ancient methods of encrypting messages is the following: anyone who knows the key, that is, the method with which messages are encrypted, can easily break the code by inverting the encryption. In 1976, Diﬃe and Hellman suggested the existence of public key cryptography: these are methods for encrypting messages that do not allow you to read en- crypted messages even if you know the key. The most famous of all public key cryptosystems is called RSA after its discoverers Ramir, Shamir and Adleman (1978). Here’s the simple idea: assume that Bob wants to receive secure messages; he selects two (large) primes p and q and forms their product n = pq. Bob also chooses an integer E < n coprime to (p − 1)(q − 1). The integers n and E are made public and constitute the key, so everybody can encrypt messages. For decrypting messages, however, one needs to know the prime factors p and q, and if p and q are large enough (say about 150 digits each) then known factorization methods cannot factor n in any reasonable amount of time (say 100 years). How does the encryption work? It is a simple matter to transform any text into a sequence of numbers, for example by using a 7−→ 01, b → 02, . . . , with a 72 couple of extra numbers for blanks, commas, etc. We may therefore assume that our message is a sequence of integers T < n (if the text is longer, break it up into smaller pieces). Alice encrypts each integer T as C ≡ T E mod n and sends the sequence of C’s to Bob (by email, say). Now Bob can decrypt the message as follows: since he knows p and q, he can form the product m = (p − 1)(q − 1) and run the Euclidean algorithm on the pair (E, m) to ﬁnd an integer D such that DE ≡ 1 mod m. Now he takes the message C and computes C D mod n. The result is C D ≡ (T E) D = T DE mod n, but since DE ≡ 1 mod m = ϕ(n), the theorem of Euler-Fermat shows that C D ≡ T mod n, and Bob has got the original text that Alice sent him. Now assume that Celia is eavesdropping. Of course she knows the pair (n, E) (which is public anyway), and she also knows the message C that Alice sent to Bob. That does not suﬃce for decrypting the message, however, since one seems to need an inverse D of E mod (p − 1)(q − 1) to do that; it is likely that one needs to know the factors of n in order to compute D. Baby Example. The following choice of n = 1073 with p = 29 and q = 37 is not realistic because this number can be factored easily; its only purpose is to illustrate the method. So assume that Bob picks the key (n, E) = (1073, 25). Alice wants to send the message ”miss piggy” to Bob. She starts by transforming the message into a string of integers as follows: m i s s p i g g y T 13 9 19 19 27 16 9 7 7 25 Next she encrypts this sequence by computing C ≡ T 25 mod n for each of these T : starting with 1325 ≡ 671 mod 1073, she ﬁnds T 13 9 19 19 27 16 9 7 7 25 C 671 312 901 901 656 1011 312 922 922 546 Alice sends this string of C’s to Bob. Knowing the prime factorization of n, Bob is able to compute the inverse of 25 mod (p − 1)(q − 1) as follows: he multiplies p − 1 = 28 and q − 1 = 36 to get (p − 1)(q − 1) = 28 · 36 = 1008. Then he applies the extended Euclidean algorithm to (25, 1008) and ﬁnds 1 = 25 · 121 − 1008 · 3, and this shows that D = 121. Now Bob takes the string of C’s he got from Alice and decrypts them: start- ing with 671121 ≡ 13 mod n he can get back the string of T’s, and hence the original message. Remark. There is a big problem with this baby example: if we encrypt the message letter for letter, then equal letters will have equal code, and the cryp- tosystem can be broken (if the message is long enough) by analyzing the fre- quency with which each letter occurs (say in English). This problem vanishes into thin air when we use (realistic) key sizes of about 200 digits: there we en- crypt the message in blocks of about 100 letters, and since the chance that any two blocks of 100 letters inside a message coincide is practically 0, an attack based on the frequency of letters will not be successful for keys of this size. 73 RSA can also be applied to the signature problem. Assume that Alice re- ceives an email from someone claiming to be Bob. How can Alice verify that this is true? Here’s the simple trick in a nutshell: both Bob and Alice choose public keys, say (nA, EA) for Alice and (nB, EB) for Bob. Moreover, Alice knows DA with DAEA ≡ 1 mod ϕ(nA), while Bob knows DB with DBEB ≡ 1 mod ϕ(nB). Now Bob encrypts his message as above, but instead of sending the T’s to Al- ice, he computes U = T DB mod nB and sends the U’s. In order to decrypt the message, Alice computes ﬁrst T ≡ U ED mod nB and then decrypts the T’s as in the original version of RSA using her DA. If this works, then Alice can be sure that the message came from Bob because in order to encrypt the message this way, the sender has to know DB. 7.5 Pollard’s p − 1-Factorization Method Pollard is deﬁnitely the world champion in inventing new methods for factoring integers. One of his earliest contributions were the p − 1-method (ca. 1974), his ρ-method followed shortly after, and his latest invention is the number ﬁeld sieve (which is based on ideas from algebraic number theory). The idea behind Pollard’s p − 1-method is incredibly simple. Assume that we are given an integer N that we want to factor. Fix an integer a > 1 and check that gcd(a, N ) = 1 (should d = gcd(a, N ) be not trivial, then we have already found a factor d and continue with N replaced by N/d). Let p be a factor of N ; by Fermat’s Little Theorem we know that a p−1 ≡ 1 mod p, hence D := gcd(a p−1 − 1, N ) has the properties p | D and D | N . Thus D is a nontrivial factor of N unless D = N (which should not happen too often). The procedure above is not much of a factorization algorithm as long as we have to know the prime factor p beforehand. The prime p occurs at two places in the method above: ﬁrst, as the modulus when computing a p−1 mod p. But this problem is easily taken care of because we may simply compute a p−1 mod N . It is more diﬃcult to get rid of the p in the exponent: the fundamental observation is that we can replace the exponent p − 1 above by any multiple, and D still will be divisible by p (note though that the chance that D = N has become slightly larger). Does this help us? Not always; assume, however, that p − 1 is the product of small primes (say of primes below a bound B that in practice can be taken to be B = 10 5 or B = 10 6, depending on the computing power of your hardware). Then it is not too hard to come up with good candidates for multiples of p − 1: we might simply pick k = B!, or, in a similar vein, k = ∏ i pai i , where pai i ≤ B < p ai+1 i . (7.3) If we (p − 1) | k, then a k ≡ 1 mod p, hence p | D = gcd(a k − 1, N ). Thus the following algorithm has a good chance of ﬁnding those factors p of N for which p − 1 has only small prime factors: 74 1. Pick a > 1 and check that gcd(a, N ) = 1 2. Choose a bound B, say B = 10 4, 105, 106, ... 3. Pick k as in (7.3) and compute D = gcd(a k − 1, N ). Note that the computation of a k can be done modulo N ; if p | N and (p − 1) | k, then a k ≡ 1 mod p, hence p | D. If D = 1, we may increase k; if D = N , we can reduce k and repeat the computation. Among the record factors found by the p − 1-method is the 37-digit factor p = 6902861817667290192729108442204980121 of 71 77 − 1 with p − 1 = 23 · 3 3 · 5 · 7 · 11 · 13 · 401 · 409 · 3167 · 83243 · 83983 · 800221 · 2197387 discovered by Dubner. A list of record factors can be found at http://www.users.globalnet.co.uk/∼aads/Pminus1.html Here’s a baby example: take N = 1769, a = 2 and B = 6. Then we compute k = 2 2·3·5 and we ﬁnd 2 60 ≡ 306 mod 1769, gcd(305, 1769) = 61 and N = 29·61. Note that 61 − 1 = 2 2 · 3 · 5, so the factor 61 was found, while 29 − 1 = 22 · 7 explains why 29 wasn’t (although 29 < 61). Another large class of factorization algorithms is based on an algorithm invented by Fermat: the idea is to write an integer n as a diﬀerence of squares. If n = x 2 − y2, then n = (x − y)(x + y), and unless this is the trivial factorization n = 1 · n, we have found a factor. Another baby example: take n = 1073; then √n = 32.756 . . ., so we start by trying to write n = 33 2 − y2. Since 33 2 − 1073 = 16, we ﬁnd n = 33 2 − 4 2 = (33 − 4)(33 + 4) = 29 · 37. If the ﬁrst attempt would have been unsuccessful, we would have tried n = 34 2 − y2, etc. In modern algorithms (continued fractions, quadratic sieve, number ﬁeld sieve) the equation N = x 2 − y2 is replaced by a congruence x 2 ≡ y2 mod N : if we have such a thing, then gcd(x − y, N ) has a good chance of being a nontrivial factor of N . The ﬁrst algorithm above constructed such pairs (x, y) by comput- ing the continued fraction expansion of √n (which we have not discussed), the number ﬁeld sieve produces such pairs by factoring certain elements in algebraic number ﬁelds. Exercises 7.1 Compute the addition and multiplication tables for the ring Z/2Z ⊕ Z/2Z, and compare the result to those for Z/4Z. 7.2 Do the same exercise for the rings Z/2Z ⊕ Z/3Z and Z/6Z. 7.3 Find all integers with ϕ(m) = 6. 7.4 Show that m is prime if and only if ϕ(m) = m − 1. 75 7.5 Solve the system of congruences x ≡ 12 mod 13, x ≡ 7 mod 19. 76","libVersion":"0.3.1","langs":""}