{"path":"iCloudDrive/bks/OlympiadQPs/Miscellaneous/tjusamo 2007/Contest2Sol.pdf","text":"TJUSAMO Contest 2: 11/02/2006 1. To tile a region R means to ﬁnd a set S of non-overlapping regions such that their union is R. Suppose R is a square with side length 1. (i) Is it possible to tile R with ﬁnitely many circles? (ii) Is it possible to tile R with ﬁnitely many 30 − 60 − 90 triangles such that their longest side has a rational length? Answer: It is impossible to perform either tiling. (i) Observe that a circle can be tangent to a line at at most one point. Now consider the line segment at the bottom of the square. As the circles cannot exceed the square, they can only cover the line via tangency to the line. However, a line has inﬁnitely many points, and so a ﬁnite number of circles cannot be tangent to every point on the line, completing the proof. (ii) If the longest side of the triangle (i.e. the hypotenuse) has length r, then the other two sides have length r 2 and √3r 2 , so that the triangle has area √3r2 8 . Note that this is a rational multiple of √3, since r is rational. Additionally, since the sum of two rationals is a rational, any ﬁnite set of non-overlapping triangles of this type will have a total area that is a rational multiple of √3. Note, however, that the square has an area of 1, which is not a rational multiple of √3. Therefore, the tiling is impossible, as stated. Note: In fact, it is possible to extend (i) to show that the only connected region tileable by a ﬁnite number of circles is a circle. This is done by observing that a circle can only be tangent to another circle at a point, that the circumference of a circle has an inﬁnite number of points, and that two tangent circles do not form a connected region (nor could another circle be placed to create a connected region about any point of tangency, as any such circle would need inﬁnitesimal radius). This same argument of inﬁnitesimal radius can additionally be used to oﬀer an alternate solution to the original problem, as a circle of inﬁnitesimal radius would be necessary to tile the corner of the square. 2. Consider an n row by m column grid G such that each element of the grid is a non-negative integer, the sum of the elements in the grid is n, each element in the grid is no less than the element below it or to its right, and no two elements in a single row diﬀer by more than 1. Prove that the number of distinct grids G is independent of m and that it is equal to the number of ways of writing n as a sum of non-decreasing positive integers. (For example, when n = 4, there are 5 ways to do this: 1 + 1 + 1 + 1, 1 + 1 + 2, 1 + 3, 2 + 2, and 4). Let Gi,j denote the element in the jth column of the ith row of G. We show ﬁrst that there is exactly one way for any given row to attain a particular sum S. If S = mk + r, then the smallest value of any element in a given row corresponds to k, and the number of elements that are larger than that value correspond to r. This can be most clearly seen by visualizing the row as a rectangle of base m and height k, along with a rectangle of base r and height 1. We now invoke a well-known result in number theory, which is that division is unique. That is, for any given value of m, there is a unique solution (k, r) across the integers, for 0 ≤ r < m, to the equation S = mk + r. Thus, we have shown that there is exactly one way to attain a sum S, as desired. Thus, for any arbitrary partition a1 + . . . + an of n, with a1 ≥ a2 ≥ . . . ≥ an ≥ 0, we 1 draw a one-to-one correspondence with a grid in which row i contains elements summing to ai (and thus show that the number of grids G is equal to the number of paritions of n, and thus clearly independent of m). It then only remains to show that such a grid follows all of the conditions. We can do this with the following algorithm: (i) Set c to 1. (ii) For 1 ≤ i ≤ n: —-(a) If ai = 0: Go to the next value of i. —-(b) Increase Gi,c by 1. —-(c) Decrease ai by 1. (iii) Increase c by 1 if c < m, otherwise set c to 1. (iv) If a1 > 0, go to (ii). We now prove by induction that if all conditions are satisﬁed before (ii) is executed, then all conditions must be satisﬁed after (ii) is executed. We enumerate the conditions here: Condition 1: a1 ≥ a2 ≥ . . . ≥ 0. Part (a) of (ii) guarantees that ai ≥ 0 for all i. Additionally, since all non-zero entries are decreased by 1 by step (ii), then if ai ≥ aj before step (ii) is executed, ai ≥ aj after its execution as well. Condition 2: Each number is no less than the number to its right. Within each row, the columns are incremented in order. Thus, if we are at a particular value of c, all columns before c have already been incremented by the algorithm (assuming ai is not 0), and so when we increment Gi,c, it can be no greater than the number to its left, which is equivalent to the desired condition. Condition 3: Each number is at most one more than any other number in its row. The algorithm increments every element in a given row before going back to re-increment any previous numbers in that row, so this condition is satisﬁed. Condition 4: Each number if no less than the number below it. If this condition holds before hand, as well as condition 1, then if ai = 0 then ai+1 = 0 as well, so neither Gi,c nor Gi+1,c would increase and the condition would hold. Otherwise, Gi,c increases by 1, and as each element in the grid can increase by at most 1 in any iteration of the algorithm, the condition must also hold. We have just shown that all four conditions hold, which completes the proof. 3. To a polynomial P (x) = ax3 + bx2 + cx + d, of degree at most 3, one can apply two operations: (a) ax3 + bx2 + cx + d becomes dx3 + cx2 + bx + a; (b) ax3 + bx2 + cx + d becomes a(x + t)3 + b(x + t)2 + c(x + t) + d. 2 Determine if one can transform, by applications of these operations, the polynomial P1(x) = x3 + x2 − 2x into P2(x) = x3 − 3x − 2. Answer: We show that it is impossible to perform the given transformation because both operations preserve the distinctness of roots. Let Pa(x) denote P (x) with the transformation a applied. It is easy to verify, ﬁrst of all, that if P (x) = a(x − r1)(x − r2)(x − r3), then Pa(x) = a(1 − r1x)(1 − r2x)(1 − r3x), and that the reverse transformation applies as well (so in the case of a quadratic, linear, etc. function, we can go backwards, letting r1 = 0). Thus, roots at zero map to nonexistent roots, nonexistent roots map to roots at 0, and all other roots map to their multiplicative inverses. As this is a one-to-one mapping, the uniqueness or nonuniqueness of roots must be preserved in the transformation. Operation b merely shifts the roots by t, which is once again an obvious one-to-one mapping, and so again uniqueness or nonuniqueness is preserved in the transformation. Now let us consider the two polynomials in question: P1(x) = x 3 + x 2 − 2x = x(x 2 + x − 2) = x(x + 2)(x − 1) P2(x) = (x + 1) 2(x − 2) P1(x) has three distinct roots, while P2(x) has only two, so the two polynomials can never be transformed to each other by application of (a) and (b), as stated. 3","libVersion":"0.3.1","langs":""}